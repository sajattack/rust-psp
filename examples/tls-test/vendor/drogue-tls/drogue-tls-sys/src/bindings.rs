/* automatically generated by rust-bindgen */

use drogue_ffi_compat::va_list as __va_list;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MPI_WINDOW_SIZE: u32 = 3;
pub const MPI_MAX_SIZE: u32 = 256;
pub const SSL_MAX_CONTENT_LEN: u32 = 1024;
pub const MB_LEN_MAX: u32 = 1;
pub const CHAR_MIN: u32 = 0;
pub const ERR_PLATFORM_HW_ACCEL_FAILED: i32 = -112;
pub const ERR_PLATFORM_FEATURE_UNSUPPORTED: i32 = -114;
pub const __GNUC_VA_LIST: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MPI_MAX_LIMBS: u32 = 10000;
pub const MPI_MAX_BITS: u32 = 2048;
pub const MPI_MAX_BITS_SCALE100: u32 = 204800;
pub const LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MPI_RW_BUFFER_SIZE: u32 = 633;
pub const ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const ERR_MD_HW_ACCEL_FAILED: i32 = -21120;
pub const MD_MAX_SIZE: u32 = 64;
pub const MD_MAX_BLOCK_SIZE: u32 = 128;
pub const ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const ERR_ECP_INVALID_KEY: i32 = -19584;
pub const ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const ERR_ECP_HW_ACCEL_FAILED: i32 = -19328;
pub const ERR_ECP_IN_PROGRESS: i32 = -19200;
pub const ECP_DP_MAX: u32 = 12;
pub const ECP_MAX_BITS: u32 = 521;
pub const ECP_MAX_BYTES: u32 = 66;
pub const ECP_MAX_PT_LEN: u32 = 133;
pub const ECP_WINDOW_SIZE: u32 = 6;
pub const ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const ECP_PF_UNCOMPRESSED: u32 = 0;
pub const ECP_PF_COMPRESSED: u32 = 1;
pub const ECP_TLS_NAMED_CURVE: u32 = 3;
pub const ERR_RSA_BAD_INPUT_DATA: i32 = -16512;
pub const ERR_RSA_INVALID_PADDING: i32 = -16640;
pub const ERR_RSA_KEY_GEN_FAILED: i32 = -16768;
pub const ERR_RSA_KEY_CHECK_FAILED: i32 = -16896;
pub const ERR_RSA_PUBLIC_FAILED: i32 = -17024;
pub const ERR_RSA_PRIVATE_FAILED: i32 = -17152;
pub const ERR_RSA_VERIFY_FAILED: i32 = -17280;
pub const ERR_RSA_OUTPUT_TOO_LARGE: i32 = -17408;
pub const ERR_RSA_RNG_FAILED: i32 = -17536;
pub const ERR_RSA_UNSUPPORTED_OPERATION: i32 = -17664;
pub const ERR_RSA_HW_ACCEL_FAILED: i32 = -17792;
pub const RSA_PUBLIC: u32 = 0;
pub const RSA_PRIVATE: u32 = 1;
pub const RSA_PKCS_V15: u32 = 0;
pub const RSA_PKCS_V21: u32 = 1;
pub const RSA_SIGN: u32 = 1;
pub const RSA_CRYPT: u32 = 2;
pub const RSA_SALT_LEN_ANY: i32 = -1;
pub const ERR_ASN1_OUT_OF_DATA: i32 = -96;
pub const ERR_ASN1_UNEXPECTED_TAG: i32 = -98;
pub const ERR_ASN1_INVALID_LENGTH: i32 = -100;
pub const ERR_ASN1_LENGTH_MISMATCH: i32 = -102;
pub const ERR_ASN1_INVALID_DATA: i32 = -104;
pub const ERR_ASN1_ALLOC_FAILED: i32 = -106;
pub const ERR_ASN1_BUF_TOO_SMALL: i32 = -108;
pub const ASN1_BOOLEAN: u32 = 1;
pub const ASN1_INTEGER: u32 = 2;
pub const ASN1_BIT_STRING: u32 = 3;
pub const ASN1_OCTET_STRING: u32 = 4;
pub const ASN1_NULL: u32 = 5;
pub const ASN1_OID: u32 = 6;
pub const ASN1_ENUMERATED: u32 = 10;
pub const ASN1_UTF8_STRING: u32 = 12;
pub const ASN1_SEQUENCE: u32 = 16;
pub const ASN1_SET: u32 = 17;
pub const ASN1_PRINTABLE_STRING: u32 = 19;
pub const ASN1_T61_STRING: u32 = 20;
pub const ASN1_IA5_STRING: u32 = 22;
pub const ASN1_UTC_TIME: u32 = 23;
pub const ASN1_GENERALIZED_TIME: u32 = 24;
pub const ASN1_UNIVERSAL_STRING: u32 = 28;
pub const ASN1_BMP_STRING: u32 = 30;
pub const ASN1_PRIMITIVE: u32 = 0;
pub const ASN1_CONSTRUCTED: u32 = 32;
pub const ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const ASN1_TAG_CLASS_MASK: u32 = 192;
pub const ASN1_TAG_PC_MASK: u32 = 32;
pub const ASN1_TAG_VALUE_MASK: u32 = 31;
pub const ERR_PK_ALLOC_FAILED: i32 = -16256;
pub const ERR_PK_TYPE_MISMATCH: i32 = -16128;
pub const ERR_PK_BAD_INPUT_DATA: i32 = -16000;
pub const ERR_PK_FILE_IO_ERROR: i32 = -15872;
pub const ERR_PK_KEY_INVALID_VERSION: i32 = -15744;
pub const ERR_PK_KEY_INVALID_FORMAT: i32 = -15616;
pub const ERR_PK_UNKNOWN_PK_ALG: i32 = -15488;
pub const ERR_PK_PASSWORD_REQUIRED: i32 = -15360;
pub const ERR_PK_PASSWORD_MISMATCH: i32 = -15232;
pub const ERR_PK_INVALID_PUBKEY: i32 = -15104;
pub const ERR_PK_INVALID_ALG: i32 = -14976;
pub const ERR_PK_UNKNOWN_NAMED_CURVE: i32 = -14848;
pub const ERR_PK_FEATURE_UNAVAILABLE: i32 = -14720;
pub const ERR_PK_SIG_LEN_MISMATCH: i32 = -14592;
pub const ERR_PK_HW_ACCEL_FAILED: i32 = -14464;
pub const PK_SIGNATURE_MAX_SIZE: u32 = 0;
pub const PK_DEBUG_MAX_ITEMS: u32 = 3;
pub const X509_MAX_INTERMEDIATE_CA: u32 = 8;
pub const ERR_X509_FEATURE_UNAVAILABLE: i32 = -8320;
pub const ERR_X509_UNKNOWN_OID: i32 = -8448;
pub const ERR_X509_INVALID_FORMAT: i32 = -8576;
pub const ERR_X509_INVALID_VERSION: i32 = -8704;
pub const ERR_X509_INVALID_SERIAL: i32 = -8832;
pub const ERR_X509_INVALID_ALG: i32 = -8960;
pub const ERR_X509_INVALID_NAME: i32 = -9088;
pub const ERR_X509_INVALID_DATE: i32 = -9216;
pub const ERR_X509_INVALID_SIGNATURE: i32 = -9344;
pub const ERR_X509_INVALID_EXTENSIONS: i32 = -9472;
pub const ERR_X509_UNKNOWN_VERSION: i32 = -9600;
pub const ERR_X509_UNKNOWN_SIG_ALG: i32 = -9728;
pub const ERR_X509_SIG_MISMATCH: i32 = -9856;
pub const ERR_X509_CERT_VERIFY_FAILED: i32 = -9984;
pub const ERR_X509_CERT_UNKNOWN_FORMAT: i32 = -10112;
pub const ERR_X509_BAD_INPUT_DATA: i32 = -10240;
pub const ERR_X509_ALLOC_FAILED: i32 = -10368;
pub const ERR_X509_FILE_IO_ERROR: i32 = -10496;
pub const ERR_X509_BUFFER_TOO_SMALL: i32 = -10624;
pub const ERR_X509_FATAL_ERROR: i32 = -12288;
pub const X509_BADCERT_EXPIRED: u32 = 1;
pub const X509_BADCERT_REVOKED: u32 = 2;
pub const X509_BADCERT_CN_MISMATCH: u32 = 4;
pub const X509_BADCERT_NOT_TRUSTED: u32 = 8;
pub const X509_BADCRL_NOT_TRUSTED: u32 = 16;
pub const X509_BADCRL_EXPIRED: u32 = 32;
pub const X509_BADCERT_MISSING: u32 = 64;
pub const X509_BADCERT_SKIP_VERIFY: u32 = 128;
pub const X509_BADCERT_OTHER: u32 = 256;
pub const X509_BADCERT_FUTURE: u32 = 512;
pub const X509_BADCRL_FUTURE: u32 = 1024;
pub const X509_BADCERT_KEY_USAGE: u32 = 2048;
pub const X509_BADCERT_EXT_KEY_USAGE: u32 = 4096;
pub const X509_BADCERT_NS_CERT_TYPE: u32 = 8192;
pub const X509_BADCERT_BAD_MD: u32 = 16384;
pub const X509_BADCERT_BAD_PK: u32 = 32768;
pub const X509_BADCERT_BAD_KEY: u32 = 65536;
pub const X509_BADCRL_BAD_MD: u32 = 131072;
pub const X509_BADCRL_BAD_PK: u32 = 262144;
pub const X509_BADCRL_BAD_KEY: u32 = 524288;
pub const X509_SAN_OTHER_NAME: u32 = 0;
pub const X509_SAN_RFC822_NAME: u32 = 1;
pub const X509_SAN_DNS_NAME: u32 = 2;
pub const X509_SAN_X400_ADDRESS_NAME: u32 = 3;
pub const X509_SAN_DIRECTORY_NAME: u32 = 4;
pub const X509_SAN_EDI_PARTY_NAME: u32 = 5;
pub const X509_SAN_UNIFORM_RESOURCE_IDENTIFIER: u32 = 6;
pub const X509_SAN_IP_ADDRESS: u32 = 7;
pub const X509_SAN_REGISTERED_ID: u32 = 8;
pub const X509_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const X509_KU_NON_REPUDIATION: u32 = 64;
pub const X509_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const X509_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const X509_KU_KEY_AGREEMENT: u32 = 8;
pub const X509_KU_KEY_CERT_SIGN: u32 = 4;
pub const X509_KU_CRL_SIGN: u32 = 2;
pub const X509_KU_ENCIPHER_ONLY: u32 = 1;
pub const X509_KU_DECIPHER_ONLY: u32 = 32768;
pub const X509_NS_CERT_TYPE_SSL_CLIENT: u32 = 128;
pub const X509_NS_CERT_TYPE_SSL_SERVER: u32 = 64;
pub const X509_NS_CERT_TYPE_EMAIL: u32 = 32;
pub const X509_NS_CERT_TYPE_OBJECT_SIGNING: u32 = 16;
pub const X509_NS_CERT_TYPE_RESERVED: u32 = 8;
pub const X509_NS_CERT_TYPE_SSL_CA: u32 = 4;
pub const X509_NS_CERT_TYPE_EMAIL_CA: u32 = 2;
pub const X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: u32 = 1;
pub const X509_FORMAT_DER: u32 = 1;
pub const X509_FORMAT_PEM: u32 = 2;
pub const X509_MAX_DN_NAME_SIZE: u32 = 256;
pub const ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const ERR_CIPHER_HW_ACCEL_FAILED: i32 = -25600;
pub const CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MAX_IV_LENGTH: u32 = 16;
pub const MAX_BLOCK_LENGTH: u32 = 16;
pub const TLS_RSA_WITH_NULL_MD5: u32 = 1;
pub const TLS_RSA_WITH_NULL_SHA: u32 = 2;
pub const TLS_RSA_WITH_RC4_128_MD5: u32 = 4;
pub const TLS_RSA_WITH_RC4_128_SHA: u32 = 5;
pub const TLS_RSA_WITH_DES_CBC_SHA: u32 = 9;
pub const TLS_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 10;
pub const TLS_DHE_RSA_WITH_DES_CBC_SHA: u32 = 21;
pub const TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 22;
pub const TLS_PSK_WITH_NULL_SHA: u32 = 44;
pub const TLS_DHE_PSK_WITH_NULL_SHA: u32 = 45;
pub const TLS_RSA_PSK_WITH_NULL_SHA: u32 = 46;
pub const TLS_RSA_WITH_AES_128_CBC_SHA: u32 = 47;
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA: u32 = 51;
pub const TLS_RSA_WITH_AES_256_CBC_SHA: u32 = 53;
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA: u32 = 57;
pub const TLS_RSA_WITH_NULL_SHA256: u32 = 59;
pub const TLS_RSA_WITH_AES_128_CBC_SHA256: u32 = 60;
pub const TLS_RSA_WITH_AES_256_CBC_SHA256: u32 = 61;
pub const TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 65;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 69;
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 103;
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: u32 = 107;
pub const TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 132;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 136;
pub const TLS_PSK_WITH_RC4_128_SHA: u32 = 138;
pub const TLS_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 139;
pub const TLS_PSK_WITH_AES_128_CBC_SHA: u32 = 140;
pub const TLS_PSK_WITH_AES_256_CBC_SHA: u32 = 141;
pub const TLS_DHE_PSK_WITH_RC4_128_SHA: u32 = 142;
pub const TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 143;
pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 144;
pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 145;
pub const TLS_RSA_PSK_WITH_RC4_128_SHA: u32 = 146;
pub const TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 147;
pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 148;
pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 149;
pub const TLS_RSA_WITH_AES_128_GCM_SHA256: u32 = 156;
pub const TLS_RSA_WITH_AES_256_GCM_SHA384: u32 = 157;
pub const TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 158;
pub const TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 159;
pub const TLS_PSK_WITH_AES_128_GCM_SHA256: u32 = 168;
pub const TLS_PSK_WITH_AES_256_GCM_SHA384: u32 = 169;
pub const TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: u32 = 170;
pub const TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: u32 = 171;
pub const TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: u32 = 172;
pub const TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: u32 = 173;
pub const TLS_PSK_WITH_AES_128_CBC_SHA256: u32 = 174;
pub const TLS_PSK_WITH_AES_256_CBC_SHA384: u32 = 175;
pub const TLS_PSK_WITH_NULL_SHA256: u32 = 176;
pub const TLS_PSK_WITH_NULL_SHA384: u32 = 177;
pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 178;
pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 179;
pub const TLS_DHE_PSK_WITH_NULL_SHA256: u32 = 180;
pub const TLS_DHE_PSK_WITH_NULL_SHA384: u32 = 181;
pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 182;
pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 183;
pub const TLS_RSA_PSK_WITH_NULL_SHA256: u32 = 184;
pub const TLS_RSA_PSK_WITH_NULL_SHA384: u32 = 185;
pub const TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 186;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 190;
pub const TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 192;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 196;
pub const TLS_ECDH_ECDSA_WITH_NULL_SHA: u32 = 49153;
pub const TLS_ECDH_ECDSA_WITH_RC4_128_SHA: u32 = 49154;
pub const TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49155;
pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49156;
pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49157;
pub const TLS_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 49158;
pub const TLS_ECDHE_ECDSA_WITH_RC4_128_SHA: u32 = 49159;
pub const TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: u32 = 49160;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49161;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49162;
pub const TLS_ECDH_RSA_WITH_NULL_SHA: u32 = 49163;
pub const TLS_ECDH_RSA_WITH_RC4_128_SHA: u32 = 49164;
pub const TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49165;
pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 49166;
pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 49167;
pub const TLS_ECDHE_RSA_WITH_NULL_SHA: u32 = 49168;
pub const TLS_ECDHE_RSA_WITH_RC4_128_SHA: u32 = 49169;
pub const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: u32 = 49170;
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 49171;
pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 49172;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49187;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49188;
pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49189;
pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49190;
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 49191;
pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: u32 = 49192;
pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: u32 = 49193;
pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: u32 = 49194;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49195;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49196;
pub const TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49197;
pub const TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49198;
pub const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 49199;
pub const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 49200;
pub const TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 49201;
pub const TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 49202;
pub const TLS_ECDHE_PSK_WITH_RC4_128_SHA: u32 = 49203;
pub const TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: u32 = 49204;
pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 49205;
pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 49206;
pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 49207;
pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 49208;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA: u32 = 49209;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA256: u32 = 49210;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA384: u32 = 49211;
pub const TLS_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49212;
pub const TLS_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49213;
pub const TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49220;
pub const TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49221;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49224;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49225;
pub const TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49226;
pub const TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49227;
pub const TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49228;
pub const TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49229;
pub const TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49230;
pub const TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49231;
pub const TLS_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49232;
pub const TLS_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49233;
pub const TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49234;
pub const TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49235;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49244;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49245;
pub const TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49246;
pub const TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49247;
pub const TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49248;
pub const TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49249;
pub const TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49250;
pub const TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49251;
pub const TLS_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49252;
pub const TLS_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49253;
pub const TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49254;
pub const TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49255;
pub const TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49256;
pub const TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49257;
pub const TLS_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49258;
pub const TLS_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49259;
pub const TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49260;
pub const TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49261;
pub const TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49262;
pub const TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49263;
pub const TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49264;
pub const TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49265;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49266;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49267;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49268;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49269;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49270;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49271;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49272;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49273;
pub const TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49274;
pub const TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49275;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49276;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49277;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49286;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49287;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49288;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49289;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49290;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49291;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49292;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49293;
pub const TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49294;
pub const TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49295;
pub const TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49296;
pub const TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49297;
pub const TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49298;
pub const TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49299;
pub const TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49300;
pub const TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49301;
pub const TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49302;
pub const TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49303;
pub const TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49304;
pub const TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49305;
pub const TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49306;
pub const TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49307;
pub const TLS_RSA_WITH_AES_128_CCM: u32 = 49308;
pub const TLS_RSA_WITH_AES_256_CCM: u32 = 49309;
pub const TLS_DHE_RSA_WITH_AES_128_CCM: u32 = 49310;
pub const TLS_DHE_RSA_WITH_AES_256_CCM: u32 = 49311;
pub const TLS_RSA_WITH_AES_128_CCM_8: u32 = 49312;
pub const TLS_RSA_WITH_AES_256_CCM_8: u32 = 49313;
pub const TLS_DHE_RSA_WITH_AES_128_CCM_8: u32 = 49314;
pub const TLS_DHE_RSA_WITH_AES_256_CCM_8: u32 = 49315;
pub const TLS_PSK_WITH_AES_128_CCM: u32 = 49316;
pub const TLS_PSK_WITH_AES_256_CCM: u32 = 49317;
pub const TLS_DHE_PSK_WITH_AES_128_CCM: u32 = 49318;
pub const TLS_DHE_PSK_WITH_AES_256_CCM: u32 = 49319;
pub const TLS_PSK_WITH_AES_128_CCM_8: u32 = 49320;
pub const TLS_PSK_WITH_AES_256_CCM_8: u32 = 49321;
pub const TLS_DHE_PSK_WITH_AES_128_CCM_8: u32 = 49322;
pub const TLS_DHE_PSK_WITH_AES_256_CCM_8: u32 = 49323;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 49324;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 49325;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 49326;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 49327;
pub const TLS_ECJPAKE_WITH_AES_128_CCM_8: u32 = 49407;
pub const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52392;
pub const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52393;
pub const TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52394;
pub const TLS_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52395;
pub const TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52396;
pub const TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52397;
pub const TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52398;
pub const CIPHERSUITE_WEAK: u32 = 1;
pub const CIPHERSUITE_SHORT_TAG: u32 = 2;
pub const CIPHERSUITE_NODTLS: u32 = 4;
pub const X509_CRT_VERSION_1: u32 = 0;
pub const X509_CRT_VERSION_2: u32 = 1;
pub const X509_CRT_VERSION_3: u32 = 2;
pub const X509_RFC5280_MAX_SERIAL_LEN: u32 = 32;
pub const X509_RFC5280_UTC_TIME_LEN: u32 = 15;
pub const X509_MAX_FILE_PATH_LEN: u32 = 512;
pub const X509_MAX_VERIFY_CHAIN_SIZE: u32 = 10;
pub const ERR_DHM_BAD_INPUT_DATA: i32 = -12416;
pub const ERR_DHM_READ_PARAMS_FAILED: i32 = -12544;
pub const ERR_DHM_MAKE_PARAMS_FAILED: i32 = -12672;
pub const ERR_DHM_READ_PUBLIC_FAILED: i32 = -12800;
pub const ERR_DHM_MAKE_PUBLIC_FAILED: i32 = -12928;
pub const ERR_DHM_CALC_SECRET_FAILED: i32 = -13056;
pub const ERR_DHM_INVALID_FORMAT: i32 = -13184;
pub const ERR_DHM_ALLOC_FAILED: i32 = -13312;
pub const ERR_DHM_FILE_IO_ERROR: i32 = -13440;
pub const ERR_DHM_HW_ACCEL_FAILED: i32 = -13568;
pub const ERR_DHM_SET_GROUP_FAILED: i32 = -13696;
pub const ERR_SSL_FEATURE_UNAVAILABLE: i32 = -28800;
pub const ERR_SSL_BAD_INPUT_DATA: i32 = -28928;
pub const ERR_SSL_INVALID_MAC: i32 = -29056;
pub const ERR_SSL_INVALID_RECORD: i32 = -29184;
pub const ERR_SSL_CONN_EOF: i32 = -29312;
pub const ERR_SSL_UNKNOWN_CIPHER: i32 = -29440;
pub const ERR_SSL_NO_CIPHER_CHOSEN: i32 = -29568;
pub const ERR_SSL_NO_RNG: i32 = -29696;
pub const ERR_SSL_NO_CLIENT_CERTIFICATE: i32 = -29824;
pub const ERR_SSL_CERTIFICATE_TOO_LARGE: i32 = -29952;
pub const ERR_SSL_CERTIFICATE_REQUIRED: i32 = -30080;
pub const ERR_SSL_PRIVATE_KEY_REQUIRED: i32 = -30208;
pub const ERR_SSL_CA_CHAIN_REQUIRED: i32 = -30336;
pub const ERR_SSL_UNEXPECTED_MESSAGE: i32 = -30464;
pub const ERR_SSL_FATAL_ALERT_MESSAGE: i32 = -30592;
pub const ERR_SSL_PEER_VERIFY_FAILED: i32 = -30720;
pub const ERR_SSL_PEER_CLOSE_NOTIFY: i32 = -30848;
pub const ERR_SSL_BAD_HS_CLIENT_HELLO: i32 = -30976;
pub const ERR_SSL_BAD_HS_SERVER_HELLO: i32 = -31104;
pub const ERR_SSL_BAD_HS_CERTIFICATE: i32 = -31232;
pub const ERR_SSL_BAD_HS_CERTIFICATE_REQUEST: i32 = -31360;
pub const ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE: i32 = -31488;
pub const ERR_SSL_BAD_HS_SERVER_HELLO_DONE: i32 = -31616;
pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE: i32 = -31744;
pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP: i32 = -31872;
pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS: i32 = -32000;
pub const ERR_SSL_BAD_HS_CERTIFICATE_VERIFY: i32 = -32128;
pub const ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC: i32 = -32256;
pub const ERR_SSL_BAD_HS_FINISHED: i32 = -32384;
pub const ERR_SSL_ALLOC_FAILED: i32 = -32512;
pub const ERR_SSL_HW_ACCEL_FAILED: i32 = -32640;
pub const ERR_SSL_HW_ACCEL_FALLTHROUGH: i32 = -28544;
pub const ERR_SSL_COMPRESSION_FAILED: i32 = -28416;
pub const ERR_SSL_BAD_HS_PROTOCOL_VERSION: i32 = -28288;
pub const ERR_SSL_BAD_HS_NEW_SESSION_TICKET: i32 = -28160;
pub const ERR_SSL_SESSION_TICKET_EXPIRED: i32 = -28032;
pub const ERR_SSL_PK_TYPE_MISMATCH: i32 = -27904;
pub const ERR_SSL_UNKNOWN_IDENTITY: i32 = -27776;
pub const ERR_SSL_INTERNAL_ERROR: i32 = -27648;
pub const ERR_SSL_COUNTER_WRAPPING: i32 = -27520;
pub const ERR_SSL_WAITING_SERVER_HELLO_RENEGO: i32 = -27392;
pub const ERR_SSL_HELLO_VERIFY_REQUIRED: i32 = -27264;
pub const ERR_SSL_BUFFER_TOO_SMALL: i32 = -27136;
pub const ERR_SSL_NO_USABLE_CIPHERSUITE: i32 = -27008;
pub const ERR_SSL_WANT_READ: i32 = -26880;
pub const ERR_SSL_WANT_WRITE: i32 = -26752;
pub const ERR_SSL_TIMEOUT: i32 = -26624;
pub const ERR_SSL_CLIENT_RECONNECT: i32 = -26496;
pub const ERR_SSL_UNEXPECTED_RECORD: i32 = -26368;
pub const ERR_SSL_NON_FATAL: i32 = -26240;
pub const ERR_SSL_INVALID_VERIFY_HASH: i32 = -26112;
pub const ERR_SSL_CONTINUE_PROCESSING: i32 = -25984;
pub const ERR_SSL_ASYNC_IN_PROGRESS: i32 = -25856;
pub const ERR_SSL_EARLY_MESSAGE: i32 = -25728;
pub const ERR_SSL_UNEXPECTED_CID: i32 = -24576;
pub const ERR_SSL_VERSION_MISMATCH: i32 = -24320;
pub const ERR_SSL_CRYPTO_IN_PROGRESS: i32 = -28672;
pub const ERR_SSL_BAD_CONFIG: i32 = -24192;
pub const SSL_MAJOR_VERSION_3: u32 = 3;
pub const SSL_MINOR_VERSION_0: u32 = 0;
pub const SSL_MINOR_VERSION_1: u32 = 1;
pub const SSL_MINOR_VERSION_2: u32 = 2;
pub const SSL_MINOR_VERSION_3: u32 = 3;
pub const SSL_MINOR_VERSION_4: u32 = 4;
pub const SSL_TRANSPORT_STREAM: u32 = 0;
pub const SSL_TRANSPORT_DATAGRAM: u32 = 1;
pub const SSL_MAX_HOST_NAME_LEN: u32 = 255;
pub const SSL_MAX_ALPN_NAME_LEN: u32 = 255;
pub const SSL_MAX_ALPN_LIST_LEN: u32 = 65535;
pub const SSL_MAX_FRAG_LEN_NONE: u32 = 0;
pub const SSL_MAX_FRAG_LEN_512: u32 = 1;
pub const SSL_MAX_FRAG_LEN_1024: u32 = 2;
pub const SSL_MAX_FRAG_LEN_2048: u32 = 3;
pub const SSL_MAX_FRAG_LEN_4096: u32 = 4;
pub const SSL_MAX_FRAG_LEN_INVALID: u32 = 5;
pub const SSL_IS_CLIENT: u32 = 0;
pub const SSL_IS_SERVER: u32 = 1;
pub const SSL_IS_NOT_FALLBACK: u32 = 0;
pub const SSL_IS_FALLBACK: u32 = 1;
pub const SSL_EXTENDED_MS_DISABLED: u32 = 0;
pub const SSL_EXTENDED_MS_ENABLED: u32 = 1;
pub const SSL_CID_DISABLED: u32 = 0;
pub const SSL_CID_ENABLED: u32 = 1;
pub const SSL_ETM_DISABLED: u32 = 0;
pub const SSL_ETM_ENABLED: u32 = 1;
pub const SSL_COMPRESS_NULL: u32 = 0;
pub const SSL_COMPRESS_DEFLATE: u32 = 1;
pub const SSL_VERIFY_NONE: u32 = 0;
pub const SSL_VERIFY_OPTIONAL: u32 = 1;
pub const SSL_VERIFY_REQUIRED: u32 = 2;
pub const SSL_VERIFY_UNSET: u32 = 3;
pub const SSL_LEGACY_RENEGOTIATION: u32 = 0;
pub const SSL_SECURE_RENEGOTIATION: u32 = 1;
pub const SSL_RENEGOTIATION_DISABLED: u32 = 0;
pub const SSL_RENEGOTIATION_ENABLED: u32 = 1;
pub const SSL_ANTI_REPLAY_DISABLED: u32 = 0;
pub const SSL_ANTI_REPLAY_ENABLED: u32 = 1;
pub const SSL_RENEGOTIATION_NOT_ENFORCED: i32 = -1;
pub const SSL_RENEGO_MAX_RECORDS_DEFAULT: u32 = 16;
pub const SSL_LEGACY_NO_RENEGOTIATION: u32 = 0;
pub const SSL_LEGACY_ALLOW_RENEGOTIATION: u32 = 1;
pub const SSL_LEGACY_BREAK_HANDSHAKE: u32 = 2;
pub const SSL_TRUNC_HMAC_DISABLED: u32 = 0;
pub const SSL_TRUNC_HMAC_ENABLED: u32 = 1;
pub const SSL_TRUNCATED_HMAC_LEN: u32 = 10;
pub const SSL_SESSION_TICKETS_DISABLED: u32 = 0;
pub const SSL_SESSION_TICKETS_ENABLED: u32 = 1;
pub const SSL_CBC_RECORD_SPLITTING_DISABLED: u32 = 0;
pub const SSL_CBC_RECORD_SPLITTING_ENABLED: u32 = 1;
pub const SSL_ARC4_ENABLED: u32 = 0;
pub const SSL_ARC4_DISABLED: u32 = 1;
pub const SSL_PRESET_DEFAULT: u32 = 0;
pub const SSL_PRESET_SUITEB: u32 = 2;
pub const SSL_CERT_REQ_CA_LIST_ENABLED: u32 = 1;
pub const SSL_CERT_REQ_CA_LIST_DISABLED: u32 = 0;
pub const SSL_DTLS_TIMEOUT_DFL_MIN: u32 = 1000;
pub const SSL_DTLS_TIMEOUT_DFL_MAX: u32 = 60000;
pub const SSL_DEFAULT_TICKET_LIFETIME: u32 = 86400;
pub const SSL_IN_CONTENT_LEN: u32 = 1024;
pub const SSL_OUT_CONTENT_LEN: u32 = 1024;
pub const SSL_DTLS_MAX_BUFFERING: u32 = 32768;
pub const SSL_CID_IN_LEN_MAX: u32 = 32;
pub const SSL_CID_OUT_LEN_MAX: u32 = 32;
pub const SSL_CID_PADDING_GRANULARITY: u32 = 16;
pub const SSL_TLS1_3_PADDING_GRANULARITY: u32 = 1;
pub const SSL_VERIFY_DATA_MAX_LEN: u32 = 12;
pub const SSL_EMPTY_RENEGOTIATION_INFO: u32 = 255;
pub const SSL_FALLBACK_SCSV_VALUE: u32 = 22016;
pub const SSL_HASH_NONE: u32 = 0;
pub const SSL_HASH_MD5: u32 = 1;
pub const SSL_HASH_SHA1: u32 = 2;
pub const SSL_HASH_SHA224: u32 = 3;
pub const SSL_HASH_SHA256: u32 = 4;
pub const SSL_HASH_SHA384: u32 = 5;
pub const SSL_HASH_SHA512: u32 = 6;
pub const SSL_SIG_ANON: u32 = 0;
pub const SSL_SIG_RSA: u32 = 1;
pub const SSL_SIG_ECDSA: u32 = 3;
pub const SSL_CERT_TYPE_RSA_SIGN: u32 = 1;
pub const SSL_CERT_TYPE_ECDSA_SIGN: u32 = 64;
pub const SSL_MSG_CHANGE_CIPHER_SPEC: u32 = 20;
pub const SSL_MSG_ALERT: u32 = 21;
pub const SSL_MSG_HANDSHAKE: u32 = 22;
pub const SSL_MSG_APPLICATION_DATA: u32 = 23;
pub const SSL_MSG_CID: u32 = 25;
pub const SSL_ALERT_LEVEL_WARNING: u32 = 1;
pub const SSL_ALERT_LEVEL_FATAL: u32 = 2;
pub const SSL_ALERT_MSG_CLOSE_NOTIFY: u32 = 0;
pub const SSL_ALERT_MSG_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL_ALERT_MSG_BAD_RECORD_MAC: u32 = 20;
pub const SSL_ALERT_MSG_DECRYPTION_FAILED: u32 = 21;
pub const SSL_ALERT_MSG_RECORD_OVERFLOW: u32 = 22;
pub const SSL_ALERT_MSG_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL_ALERT_MSG_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL_ALERT_MSG_NO_CERT: u32 = 41;
pub const SSL_ALERT_MSG_BAD_CERT: u32 = 42;
pub const SSL_ALERT_MSG_UNSUPPORTED_CERT: u32 = 43;
pub const SSL_ALERT_MSG_CERT_REVOKED: u32 = 44;
pub const SSL_ALERT_MSG_CERT_EXPIRED: u32 = 45;
pub const SSL_ALERT_MSG_CERT_UNKNOWN: u32 = 46;
pub const SSL_ALERT_MSG_ILLEGAL_PARAMETER: u32 = 47;
pub const SSL_ALERT_MSG_UNKNOWN_CA: u32 = 48;
pub const SSL_ALERT_MSG_ACCESS_DENIED: u32 = 49;
pub const SSL_ALERT_MSG_DECODE_ERROR: u32 = 50;
pub const SSL_ALERT_MSG_DECRYPT_ERROR: u32 = 51;
pub const SSL_ALERT_MSG_EXPORT_RESTRICTION: u32 = 60;
pub const SSL_ALERT_MSG_PROTOCOL_VERSION: u32 = 70;
pub const SSL_ALERT_MSG_INSUFFICIENT_SECURITY: u32 = 71;
pub const SSL_ALERT_MSG_INTERNAL_ERROR: u32 = 80;
pub const SSL_ALERT_MSG_INAPROPRIATE_FALLBACK: u32 = 86;
pub const SSL_ALERT_MSG_USER_CANCELED: u32 = 90;
pub const SSL_ALERT_MSG_NO_RENEGOTIATION: u32 = 100;
pub const SSL_ALERT_MSG_UNSUPPORTED_EXT: u32 = 110;
pub const SSL_ALERT_MSG_UNRECOGNIZED_NAME: u32 = 112;
pub const SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const SSL_HS_HELLO_REQUEST: u32 = 0;
pub const SSL_HS_CLIENT_HELLO: u32 = 1;
pub const SSL_HS_SERVER_HELLO: u32 = 2;
pub const SSL_HS_HELLO_VERIFY_REQUEST: u32 = 3;
pub const SSL_HS_NEW_SESSION_TICKET: u32 = 4;
pub const SSL_HS_CERTIFICATE: u32 = 11;
pub const SSL_HS_SERVER_KEY_EXCHANGE: u32 = 12;
pub const SSL_HS_CERTIFICATE_REQUEST: u32 = 13;
pub const SSL_HS_SERVER_HELLO_DONE: u32 = 14;
pub const SSL_HS_CERTIFICATE_VERIFY: u32 = 15;
pub const SSL_HS_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const SSL_HS_FINISHED: u32 = 20;
pub const TLS_EXT_SERVERNAME: u32 = 0;
pub const TLS_EXT_SERVERNAME_HOSTNAME: u32 = 0;
pub const TLS_EXT_MAX_FRAGMENT_LENGTH: u32 = 1;
pub const TLS_EXT_TRUNCATED_HMAC: u32 = 4;
pub const TLS_EXT_SUPPORTED_ELLIPTIC_CURVES: u32 = 10;
pub const TLS_EXT_SUPPORTED_POINT_FORMATS: u32 = 11;
pub const TLS_EXT_SIG_ALG: u32 = 13;
pub const TLS_EXT_ALPN: u32 = 16;
pub const TLS_EXT_ENCRYPT_THEN_MAC: u32 = 22;
pub const TLS_EXT_EXTENDED_MASTER_SECRET: u32 = 23;
pub const TLS_EXT_SESSION_TICKET: u32 = 35;
pub const TLS_EXT_CID: u32 = 254;
pub const TLS_EXT_ECJPAKE_KKPP: u32 = 256;
pub const TLS_EXT_RENEGOTIATION_INFO: u32 = 65281;
pub const PSK_MAX_LEN: u32 = 32;
pub const ERR_MD5_HW_ACCEL_FAILED: i32 = -47;
pub const ERR_SHA1_HW_ACCEL_FAILED: i32 = -53;
pub const ERR_SHA1_BAD_INPUT_DATA: i32 = -115;
pub const ERR_SHA256_HW_ACCEL_FAILED: i32 = -55;
pub const ERR_SHA256_BAD_INPUT_DATA: i32 = -116;
pub const ERR_SHA512_HW_ACCEL_FAILED: i32 = -57;
pub const ERR_SHA512_BAD_INPUT_DATA: i32 = -117;
pub const SSL_MIN_MAJOR_VERSION: u32 = 3;
pub const SSL_MIN_MINOR_VERSION: u32 = 1;
pub const SSL_MIN_VALID_MINOR_VERSION: u32 = 1;
pub const SSL_MIN_VALID_MAJOR_VERSION: u32 = 3;
pub const SSL_MAX_MAJOR_VERSION: u32 = 3;
pub const SSL_MAX_MINOR_VERSION: u32 = 3;
pub const SSL_INITIAL_HANDSHAKE: u32 = 0;
pub const SSL_RENEGOTIATION_IN_PROGRESS: u32 = 1;
pub const SSL_RENEGOTIATION_DONE: u32 = 2;
pub const SSL_RENEGOTIATION_PENDING: u32 = 3;
pub const SSL_RETRANS_PREPARING: u32 = 0;
pub const SSL_RETRANS_SENDING: u32 = 1;
pub const SSL_RETRANS_WAITING: u32 = 2;
pub const SSL_RETRANS_FINISHED: u32 = 3;
pub const SSL_COMPRESSION_ADD: u32 = 0;
pub const SSL_MAC_ADD: u32 = 48;
pub const SSL_PADDING_ADD: u32 = 256;
pub const SSL_MAX_CID_EXPANSION: u32 = 0;
pub const SSL_PAYLOAD_OVERHEAD: u32 = 320;
pub const SSL_IN_PAYLOAD_LEN: u32 = 1344;
pub const SSL_OUT_PAYLOAD_LEN: u32 = 1344;
pub const SSL_MAX_BUFFERED_HS: u32 = 4;
pub const SSL_MAX_SIG_HASH_ALG_LIST_LEN: u32 = 65534;
pub const SSL_MAX_CURVE_LIST_LEN: u32 = 65535;
pub const SSL_HEADER_LEN: u32 = 13;
pub const SSL_IN_BUFFER_LEN: u32 = 1357;
pub const SSL_OUT_BUFFER_LEN: u32 = 1357;
pub const TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT: u32 = 1;
pub const TLS_EXT_ECJPAKE_KKPP_OK: u32 = 2;
pub const SSL_CID_LEN_MAX: u32 = 32;
pub const ERR_HMAC_DRBG_REQUEST_TOO_BIG: i32 = -3;
pub const ERR_HMAC_DRBG_INPUT_TOO_BIG: i32 = -5;
pub const ERR_HMAC_DRBG_FILE_IO_ERROR: i32 = -7;
pub const ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED: i32 = -9;
pub const HMAC_DRBG_RESEED_INTERVAL: u32 = 10000;
pub const HMAC_DRBG_MAX_INPUT: u32 = 256;
pub const HMAC_DRBG_MAX_REQUEST: u32 = 1024;
pub const HMAC_DRBG_MAX_SEED_INPUT: u32 = 384;
pub const HMAC_DRBG_PR_OFF: u32 = 0;
pub const HMAC_DRBG_PR_ON: u32 = 1;
pub const ERR_OID_NOT_FOUND: i32 = -46;
pub const ERR_OID_BUF_TOO_SMALL: i32 = -11;
pub const OID_X509_EXT_AUTHORITY_KEY_IDENTIFIER: u32 = 1;
pub const OID_X509_EXT_SUBJECT_KEY_IDENTIFIER: u32 = 2;
pub const OID_X509_EXT_KEY_USAGE: u32 = 4;
pub const OID_X509_EXT_CERTIFICATE_POLICIES: u32 = 8;
pub const OID_X509_EXT_POLICY_MAPPINGS: u32 = 16;
pub const OID_X509_EXT_SUBJECT_ALT_NAME: u32 = 32;
pub const OID_X509_EXT_ISSUER_ALT_NAME: u32 = 64;
pub const OID_X509_EXT_SUBJECT_DIRECTORY_ATTRS: u32 = 128;
pub const OID_X509_EXT_BASIC_CONSTRAINTS: u32 = 256;
pub const OID_X509_EXT_NAME_CONSTRAINTS: u32 = 512;
pub const OID_X509_EXT_POLICY_CONSTRAINTS: u32 = 1024;
pub const OID_X509_EXT_EXTENDED_KEY_USAGE: u32 = 2048;
pub const OID_X509_EXT_CRL_DISTRIBUTION_POINTS: u32 = 4096;
pub const OID_X509_EXT_INIHIBIT_ANYPOLICY: u32 = 8192;
pub const OID_X509_EXT_FRESHEST_CRL: u32 = 16384;
pub const OID_X509_EXT_NS_CERT_TYPE: u32 = 65536;
pub const OID_ISO_MEMBER_BODIES: &'static [u8; 2usize] = b"*\0";
pub const OID_ISO_IDENTIFIED_ORG: &'static [u8; 2usize] = b"+\0";
pub const OID_ISO_CCITT_DS: &'static [u8; 2usize] = b"U\0";
pub const OID_ISO_ITU_COUNTRY: &'static [u8; 2usize] = b"`\0";
pub const OID_COUNTRY_US: [u8; 3usize] = [134u8, 72u8, 0u8];
pub const OID_ORG_RSA_DATA_SECURITY: [u8; 4usize] = [134u8, 247u8, 13u8, 0u8];
pub const OID_RSA_COMPANY: [u8; 7usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 0u8];
pub const OID_ORG_ANSI_X9_62: [u8; 3usize] = [206u8, 61u8, 0u8];
pub const OID_ANSI_X9_62: [u8; 6usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 0u8];
pub const OID_ORG_DOD: &'static [u8; 2usize] = b"\x06\0";
pub const OID_ORG_OIW: &'static [u8; 2usize] = b"\x0E\0";
pub const OID_OIW_SECSIG: &'static [u8; 3usize] = b"\x0E\x03\0";
pub const OID_OIW_SECSIG_ALG: &'static [u8; 4usize] = b"\x0E\x03\x02\0";
pub const OID_OIW_SECSIG_SHA1: &'static [u8; 5usize] = b"\x0E\x03\x02\x1A\0";
pub const OID_ORG_CERTICOM: [u8; 3usize] = [129u8, 4u8, 0u8];
pub const OID_CERTICOM: [u8; 4usize] = [43u8, 129u8, 4u8, 0u8];
pub const OID_ORG_TELETRUST: &'static [u8; 2usize] = b"$\0";
pub const OID_TELETRUST: &'static [u8; 3usize] = b"+$\0";
pub const OID_ORGANIZATION: &'static [u8; 2usize] = b"\x01\0";
pub const OID_ISO_ITU_US_ORG: [u8; 5usize] = [96u8, 134u8, 72u8, 1u8, 0u8];
pub const OID_ORG_GOV: &'static [u8; 2usize] = b"e\0";
pub const OID_GOV: [u8; 6usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 0u8];
pub const OID_ORG_NETSCAPE: [u8; 4usize] = [134u8, 248u8, 66u8, 0u8];
pub const OID_NETSCAPE: [u8; 8usize] = [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 0u8];
pub const OID_ID_CE: &'static [u8; 3usize] = b"U\x1D\0";
pub const OID_NIST_ALG: [u8; 8usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 0u8];
pub const OID_INTERNET: &'static [u8; 4usize] = b"+\x06\x01\0";
pub const OID_PKIX: &'static [u8; 7usize] = b"+\x06\x01\x05\x05\x07\0";
pub const OID_AT: &'static [u8; 3usize] = b"U\x04\0";
pub const OID_AT_CN: &'static [u8; 4usize] = b"U\x04\x03\0";
pub const OID_AT_SUR_NAME: &'static [u8; 4usize] = b"U\x04\x04\0";
pub const OID_AT_SERIAL_NUMBER: &'static [u8; 4usize] = b"U\x04\x05\0";
pub const OID_AT_COUNTRY: &'static [u8; 4usize] = b"U\x04\x06\0";
pub const OID_AT_LOCALITY: &'static [u8; 4usize] = b"U\x04\x07\0";
pub const OID_AT_STATE: &'static [u8; 4usize] = b"U\x04\x08\0";
pub const OID_AT_ORGANIZATION: &'static [u8; 4usize] = b"U\x04\n\0";
pub const OID_AT_ORG_UNIT: &'static [u8; 4usize] = b"U\x04\x0B\0";
pub const OID_AT_TITLE: &'static [u8; 4usize] = b"U\x04\x0C\0";
pub const OID_AT_POSTAL_ADDRESS: &'static [u8; 4usize] = b"U\x04\x10\0";
pub const OID_AT_POSTAL_CODE: &'static [u8; 4usize] = b"U\x04\x11\0";
pub const OID_AT_GIVEN_NAME: &'static [u8; 4usize] = b"U\x04*\0";
pub const OID_AT_INITIALS: &'static [u8; 4usize] = b"U\x04+\0";
pub const OID_AT_GENERATION_QUALIFIER: &'static [u8; 4usize] = b"U\x04,\0";
pub const OID_AT_UNIQUE_IDENTIFIER: &'static [u8; 4usize] = b"U\x04-\0";
pub const OID_AT_DN_QUALIFIER: &'static [u8; 4usize] = b"U\x04.\0";
pub const OID_AT_PSEUDONYM: &'static [u8; 4usize] = b"U\x04A\0";
pub const OID_DOMAIN_COMPONENT: [u8; 11usize] = [
    9u8, 146u8, 38u8, 137u8, 147u8, 242u8, 44u8, 100u8, 1u8, 25u8, 0u8,
];
pub const OID_AUTHORITY_KEY_IDENTIFIER: &'static [u8; 4usize] = b"U\x1D#\0";
pub const OID_SUBJECT_KEY_IDENTIFIER: &'static [u8; 4usize] = b"U\x1D\x0E\0";
pub const OID_KEY_USAGE: &'static [u8; 4usize] = b"U\x1D\x0F\0";
pub const OID_CERTIFICATE_POLICIES: &'static [u8; 4usize] = b"U\x1D \0";
pub const OID_POLICY_MAPPINGS: &'static [u8; 4usize] = b"U\x1D!\0";
pub const OID_SUBJECT_ALT_NAME: &'static [u8; 4usize] = b"U\x1D\x11\0";
pub const OID_ISSUER_ALT_NAME: &'static [u8; 4usize] = b"U\x1D\x12\0";
pub const OID_SUBJECT_DIRECTORY_ATTRS: &'static [u8; 4usize] = b"U\x1D\t\0";
pub const OID_BASIC_CONSTRAINTS: &'static [u8; 4usize] = b"U\x1D\x13\0";
pub const OID_NAME_CONSTRAINTS: &'static [u8; 4usize] = b"U\x1D\x1E\0";
pub const OID_POLICY_CONSTRAINTS: &'static [u8; 4usize] = b"U\x1D$\0";
pub const OID_EXTENDED_KEY_USAGE: &'static [u8; 4usize] = b"U\x1D%\0";
pub const OID_CRL_DISTRIBUTION_POINTS: &'static [u8; 4usize] = b"U\x1D\x1F\0";
pub const OID_INIHIBIT_ANYPOLICY: &'static [u8; 4usize] = b"U\x1D6\0";
pub const OID_FRESHEST_CRL: &'static [u8; 4usize] = b"U\x1D.\0";
pub const OID_ANY_POLICY: &'static [u8; 5usize] = b"U\x1D \0\0";
pub const OID_NS_CERT: [u8; 9usize] = [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 0u8];
pub const OID_NS_CERT_TYPE: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 1u8, 0u8];
pub const OID_NS_BASE_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 2u8, 0u8];
pub const OID_NS_REVOCATION_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 3u8, 0u8];
pub const OID_NS_CA_REVOCATION_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 4u8, 0u8];
pub const OID_NS_RENEWAL_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 7u8, 0u8];
pub const OID_NS_CA_POLICY_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 8u8, 0u8];
pub const OID_NS_SSL_SERVER_NAME: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 12u8, 0u8];
pub const OID_NS_COMMENT: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 13u8, 0u8];
pub const OID_NS_DATA_TYPE: [u8; 9usize] = [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 2u8, 0u8];
pub const OID_NS_CERT_SEQUENCE: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 2u8, 5u8, 0u8];
pub const OID_PRIVATE_KEY_USAGE_PERIOD: &'static [u8; 4usize] = b"U\x1D\x10\0";
pub const OID_CRL_NUMBER: &'static [u8; 4usize] = b"U\x1D\x14\0";
pub const OID_ANY_EXTENDED_KEY_USAGE: &'static [u8; 5usize] = b"U\x1D%\0\0";
pub const OID_KP: &'static [u8; 8usize] = b"+\x06\x01\x05\x05\x07\x03\0";
pub const OID_SERVER_AUTH: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x01\0";
pub const OID_CLIENT_AUTH: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x02\0";
pub const OID_CODE_SIGNING: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x03\0";
pub const OID_EMAIL_PROTECTION: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x04\0";
pub const OID_TIME_STAMPING: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x08\0";
pub const OID_OCSP_SIGNING: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\t\0";
pub const OID_WISUN_FAN: [u8; 10usize] = [43u8, 6u8, 1u8, 4u8, 1u8, 130u8, 228u8, 37u8, 1u8, 0u8];
pub const OID_ON: &'static [u8; 8usize] = b"+\x06\x01\x05\x05\x07\x08\0";
pub const OID_ON_HW_MODULE_NAME: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x08\x04\0";
pub const OID_PKCS: [u8; 8usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 0u8];
pub const OID_PKCS1: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 0u8];
pub const OID_PKCS5: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 0u8];
pub const OID_PKCS9: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 9u8, 0u8];
pub const OID_PKCS12: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 0u8];
pub const OID_PKCS1_RSA: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 1u8, 0u8];
pub const OID_PKCS1_MD2: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 2u8, 0u8];
pub const OID_PKCS1_MD4: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 3u8, 0u8];
pub const OID_PKCS1_MD5: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 4u8, 0u8];
pub const OID_PKCS1_SHA1: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 5u8, 0u8];
pub const OID_PKCS1_SHA224: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 14u8, 0u8];
pub const OID_PKCS1_SHA256: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 11u8, 0u8];
pub const OID_PKCS1_SHA384: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 12u8, 0u8];
pub const OID_PKCS1_SHA512: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 13u8, 0u8];
pub const OID_RSA_SHA_OBS: &'static [u8; 6usize] = b"+\x0E\x03\x02\x1D\0";
pub const OID_PKCS9_EMAIL: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 9u8, 1u8, 0u8];
pub const OID_RSASSA_PSS: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 10u8, 0u8];
pub const OID_MGF1: [u8; 10usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 8u8, 0u8];
pub const OID_DIGEST_ALG_MD2: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 2u8, 0u8];
pub const OID_DIGEST_ALG_MD4: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 4u8, 0u8];
pub const OID_DIGEST_ALG_MD5: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 5u8, 0u8];
pub const OID_DIGEST_ALG_SHA1: &'static [u8; 6usize] = b"+\x0E\x03\x02\x1A\0";
pub const OID_DIGEST_ALG_SHA224: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 4u8, 0u8];
pub const OID_DIGEST_ALG_SHA256: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 1u8, 0u8];
pub const OID_DIGEST_ALG_SHA384: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 2u8, 0u8];
pub const OID_DIGEST_ALG_SHA512: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 3u8, 0u8];
pub const OID_DIGEST_ALG_RIPEMD160: &'static [u8; 6usize] = b"+$\x03\x02\x01\0";
pub const OID_HMAC_SHA1: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 7u8, 0u8];
pub const OID_HMAC_SHA224: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 8u8, 0u8];
pub const OID_HMAC_SHA256: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 9u8, 0u8];
pub const OID_HMAC_SHA384: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 10u8, 0u8];
pub const OID_HMAC_SHA512: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 11u8, 0u8];
pub const OID_DES_CBC: &'static [u8; 6usize] = b"+\x0E\x03\x02\x07\0";
pub const OID_DES_EDE3_CBC: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 3u8, 7u8, 0u8];
pub const OID_AES: [u8; 9usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 0u8];
pub const OID_AES128_KW: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 5u8, 0u8];
pub const OID_AES128_KWP: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 8u8, 0u8];
pub const OID_AES192_KW: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 25u8, 0u8];
pub const OID_AES192_KWP: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 28u8, 0u8];
pub const OID_AES256_KW: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 45u8, 0u8];
pub const OID_AES256_KWP: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 48u8, 0u8];
pub const OID_PKCS5_PBKDF2: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 12u8, 0u8];
pub const OID_PKCS5_PBES2: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 13u8, 0u8];
pub const OID_PKCS5_PBMAC1: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 14u8, 0u8];
pub const OID_PKCS5_PBE_MD2_DES_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 1u8, 0u8];
pub const OID_PKCS5_PBE_MD2_RC2_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 4u8, 0u8];
pub const OID_PKCS5_PBE_MD5_DES_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 3u8, 0u8];
pub const OID_PKCS5_PBE_MD5_RC2_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 6u8, 0u8];
pub const OID_PKCS5_PBE_SHA1_DES_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 10u8, 0u8];
pub const OID_PKCS5_PBE_SHA1_RC2_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 11u8, 0u8];
pub const OID_PKCS9_CSR_EXT_REQ: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 9u8, 14u8, 0u8];
pub const OID_PKCS12_PBE: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 0u8];
pub const OID_PKCS12_PBE_SHA1_RC4_128: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 1u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_RC4_40: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 2u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_DES3_EDE_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 3u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_DES2_EDE_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 4u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_RC2_128_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 5u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_RC2_40_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 6u8, 0u8,
];
pub const OID_EC_ALG_UNRESTRICTED: [u8; 8usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 2u8, 1u8, 0u8];
pub const OID_EC_ALG_ECDH: [u8; 6usize] = [43u8, 129u8, 4u8, 1u8, 12u8, 0u8];
pub const OID_EC_GRP_SECP192R1: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 3u8, 1u8, 1u8, 0u8];
pub const OID_EC_GRP_SECP224R1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 33u8, 0u8];
pub const OID_EC_GRP_SECP256R1: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 3u8, 1u8, 7u8, 0u8];
pub const OID_EC_GRP_SECP384R1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 34u8, 0u8];
pub const OID_EC_GRP_SECP521R1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 35u8, 0u8];
pub const OID_EC_GRP_SECP192K1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 31u8, 0u8];
pub const OID_EC_GRP_SECP224K1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 32u8, 0u8];
pub const OID_EC_GRP_SECP256K1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 10u8, 0u8];
pub const OID_EC_BRAINPOOL_V1: &'static [u8; 9usize] = b"+$\x03\x03\x02\x08\x01\x01\0";
pub const OID_EC_GRP_BP256R1: &'static [u8; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\x07\0";
pub const OID_EC_GRP_BP384R1: &'static [u8; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\x0B\0";
pub const OID_EC_GRP_BP512R1: &'static [u8; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\r\0";
pub const OID_ANSI_X9_62_FIELD_TYPE: [u8; 7usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 1u8, 0u8];
pub const OID_ANSI_X9_62_PRIME_FIELD: [u8; 8usize] =
    [42u8, 134u8, 72u8, 206u8, 61u8, 1u8, 1u8, 0u8];
pub const OID_ANSI_X9_62_SIG: [u8; 7usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 0u8];
pub const OID_ANSI_X9_62_SIG_SHA2: [u8; 8usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 0u8];
pub const OID_ECDSA_SHA1: [u8; 8usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 1u8, 0u8];
pub const OID_ECDSA_SHA224: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 1u8, 0u8];
pub const OID_ECDSA_SHA256: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 2u8, 0u8];
pub const OID_ECDSA_SHA384: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 3u8, 0u8];
pub const OID_ECDSA_SHA512: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 4u8, 0u8];
pub const AES_ENCRYPT: u32 = 1;
pub const AES_DECRYPT: u32 = 0;
pub const ERR_AES_INVALID_KEY_LENGTH: i32 = -32;
pub const ERR_AES_INVALID_INPUT_LENGTH: i32 = -34;
pub const ERR_AES_BAD_INPUT_DATA: i32 = -33;
pub const ERR_AES_FEATURE_UNAVAILABLE: i32 = -35;
pub const ERR_AES_HW_ACCEL_FAILED: i32 = -37;
pub const ERR_PADLOCK_DATA_MISALIGNED: i32 = -48;
pub const ERR_PEM_NO_HEADER_FOOTER_PRESENT: i32 = -4224;
pub const ERR_PEM_INVALID_DATA: i32 = -4352;
pub const ERR_PEM_ALLOC_FAILED: i32 = -4480;
pub const ERR_PEM_INVALID_ENC_IV: i32 = -4608;
pub const ERR_PEM_UNKNOWN_ENC_ALG: i32 = -4736;
pub const ERR_PEM_PASSWORD_REQUIRED: i32 = -4864;
pub const ERR_PEM_PASSWORD_MISMATCH: i32 = -4992;
pub const ERR_PEM_FEATURE_UNAVAILABLE: i32 = -5120;
pub const ERR_PEM_BAD_INPUT_DATA: i32 = -5248;
pub const ERR_ARC4_HW_ACCEL_FAILED: i32 = -25;
pub const ARIA_ENCRYPT: u32 = 1;
pub const ARIA_DECRYPT: u32 = 0;
pub const ARIA_BLOCKSIZE: u32 = 16;
pub const ARIA_MAX_ROUNDS: u32 = 16;
pub const ARIA_MAX_KEYSIZE: u32 = 32;
pub const ERR_ARIA_BAD_INPUT_DATA: i32 = -92;
pub const ERR_ARIA_INVALID_INPUT_LENGTH: i32 = -94;
pub const ERR_ARIA_FEATURE_UNAVAILABLE: i32 = -90;
pub const ERR_ARIA_HW_ACCEL_FAILED: i32 = -88;
pub const ERR_BASE64_BUFFER_TOO_SMALL: i32 = -42;
pub const ERR_BASE64_INVALID_CHARACTER: i32 = -44;
pub const BLOWFISH_ENCRYPT: u32 = 1;
pub const BLOWFISH_DECRYPT: u32 = 0;
pub const BLOWFISH_MAX_KEY_BITS: u32 = 448;
pub const BLOWFISH_MIN_KEY_BITS: u32 = 32;
pub const BLOWFISH_ROUNDS: u32 = 16;
pub const BLOWFISH_BLOCKSIZE: u32 = 8;
pub const ERR_BLOWFISH_BAD_INPUT_DATA: i32 = -22;
pub const ERR_BLOWFISH_INVALID_INPUT_LENGTH: i32 = -24;
pub const ERR_BLOWFISH_HW_ACCEL_FAILED: i32 = -23;
pub const ERR_CCM_BAD_INPUT: i32 = -13;
pub const ERR_CCM_AUTH_FAILED: i32 = -15;
pub const ERR_CCM_HW_ACCEL_FAILED: i32 = -17;
pub const CAMELLIA_ENCRYPT: u32 = 1;
pub const CAMELLIA_DECRYPT: u32 = 0;
pub const ERR_CAMELLIA_BAD_INPUT_DATA: i32 = -36;
pub const ERR_CAMELLIA_INVALID_INPUT_LENGTH: i32 = -38;
pub const ERR_CAMELLIA_HW_ACCEL_FAILED: i32 = -39;
pub const ERR_CHACHA20_BAD_INPUT_DATA: i32 = -81;
pub const ERR_CHACHA20_FEATURE_UNAVAILABLE: i32 = -83;
pub const ERR_CHACHA20_HW_ACCEL_FAILED: i32 = -85;
pub const ERR_POLY1305_BAD_INPUT_DATA: i32 = -87;
pub const ERR_POLY1305_FEATURE_UNAVAILABLE: i32 = -89;
pub const ERR_POLY1305_HW_ACCEL_FAILED: i32 = -91;
pub const ERR_CHACHAPOLY_BAD_STATE: i32 = -84;
pub const ERR_CHACHAPOLY_AUTH_FAILED: i32 = -86;
pub const ERR_CMAC_HW_ACCEL_FAILED: i32 = -122;
pub const AES_BLOCK_SIZE: u32 = 16;
pub const DES3_BLOCK_SIZE: u32 = 8;
pub const CIPHER_BLKSIZE_MAX: u32 = 16;
pub const DES_ENCRYPT: u32 = 1;
pub const DES_DECRYPT: u32 = 0;
pub const ERR_DES_INVALID_INPUT_LENGTH: i32 = -50;
pub const ERR_DES_HW_ACCEL_FAILED: i32 = -51;
pub const DES_KEY_SIZE: u32 = 8;
pub const GCM_ENCRYPT: u32 = 1;
pub const GCM_DECRYPT: u32 = 0;
pub const ERR_GCM_AUTH_FAILED: i32 = -18;
pub const ERR_GCM_HW_ACCEL_FAILED: i32 = -19;
pub const ERR_GCM_BAD_INPUT: i32 = -20;
pub const ERR_HKDF_BAD_INPUT_DATA: i32 = -24448;
pub const ERR_MD2_HW_ACCEL_FAILED: i32 = -43;
pub const ERR_MD4_HW_ACCEL_FAILED: i32 = -45;
pub const ERR_PKCS5_BAD_INPUT_DATA: i32 = -12160;
pub const ERR_PKCS5_INVALID_FORMAT: i32 = -12032;
pub const ERR_PKCS5_FEATURE_UNAVAILABLE: i32 = -11904;
pub const ERR_PKCS5_PASSWORD_MISMATCH: i32 = -11776;
pub const PKCS5_DECRYPT: u32 = 0;
pub const PKCS5_ENCRYPT: u32 = 1;
pub const ERR_PKCS12_BAD_INPUT_DATA: i32 = -8064;
pub const ERR_PKCS12_FEATURE_UNAVAILABLE: i32 = -7936;
pub const ERR_PKCS12_PBE_INVALID_FORMAT: i32 = -7808;
pub const ERR_PKCS12_PASSWORD_MISMATCH: i32 = -7680;
pub const PKCS12_DERIVE_KEY: u32 = 1;
pub const PKCS12_DERIVE_IV: u32 = 2;
pub const PKCS12_DERIVE_MAC_KEY: u32 = 3;
pub const PKCS12_PBE_DECRYPT: u32 = 0;
pub const PKCS12_PBE_ENCRYPT: u32 = 1;
pub const ERR_RIPEMD160_HW_ACCEL_FAILED: i32 = -49;
pub const XTEA_ENCRYPT: u32 = 1;
pub const XTEA_DECRYPT: u32 = 0;
pub const ERR_XTEA_INVALID_INPUT_LENGTH: i32 = -40;
pub const ERR_XTEA_HW_ACCEL_FAILED: i32 = -41;
pub const ERR_ENTROPY_SOURCE_FAILED: i32 = -60;
pub const ERR_ENTROPY_MAX_SOURCES: i32 = -62;
pub const ERR_ENTROPY_NO_SOURCES_DEFINED: i32 = -64;
pub const ERR_ENTROPY_NO_STRONG_SOURCE: i32 = -61;
pub const ERR_ENTROPY_FILE_IO_ERROR: i32 = -63;
pub const ENTROPY_MAX_SOURCES: u32 = 20;
pub const ENTROPY_MAX_GATHER: u32 = 128;
pub const ENTROPY_BLOCK_SIZE: u32 = 64;
pub const ENTROPY_MAX_SEED_SIZE: u32 = 1024;
pub const ENTROPY_SOURCE_MANUAL: u32 = 20;
pub const ENTROPY_SOURCE_STRONG: u32 = 1;
pub const ENTROPY_SOURCE_WEAK: u32 = 0;
pub const ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED: i32 = -52;
pub const ERR_CTR_DRBG_REQUEST_TOO_BIG: i32 = -54;
pub const ERR_CTR_DRBG_INPUT_TOO_BIG: i32 = -56;
pub const ERR_CTR_DRBG_FILE_IO_ERROR: i32 = -58;
pub const CTR_DRBG_BLOCKSIZE: u32 = 16;
pub const CTR_DRBG_KEYSIZE: u32 = 32;
pub const CTR_DRBG_KEYBITS: u32 = 256;
pub const CTR_DRBG_SEEDLEN: u32 = 48;
pub const CTR_DRBG_ENTROPY_LEN: u32 = 48;
pub const CTR_DRBG_RESEED_INTERVAL: u32 = 10000;
pub const CTR_DRBG_MAX_INPUT: u32 = 256;
pub const CTR_DRBG_MAX_REQUEST: u32 = 1024;
pub const CTR_DRBG_MAX_SEED_INPUT: u32 = 384;
pub const CTR_DRBG_PR_OFF: u32 = 0;
pub const CTR_DRBG_PR_ON: u32 = 1;
pub const CTR_DRBG_ENTROPY_NONCE_LEN: u32 = 0;
pub type iso_c_forbids_empty_translation_units = crate::types::c_int;
pub type wchar_t = crate::types::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::types::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_calloc"]
    pub fn calloc(n: usize, size: usize) -> *mut crate::types::c_void;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_free"]
    pub fn free(ptr: *mut crate::types::c_void);
}
extern "C" {
    #[doc = " \\brief               This function dynamically sets the memory-management"]
    #[doc = "                      functions used by the library, during runtime."]
    #[doc = ""]
    #[doc = " \\param calloc_func   The \\c calloc function implementation."]
    #[doc = " \\param free_func     The \\c free function implementation."]
    #[doc = ""]
    #[doc = " \\return              \\c 0."]
    #[link_name = "\u{1}mbedtls_platform_set_calloc_free"]
    pub fn platform_set_calloc_free(
        calloc_func: ::core::option::Option<
            unsafe extern "C" fn(arg1: usize, arg2: usize) -> *mut crate::types::c_void,
        >,
        free_func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut crate::types::c_void)>,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_printf"]
    pub static mut printf: ::core::option::Option<
        unsafe extern "C" fn(format: *const crate::types::c_char, ...) -> crate::types::c_int,
    >;
}
extern "C" {
    #[doc = " \\brief               This function dynamically configures the snprintf"]
    #[doc = "                      function that is called when the mbedtls_snprintf()"]
    #[doc = "                      function is invoked by the library."]
    #[doc = ""]
    #[doc = " \\param printf_func   The \\c printf function implementation."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_platform_set_printf"]
    pub fn platform_set_printf(
        printf_func: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const crate::types::c_char, ...) -> crate::types::c_int,
        >,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_snprintf"]
    pub static mut snprintf: ::core::option::Option<
        unsafe extern "C" fn(
            s: *mut crate::types::c_char,
            n: usize,
            format: *const crate::types::c_char,
            ...
        ) -> crate::types::c_int,
    >;
}
extern "C" {
    #[doc = " \\brief                 This function allows configuring a custom"]
    #[doc = "                        \\c snprintf function pointer."]
    #[doc = ""]
    #[doc = " \\param snprintf_func   The \\c snprintf function implementation."]
    #[doc = ""]
    #[doc = " \\return                \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_platform_set_snprintf"]
    pub fn platform_set_snprintf(
        snprintf_func: ::core::option::Option<
            unsafe extern "C" fn(
                s: *mut crate::types::c_char,
                n: usize,
                format: *const crate::types::c_char,
                ...
            ) -> crate::types::c_int,
        >,
    ) -> crate::types::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    #[link_name = "\u{1}mbedtls_vsnprintf"]
    pub static mut vsnprintf: ::core::option::Option<
        unsafe extern "C" fn(
            s: *mut crate::types::c_char,
            n: usize,
            format: *const crate::types::c_char,
            arg: va_list,
        ) -> crate::types::c_int,
    >;
}
extern "C" {
    #[doc = " \\brief   Set your own snprintf function pointer"]
    #[doc = ""]
    #[doc = " \\param   vsnprintf_func   The \\c vsnprintf function implementation"]
    #[doc = ""]
    #[doc = " \\return  \\c 0"]
    #[link_name = "\u{1}mbedtls_platform_set_vsnprintf"]
    pub fn platform_set_vsnprintf(
        vsnprintf_func: ::core::option::Option<
            unsafe extern "C" fn(
                s: *mut crate::types::c_char,
                n: usize,
                format: *const crate::types::c_char,
                arg: va_list,
            ) -> crate::types::c_int,
        >,
    ) -> crate::types::c_int;
}
#[doc = " \\brief   The platform context structure."]
#[doc = ""]
#[doc = " \\note    This structure may be used to assist platform-specific"]
#[doc = "          setup or teardown operations."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct platform_context {
    #[doc = "< A placeholder member, as empty structs are not portable."]
    pub dummy: crate::types::c_char,
}
#[test]
fn bindgen_test_layout_platform_context() {
    assert_eq!(
        ::core::mem::size_of::<platform_context>(),
        1usize,
        concat!("Size of: ", stringify!(platform_context))
    );
    assert_eq!(
        ::core::mem::align_of::<platform_context>(),
        1usize,
        concat!("Alignment of ", stringify!(platform_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<platform_context>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(platform_context),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    #[doc = " \\brief   This function performs any platform-specific initialization"]
    #[doc = "          operations."]
    #[doc = ""]
    #[doc = " \\note    This function should be called before any other library functions."]
    #[doc = ""]
    #[doc = "          Its implementation is platform-specific, and unless"]
    #[doc = "          platform-specific code is provided, it does nothing."]
    #[doc = ""]
    #[doc = " \\note    The usage and necessity of this function is dependent on the platform."]
    #[doc = ""]
    #[doc = " \\param   ctx     The platform context."]
    #[doc = ""]
    #[doc = " \\return  \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_platform_setup"]
    pub fn platform_setup(ctx: *mut platform_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function performs any platform teardown operations."]
    #[doc = ""]
    #[doc = " \\note    This function should be called after every other Mbed TLS module"]
    #[doc = "          has been correctly freed using the appropriate free function."]
    #[doc = ""]
    #[doc = "          Its implementation is platform-specific, and unless"]
    #[doc = "          platform-specific code is provided, it does nothing."]
    #[doc = ""]
    #[doc = " \\note    The usage and necessity of this function is dependent on the platform."]
    #[doc = ""]
    #[doc = " \\param   ctx     The platform context."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_platform_teardown"]
    pub fn platform_teardown(ctx: *mut platform_context);
}
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = crate::types::c_longlong;
pub type uintmax_t = crate::types::c_ulonglong;
pub type mpi_sint = i32;
pub type mpi_uint = u32;
pub type t_udbl = u64;
#[doc = " \\brief          MPI structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpi {
    #[doc = "<  Sign: -1 if the mpi is negative, 1 otherwise"]
    pub s: crate::types::c_int,
    #[doc = "<  total # of limbs"]
    pub n: usize,
    #[doc = "<  pointer to limbs"]
    pub p: *mut mpi_uint,
}
#[test]
fn bindgen_test_layout_mpi() {
    assert_eq!(
        ::core::mem::size_of::<mpi>(),
        12usize,
        concat!("Size of: ", stringify!(mpi))
    );
    assert_eq!(
        ::core::mem::align_of::<mpi>(),
        4usize,
        concat!("Alignment of ", stringify!(mpi))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mpi>())).s as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(mpi), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mpi>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(mpi), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mpi>())).p as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(mpi), "::", stringify!(p))
    );
}
impl Default for mpi {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           Initialize an MPI context."]
    #[doc = ""]
    #[doc = "                  This makes the MPI ready to be set or freed,"]
    #[doc = "                  but does not define a value for the MPI."]
    #[doc = ""]
    #[doc = " \\param X         The MPI context to initialize. This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_mpi_init"]
    pub fn mpi_init(X: *mut mpi);
}
extern "C" {
    #[doc = " \\brief          This function frees the components of an MPI context."]
    #[doc = ""]
    #[doc = " \\param X        The MPI context to be cleared. This may be \\c NULL,"]
    #[doc = "                 in which case this function is a no-op. If it is"]
    #[doc = "                 not \\c NULL, it must point to an initialized MPI."]
    #[link_name = "\u{1}mbedtls_mpi_free"]
    pub fn mpi_free(X: *mut mpi);
}
extern "C" {
    #[doc = " \\brief          Enlarge an MPI to the specified number of limbs."]
    #[doc = ""]
    #[doc = " \\note           This function does nothing if the MPI is"]
    #[doc = "                 already large enough."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to grow. It must be initialized."]
    #[doc = " \\param nblimbs  The target number of limbs."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_grow"]
    pub fn mpi_grow(X: *mut mpi, nblimbs: usize) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function resizes an MPI downwards, keeping at least the"]
    #[doc = "                 specified number of limbs."]
    #[doc = ""]
    #[doc = "                 If \\c X is smaller than \\c nblimbs, it is resized up"]
    #[doc = "                 instead."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to shrink. This must point to an initialized MPI."]
    #[doc = " \\param nblimbs  The minimum number of limbs to keep."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed"]
    #[doc = "                 (this can only happen when resizing up)."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_shrink"]
    pub fn mpi_shrink(X: *mut mpi, nblimbs: usize) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Make a copy of an MPI."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param Y        The source MPI. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\note           The limb-buffer in the destination MPI is enlarged"]
    #[doc = "                 if necessary to hold the value in the source MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_copy"]
    pub fn mpi_copy(X: *mut mpi, Y: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Swap the contents of two MPIs."]
    #[doc = ""]
    #[doc = " \\param X        The first MPI. It must be initialized."]
    #[doc = " \\param Y        The second MPI. It must be initialized."]
    #[link_name = "\u{1}mbedtls_mpi_swap"]
    pub fn mpi_swap(X: *mut mpi, Y: *mut mpi);
}
extern "C" {
    #[doc = " \\brief          Perform a safe conditional copy of MPI which doesn't"]
    #[doc = "                 reveal whether the condition was true or not."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to conditionally assign to. This must point"]
    #[doc = "                 to an initialized MPI."]
    #[doc = " \\param Y        The MPI to be assigned from. This must point to an"]
    #[doc = "                 initialized MPI."]
    #[doc = " \\param assign   The condition deciding whether to perform the"]
    #[doc = "                 assignment or not. Possible values:"]
    #[doc = "                 * \\c 1: Perform the assignment `X = Y`."]
    #[doc = "                 * \\c 0: Keep the original value of \\p X."]
    #[doc = ""]
    #[doc = " \\note           This function is equivalent to"]
    #[doc = "                      `if( assign ) mbedtls_mpi_copy( X, Y );`"]
    #[doc = "                 except that it avoids leaking any information about whether"]
    #[doc = "                 the assignment was done or not (the above code may leak"]
    #[doc = "                 information through branch prediction and/or memory access"]
    #[doc = "                 patterns analysis)."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_safe_cond_assign"]
    pub fn mpi_safe_cond_assign(
        X: *mut mpi,
        Y: *const mpi,
        assign: crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a safe conditional swap which doesn't"]
    #[doc = "                 reveal whether the condition was true or not."]
    #[doc = ""]
    #[doc = " \\param X        The first MPI. This must be initialized."]
    #[doc = " \\param Y        The second MPI. This must be initialized."]
    #[doc = " \\param assign   The condition deciding whether to perform"]
    #[doc = "                 the swap or not. Possible values:"]
    #[doc = "                 * \\c 1: Swap the values of \\p X and \\p Y."]
    #[doc = "                 * \\c 0: Keep the original values of \\p X and \\p Y."]
    #[doc = ""]
    #[doc = " \\note           This function is equivalent to"]
    #[doc = "                      if( assign ) mbedtls_mpi_swap( X, Y );"]
    #[doc = "                 except that it avoids leaking any information about whether"]
    #[doc = "                 the assignment was done or not (the above code may leak"]
    #[doc = "                 information through branch prediction and/or memory access"]
    #[doc = "                 patterns analysis)."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_mpi_safe_cond_swap"]
    pub fn mpi_safe_cond_swap(
        X: *mut mpi,
        Y: *mut mpi,
        assign: crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Store integer value in MPI."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to set. This must be initialized."]
    #[doc = " \\param z        The value to use."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_lset"]
    pub fn mpi_lset(X: *mut mpi, z: mpi_sint) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Get a specific bit from an MPI."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to query. This must be initialized."]
    #[doc = " \\param pos      Zero-based index of the bit to query."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 or \\c 1 on success, depending on whether bit \\c pos"]
    #[doc = "                 of \\c X is unset or set."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_mpi_get_bit"]
    pub fn mpi_get_bit(X: *const mpi, pos: usize) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Modify a specific bit in an MPI."]
    #[doc = ""]
    #[doc = " \\note           This function will grow the target MPI if necessary to set a"]
    #[doc = "                 bit to \\c 1 in a not yet existing limb. It will not grow if"]
    #[doc = "                 the bit should be set to \\c 0."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to modify. This must be initialized."]
    #[doc = " \\param pos      Zero-based index of the bit to modify."]
    #[doc = " \\param val      The desired value of bit \\c pos: \\c 0 or \\c 1."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_set_bit"]
    pub fn mpi_set_bit(X: *mut mpi, pos: usize, val: crate::types::c_uchar) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of bits of value \\c 0 before the"]
    #[doc = "                 least significant bit of value \\c 1."]
    #[doc = ""]
    #[doc = " \\note           This is the same as the zero-based index of"]
    #[doc = "                 the least significant bit of value \\c 1."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to query."]
    #[doc = ""]
    #[doc = " \\return         The number of bits of value \\c 0 before the least significant"]
    #[doc = "                 bit of value \\c 1 in \\p X."]
    #[link_name = "\u{1}mbedtls_mpi_lsb"]
    pub fn mpi_lsb(X: *const mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the number of bits up to and including the most"]
    #[doc = "                 significant bit of value \\c 1."]
    #[doc = ""]
    #[doc = " * \\note         This is same as the one-based index of the most"]
    #[doc = "                 significant bit of value \\c 1."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to query. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         The number of bits up to and including the most"]
    #[doc = "                 significant bit of value \\c 1."]
    #[link_name = "\u{1}mbedtls_mpi_bitlen"]
    pub fn mpi_bitlen(X: *const mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the total size of an MPI value in bytes."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to use. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\note           The value returned by this function may be less than"]
    #[doc = "                 the number of bytes used to store \\p X internally."]
    #[doc = "                 This happens if and only if there are trailing bytes"]
    #[doc = "                 of value zero."]
    #[doc = ""]
    #[doc = " \\return         The least number of bytes capable of storing"]
    #[doc = "                 the absolute value of \\p X."]
    #[link_name = "\u{1}mbedtls_mpi_size"]
    pub fn mpi_size(X: *const mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Import an MPI from an ASCII string."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param radix    The numeric base of the input string."]
    #[doc = " \\param s        Null-terminated string buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_mpi_read_string"]
    pub fn mpi_read_string(
        X: *mut mpi,
        radix: crate::types::c_int,
        s: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Export an MPI to an ASCII string."]
    #[doc = ""]
    #[doc = " \\param X        The source MPI. This must point to an initialized MPI."]
    #[doc = " \\param radix    The numeric base of the output string."]
    #[doc = " \\param buf      The buffer to write the string to. This must be writable"]
    #[doc = "                 buffer of length \\p buflen Bytes."]
    #[doc = " \\param buflen   The available size in Bytes of \\p buf."]
    #[doc = " \\param olen     The address at which to store the length of the string"]
    #[doc = "                 written, including the  final \\c NULL byte. This must"]
    #[doc = "                 not be \\c NULL."]
    #[doc = ""]
    #[doc = " \\note           You can call this function with `buflen == 0` to obtain the"]
    #[doc = "                 minimum required buffer size in `*olen`."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the target buffer \\p buf"]
    #[doc = "                 is too small to hold the value of \\p X in the desired base."]
    #[doc = "                 In this case, `*olen` is nonetheless updated to contain the"]
    #[doc = "                 size of \\p buf required for a successful call."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_write_string"]
    pub fn mpi_write_string(
        X: *const mpi,
        radix: crate::types::c_int,
        buf: *mut crate::types::c_char,
        buflen: usize,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Import an MPI from unsigned big endian binary data."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param buf      The input buffer. This must be a readable buffer of length"]
    #[doc = "                 \\p buflen Bytes."]
    #[doc = " \\param buflen   The length of the input buffer \\p p in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_read_binary"]
    pub fn mpi_read_binary(
        X: *mut mpi,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Import X from unsigned binary data, little endian"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param buf      The input buffer. This must be a readable buffer of length"]
    #[doc = "                 \\p buflen Bytes."]
    #[doc = " \\param buflen   The length of the input buffer \\p p in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_read_binary_le"]
    pub fn mpi_read_binary_le(
        X: *mut mpi,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Export X into unsigned binary data, big endian."]
    #[doc = "                 Always fills the whole buffer, which will start with zeros"]
    #[doc = "                 if the number is smaller."]
    #[doc = ""]
    #[doc = " \\param X        The source MPI. This must point to an initialized MPI."]
    #[doc = " \\param buf      The output buffer. This must be a writable buffer of length"]
    #[doc = "                 \\p buflen Bytes."]
    #[doc = " \\param buflen   The size of the output buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't"]
    #[doc = "                 large enough to hold the value of \\p X."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_write_binary"]
    pub fn mpi_write_binary(
        X: *const mpi,
        buf: *mut crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Export X into unsigned binary data, little endian."]
    #[doc = "                 Always fills the whole buffer, which will end with zeros"]
    #[doc = "                 if the number is smaller."]
    #[doc = ""]
    #[doc = " \\param X        The source MPI. This must point to an initialized MPI."]
    #[doc = " \\param buf      The output buffer. This must be a writable buffer of length"]
    #[doc = "                 \\p buflen Bytes."]
    #[doc = " \\param buflen   The size of the output buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't"]
    #[doc = "                 large enough to hold the value of \\p X."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_write_binary_le"]
    pub fn mpi_write_binary_le(
        X: *const mpi,
        buf: *mut crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a left-shift on an MPI: X <<= count"]
    #[doc = ""]
    #[doc = " \\param X        The MPI to shift. This must point to an initialized MPI."]
    #[doc = " \\param count    The number of bits to shift by."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_shift_l"]
    pub fn mpi_shift_l(X: *mut mpi, count: usize) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a right-shift on an MPI: X >>= count"]
    #[doc = ""]
    #[doc = " \\param X        The MPI to shift. This must point to an initialized MPI."]
    #[doc = " \\param count    The number of bits to shift by."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_shift_r"]
    pub fn mpi_shift_r(X: *mut mpi, count: usize) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare the absolute values of two MPIs."]
    #[doc = ""]
    #[doc = " \\param X        The left-hand MPI. This must point to an initialized MPI."]
    #[doc = " \\param Y        The right-hand MPI. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if `|X|` is greater than `|Y|`."]
    #[doc = " \\return         \\c -1 if `|X|` is lesser than `|Y|`."]
    #[doc = " \\return         \\c 0 if `|X|` is equal to `|Y|`."]
    #[link_name = "\u{1}mbedtls_mpi_cmp_abs"]
    pub fn mpi_cmp_abs(X: *const mpi, Y: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare two MPIs."]
    #[doc = ""]
    #[doc = " \\param X        The left-hand MPI. This must point to an initialized MPI."]
    #[doc = " \\param Y        The right-hand MPI. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if \\p X is greater than \\p Y."]
    #[doc = " \\return         \\c -1 if \\p X is lesser than \\p Y."]
    #[doc = " \\return         \\c 0 if \\p X is equal to \\p Y."]
    #[link_name = "\u{1}mbedtls_mpi_cmp_mpi"]
    pub fn mpi_cmp_mpi(X: *const mpi, Y: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check if an MPI is less than the other in constant time."]
    #[doc = ""]
    #[doc = " \\param X        The left-hand MPI. This must point to an initialized MPI"]
    #[doc = "                 with the same allocated length as Y."]
    #[doc = " \\param Y        The right-hand MPI. This must point to an initialized MPI"]
    #[doc = "                 with the same allocated length as X."]
    #[doc = " \\param ret      The result of the comparison:"]
    #[doc = "                 \\c 1 if \\p X is less than \\p Y."]
    #[doc = "                 \\c 0 if \\p X is greater than or equal to \\p Y."]
    #[doc = ""]
    #[doc = " \\return         0 on success."]
    #[doc = " \\return         MBEDTLS_ERR_MPI_BAD_INPUT_DATA if the allocated length of"]
    #[doc = "                 the two input MPIs is not the same."]
    #[link_name = "\u{1}mbedtls_mpi_lt_mpi_ct"]
    pub fn mpi_lt_mpi_ct(
        X: *const mpi,
        Y: *const mpi,
        ret: *mut crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare an MPI with an integer."]
    #[doc = ""]
    #[doc = " \\param X        The left-hand MPI. This must point to an initialized MPI."]
    #[doc = " \\param z        The integer value to compare \\p X to."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if \\p X is greater than \\p z."]
    #[doc = " \\return         \\c -1 if \\p X is lesser than \\p z."]
    #[doc = " \\return         \\c 0 if \\p X is equal to \\p z."]
    #[link_name = "\u{1}mbedtls_mpi_cmp_int"]
    pub fn mpi_cmp_int(X: *const mpi, z: mpi_sint) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform an unsigned addition of MPIs: X = |A| + |B|"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first summand. This must point to an initialized MPI."]
    #[doc = " \\param B        The second summand. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_add_abs"]
    pub fn mpi_add_abs(X: *mut mpi, A: *const mpi, B: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform an unsigned subtraction of MPIs: X = |A| - |B|"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The minuend. This must point to an initialized MPI."]
    #[doc = " \\param B        The subtrahend. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is greater than \\p A."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_mpi_sub_abs"]
    pub fn mpi_sub_abs(X: *mut mpi, A: *const mpi, B: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed addition of MPIs: X = A + B"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first summand. This must point to an initialized MPI."]
    #[doc = " \\param B        The second summand. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_add_mpi"]
    pub fn mpi_add_mpi(X: *mut mpi, A: *const mpi, B: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed subtraction of MPIs: X = A - B"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The minuend. This must point to an initialized MPI."]
    #[doc = " \\param B        The subtrahend. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_sub_mpi"]
    pub fn mpi_sub_mpi(X: *mut mpi, A: *const mpi, B: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed addition of an MPI and an integer: X = A + b"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first summand. This must point to an initialized MPI."]
    #[doc = " \\param b        The second summand."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_add_int"]
    pub fn mpi_add_int(X: *mut mpi, A: *const mpi, b: mpi_sint) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed subtraction of an MPI and an integer:"]
    #[doc = "                 X = A - b"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The minuend. This must point to an initialized MPI."]
    #[doc = " \\param b        The subtrahend."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_sub_int"]
    pub fn mpi_sub_int(X: *mut mpi, A: *const mpi, b: mpi_sint) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a multiplication of two MPIs: X = A * B"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first factor. This must point to an initialized MPI."]
    #[doc = " \\param B        The second factor. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_mpi_mul_mpi"]
    pub fn mpi_mul_mpi(X: *mut mpi, A: *const mpi, B: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a multiplication of an MPI with an unsigned integer:"]
    #[doc = "                 X = A * b"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first factor. This must point to an initialized MPI."]
    #[doc = " \\param b        The second factor."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_mpi_mul_int"]
    pub fn mpi_mul_int(X: *mut mpi, A: *const mpi, b: mpi_uint) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a division with remainder of two MPIs:"]
    #[doc = "                 A = Q * B + R"]
    #[doc = ""]
    #[doc = " \\param Q        The destination MPI for the quotient."]
    #[doc = "                 This may be \\c NULL if the value of the"]
    #[doc = "                 quotient is not needed."]
    #[doc = " \\param R        The destination MPI for the remainder value."]
    #[doc = "                 This may be \\c NULL if the value of the"]
    #[doc = "                 remainder is not needed."]
    #[doc = " \\param A        The dividend. This must point to an initialized MPi."]
    #[doc = " \\param B        The divisor. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_div_mpi"]
    pub fn mpi_div_mpi(
        Q: *mut mpi,
        R: *mut mpi,
        A: *const mpi,
        B: *const mpi,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a division with remainder of an MPI by an integer:"]
    #[doc = "                 A = Q * b + R"]
    #[doc = ""]
    #[doc = " \\param Q        The destination MPI for the quotient."]
    #[doc = "                 This may be \\c NULL if the value of the"]
    #[doc = "                 quotient is not needed."]
    #[doc = " \\param R        The destination MPI for the remainder value."]
    #[doc = "                 This may be \\c NULL if the value of the"]
    #[doc = "                 remainder is not needed."]
    #[doc = " \\param A        The dividend. This must point to an initialized MPi."]
    #[doc = " \\param b        The divisor."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_div_int"]
    pub fn mpi_div_int(Q: *mut mpi, R: *mut mpi, A: *const mpi, b: mpi_sint)
        -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a modular reduction. R = A mod B"]
    #[doc = ""]
    #[doc = " \\param R        The destination MPI for the residue value."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = " \\param A        The MPI to compute the residue of."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = " \\param B        The base of the modular reduction."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is negative."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_mpi_mod_mpi"]
    pub fn mpi_mod_mpi(R: *mut mpi, A: *const mpi, B: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a modular reduction with respect to an integer."]
    #[doc = "                 r = A mod b"]
    #[doc = ""]
    #[doc = " \\param r        The address at which to store the residue."]
    #[doc = "                 This must not be \\c NULL."]
    #[doc = " \\param A        The MPI to compute the residue of."]
    #[doc = "                 This must point to an initialized MPi."]
    #[doc = " \\param b        The integer base of the modular reduction."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p b is negative."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_mod_int"]
    pub fn mpi_mod_int(r: *mut mpi_uint, A: *const mpi, b: mpi_sint) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a sliding-window exponentiation: X = A^E mod N"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The base of the exponentiation."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = " \\param E        The exponent MPI. This must point to an initialized MPI."]
    #[doc = " \\param N        The base for the modular reduction. This must point to an"]
    #[doc = "                 initialized MPI."]
    #[doc = " \\param _RR      A helper MPI depending solely on \\p N which can be used to"]
    #[doc = "                 speed-up multiple modular exponentiations for the same value"]
    #[doc = "                 of \\p N. This may be \\c NULL. If it is not \\c NULL, it must"]
    #[doc = "                 point to an initialized MPI. If it hasn't been used after"]
    #[doc = "                 the call to mbedtls_mpi_init(), this function will compute"]
    #[doc = "                 the helper value and store it in \\p _RR for reuse on"]
    #[doc = "                 subsequent calls to this function. Otherwise, the function"]
    #[doc = "                 will assume that \\p _RR holds the helper value set by a"]
    #[doc = "                 previous call to mbedtls_mpi_exp_mod(), and reuse it."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\c N is negative or"]
    #[doc = "                 even, or if \\c E is negative."]
    #[doc = " \\return         Another negative error code on different kinds of failures."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_mpi_exp_mod"]
    pub fn mpi_exp_mod(
        X: *mut mpi,
        A: *const mpi,
        E: *const mpi,
        N: *const mpi,
        _RR: *mut mpi,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Fill an MPI with a number of random bytes."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param size     The number of random bytes to generate."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG parameter to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on failure."]
    #[doc = ""]
    #[doc = " \\note           The bytes obtained from the RNG are interpreted"]
    #[doc = "                 as a big-endian representation of an MPI; this can"]
    #[doc = "                 be relevant in applications like deterministic ECDSA."]
    #[link_name = "\u{1}mbedtls_mpi_fill_random"]
    pub fn mpi_fill_random(
        X: *mut mpi,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compute the greatest common divisor: G = gcd(A, B)"]
    #[doc = ""]
    #[doc = " \\param G        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The first operand. This must point to an initialized MPI."]
    #[doc = " \\param B        The second operand. This must point to an initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_gcd"]
    pub fn mpi_gcd(G: *mut mpi, A: *const mpi, B: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compute the modular inverse: X = A^-1 mod N"]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI. This must point to an initialized MPI."]
    #[doc = " \\param A        The MPI to calculate the modular inverse of. This must point"]
    #[doc = "                 to an initialized MPI."]
    #[doc = " \\param N        The base of the modular inversion. This must point to an"]
    #[doc = "                 initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\p N is less than"]
    #[doc = "                 or equal to one."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p has no modular inverse"]
    #[doc = "                 with respect to \\p N."]
    #[link_name = "\u{1}mbedtls_mpi_inv_mod"]
    pub fn mpi_inv_mod(X: *mut mpi, A: *const mpi, N: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a Miller-Rabin primality test with error"]
    #[doc = "                 probability of 2<sup>-80</sup>."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_mpi_is_prime_ext() which allows"]
    #[doc = "                 specifying the number of Miller-Rabin rounds."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to check for primality."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG parameter to be passed to \\p f_rng."]
    #[doc = "                 This may be \\c NULL if \\p f_rng doesn't use a"]
    #[doc = "                 context parameter."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful, i.e. \\p X is probably prime."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p X is not prime."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_is_prime"]
    pub fn mpi_is_prime(
        X: *const mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Miller-Rabin primality test."]
    #[doc = ""]
    #[doc = " \\warning        If \\p X is potentially generated by an adversary, for example"]
    #[doc = "                 when validating cryptographic parameters that you didn't"]
    #[doc = "                 generate yourself and that are supposed to be prime, then"]
    #[doc = "                 \\p rounds should be at least the half of the security"]
    #[doc = "                 strength of the cryptographic algorithm. On the other hand,"]
    #[doc = "                 if \\p X is chosen uniformly or non-adversially (as is the"]
    #[doc = "                 case when mbedtls_mpi_gen_prime calls this function), then"]
    #[doc = "                 \\p rounds can be much lower."]
    #[doc = ""]
    #[doc = " \\param X        The MPI to check for primality."]
    #[doc = "                 This must point to an initialized MPI."]
    #[doc = " \\param rounds   The number of bases to perform the Miller-Rabin primality"]
    #[doc = "                 test for. The probability of returning 0 on a composite is"]
    #[doc = "                 at most 2<sup>-2*\\p rounds</sup>."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG parameter to be passed to \\p f_rng."]
    #[doc = "                 This may be \\c NULL if \\p f_rng doesn't use"]
    #[doc = "                 a context parameter."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful, i.e. \\p X is probably prime."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p X is not prime."]
    #[doc = " \\return         Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_mpi_is_prime_ext"]
    pub fn mpi_is_prime_ext(
        X: *const mpi,
        rounds: crate::types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
#[repr(u32)]
#[doc = " \\brief Flags for mbedtls_mpi_gen_prime()"]
#[doc = ""]
#[doc = " Each of these flags is a constraint on the result X returned by"]
#[doc = " mbedtls_mpi_gen_prime()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mpi_gen_prime_flag_t {
    #[doc = "< (X-1)/2 is prime too"]
    MPI_GEN_PRIME_FLAG_DH = 1,
    #[doc = "< lower error rate from 2<sup>-80</sup> to 2<sup>-128</sup>"]
    MPI_GEN_PRIME_FLAG_LOW_ERR = 2,
}
extern "C" {
    #[doc = " \\brief          Generate a prime number."]
    #[doc = ""]
    #[doc = " \\param X        The destination MPI to store the generated prime in."]
    #[doc = "                 This must point to an initialized MPi."]
    #[doc = " \\param nbits    The required size of the destination MPI in bits."]
    #[doc = "                 This must be between \\c 3 and #MBEDTLS_MPI_MAX_BITS."]
    #[doc = " \\param flags    A mask of flags of type #mbedtls_mpi_gen_prime_flag_t."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG parameter to be passed to \\p f_rng."]
    #[doc = "                 This may be \\c NULL if \\p f_rng doesn't use"]
    #[doc = "                 a context parameter."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful, in which case \\p X holds a"]
    #[doc = "                 probably prime number."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if `nbits` is not between"]
    #[doc = "                 \\c 3 and #MBEDTLS_MPI_MAX_BITS."]
    #[link_name = "\u{1}mbedtls_mpi_gen_prime"]
    pub fn mpi_gen_prime(
        X: *mut mpi,
        nbits: usize,
        flags: crate::types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[link_name = "\u{1}mbedtls_mpi_self_test"]
    pub fn mpi_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[repr(u32)]
#[doc = " \\brief     Supported message digests."]
#[doc = ""]
#[doc = " \\warning   MD2, MD4, MD5 and SHA-1 are considered weak message digests and"]
#[doc = "            their use constitutes a security risk. We recommend considering"]
#[doc = "            stronger message digests instead."]
#[doc = ""]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum md_type_t {
    #[doc = "< None."]
    MD_NONE = 0,
    #[doc = "< The MD2 message digest."]
    MD_MD2 = 1,
    #[doc = "< The MD4 message digest."]
    MD_MD4 = 2,
    #[doc = "< The MD5 message digest."]
    MD_MD5 = 3,
    #[doc = "< The SHA-1 message digest."]
    MD_SHA1 = 4,
    #[doc = "< The SHA-224 message digest."]
    MD_SHA224 = 5,
    #[doc = "< The SHA-256 message digest."]
    MD_SHA256 = 6,
    #[doc = "< The SHA-384 message digest."]
    MD_SHA384 = 7,
    #[doc = "< The SHA-512 message digest."]
    MD_SHA512 = 8,
    #[doc = "< The RIPEMD-160 message digest."]
    MD_RIPEMD160 = 9,
}
#[doc = " The generic message-digest context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct md_context_t {
    #[doc = " Information about the associated message digest."]
    pub md_info: *const md_info_t,
    #[doc = " The digest-specific context."]
    pub md_ctx: *mut crate::types::c_void,
    #[doc = " The HMAC part of the context."]
    pub hmac_ctx: *mut crate::types::c_void,
}
#[test]
fn bindgen_test_layout_md_context_t() {
    assert_eq!(
        ::core::mem::size_of::<md_context_t>(),
        12usize,
        concat!("Size of: ", stringify!(md_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<md_context_t>(),
        4usize,
        concat!("Alignment of ", stringify!(md_context_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_context_t>())).md_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_context_t),
            "::",
            stringify!(md_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_context_t>())).md_ctx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(md_context_t),
            "::",
            stringify!(md_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_context_t>())).hmac_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md_context_t),
            "::",
            stringify!(hmac_ctx)
        )
    );
}
impl Default for md_context_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           This function returns the list of digests supported by the"]
    #[doc = "                  generic digest module."]
    #[doc = ""]
    #[doc = " \\note            The list starts with the strongest available hashes."]
    #[doc = ""]
    #[doc = " \\return          A statically allocated array of digests. Each element"]
    #[doc = "                  in the returned list is an integer belonging to the"]
    #[doc = "                  message-digest enumeration #mbedtls_md_type_t."]
    #[doc = "                  The last entry is 0."]
    #[link_name = "\u{1}mbedtls_md_list"]
    pub fn md_list() -> *const crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information"]
    #[doc = "                  associated with the given digest name."]
    #[doc = ""]
    #[doc = " \\param md_name   The name of the digest to search for."]
    #[doc = ""]
    #[doc = " \\return          The message-digest information associated with \\p md_name."]
    #[doc = " \\return          NULL if the associated message-digest information is not found."]
    #[link_name = "\u{1}mbedtls_md_info_from_string"]
    pub fn md_info_from_string(md_name: *const crate::types::c_char) -> *const md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information"]
    #[doc = "                  associated with the given digest type."]
    #[doc = ""]
    #[doc = " \\param md_type   The type of digest to search for."]
    #[doc = ""]
    #[doc = " \\return          The message-digest information associated with \\p md_type."]
    #[doc = " \\return          NULL if the associated message-digest information is not found."]
    #[link_name = "\u{1}mbedtls_md_info_from_type"]
    pub fn md_info_from_type(md_type: md_type_t) -> *const md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function initializes a message-digest context without"]
    #[doc = "                  binding it to a particular message-digest algorithm."]
    #[doc = ""]
    #[doc = "                  This function should always be called first. It prepares the"]
    #[doc = "                  context for mbedtls_md_setup() for binding it to a"]
    #[doc = "                  message-digest algorithm."]
    #[link_name = "\u{1}mbedtls_md_init"]
    pub fn md_init(ctx: *mut md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function clears the internal structure of \\p ctx and"]
    #[doc = "                  frees any embedded internal structure, but does not free"]
    #[doc = "                  \\p ctx itself."]
    #[doc = ""]
    #[doc = "                  If you have called mbedtls_md_setup() on \\p ctx, you must"]
    #[doc = "                  call mbedtls_md_free() when you are no longer using the"]
    #[doc = "                  context."]
    #[doc = "                  Calling this function if you have previously"]
    #[doc = "                  called mbedtls_md_init() and nothing else is optional."]
    #[doc = "                  You must not call this function if you have not called"]
    #[doc = "                  mbedtls_md_init()."]
    #[link_name = "\u{1}mbedtls_md_free"]
    pub fn md_free(ctx: *mut md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function selects the message digest algorithm to use,"]
    #[doc = "                  and allocates internal structures."]
    #[doc = ""]
    #[doc = "                  It should be called after mbedtls_md_init() or mbedtls_md_free()."]
    #[doc = "                  Makes it necessary to call mbedtls_md_free() later."]
    #[doc = ""]
    #[doc = " \\deprecated      Superseded by mbedtls_md_setup() in 2.0.0"]
    #[doc = ""]
    #[doc = " \\param ctx       The context to set up."]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure."]
    #[link_name = "\u{1}mbedtls_md_init_ctx"]
    pub fn md_init_ctx(ctx: *mut md_context_t, md_info: *const md_info_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function selects the message digest algorithm to use,"]
    #[doc = "                  and allocates internal structures."]
    #[doc = ""]
    #[doc = "                  It should be called after mbedtls_md_init() or"]
    #[doc = "                  mbedtls_md_free(). Makes it necessary to call"]
    #[doc = "                  mbedtls_md_free() later."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to set up."]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = " \\param hmac      Defines if HMAC is used. 0: HMAC is not used (saves some memory),"]
    #[doc = "                  or non-zero: HMAC is used with this context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure."]
    #[link_name = "\u{1}mbedtls_md_setup"]
    pub fn md_setup(
        ctx: *mut md_context_t,
        md_info: *const md_info_t,
        hmac: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function clones the state of an message-digest"]
    #[doc = "                  context."]
    #[doc = ""]
    #[doc = " \\note            You must call mbedtls_md_setup() on \\c dst before calling"]
    #[doc = "                  this function."]
    #[doc = ""]
    #[doc = " \\note            The two contexts must have the same type,"]
    #[doc = "                  for example, both are SHA-256."]
    #[doc = ""]
    #[doc = " \\warning         This function clones the message-digest state, not the"]
    #[doc = "                  HMAC state."]
    #[doc = ""]
    #[doc = " \\param dst       The destination context."]
    #[doc = " \\param src       The context to be cloned."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification failure."]
    #[link_name = "\u{1}mbedtls_md_clone"]
    pub fn md_clone(dst: *mut md_context_t, src: *const md_context_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest size from the"]
    #[doc = "                  message-digest information structure."]
    #[doc = ""]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          The size of the message-digest output in Bytes."]
    #[link_name = "\u{1}mbedtls_md_get_size"]
    pub fn md_get_size(md_info: *const md_info_t) -> crate::types::c_uchar;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest type from the"]
    #[doc = "                  message-digest information structure."]
    #[doc = ""]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          The type of the message digest."]
    #[link_name = "\u{1}mbedtls_md_get_type"]
    pub fn md_get_type(md_info: *const md_info_t) -> md_type_t;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest name from the"]
    #[doc = "                  message-digest information structure."]
    #[doc = ""]
    #[doc = " \\param md_info   The information structure of the message-digest algorithm"]
    #[doc = "                  to use."]
    #[doc = ""]
    #[doc = " \\return          The name of the message digest."]
    #[link_name = "\u{1}mbedtls_md_get_name"]
    pub fn md_get_name(md_info: *const md_info_t) -> *const crate::types::c_char;
}
extern "C" {
    #[doc = " \\brief           This function starts a message-digest computation."]
    #[doc = ""]
    #[doc = "                  You must call this function after setting up the context"]
    #[doc = "                  with mbedtls_md_setup(), and before passing data with"]
    #[doc = "                  mbedtls_md_update()."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic message-digest context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[link_name = "\u{1}mbedtls_md_starts"]
    pub fn md_starts(ctx: *mut md_context_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing"]
    #[doc = "                  message-digest computation."]
    #[doc = ""]
    #[doc = "                  You must call mbedtls_md_starts() before calling this"]
    #[doc = "                  function. You may call this function multiple times."]
    #[doc = "                  Afterwards, call mbedtls_md_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic message-digest context."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param ilen      The length of the input data."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[link_name = "\u{1}mbedtls_md_update"]
    pub fn md_update(
        ctx: *mut md_context_t,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the digest operation,"]
    #[doc = "                  and writes the result to the output buffer."]
    #[doc = ""]
    #[doc = "                  Call this function after a call to mbedtls_md_starts(),"]
    #[doc = "                  followed by any number of calls to mbedtls_md_update()."]
    #[doc = "                  Afterwards, you may either clear the context with"]
    #[doc = "                  mbedtls_md_free(), or call mbedtls_md_starts() to reuse"]
    #[doc = "                  the context for another digest operation with the same"]
    #[doc = "                  algorithm."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic message-digest context."]
    #[doc = " \\param output    The buffer for the generic message-digest checksum result."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[link_name = "\u{1}mbedtls_md_finish"]
    pub fn md_finish(
        ctx: *mut md_context_t,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the message-digest of a buffer,"]
    #[doc = "                 with respect to a configurable message-digest algorithm"]
    #[doc = "                 in a single call."]
    #[doc = ""]
    #[doc = "                 The result is calculated as"]
    #[doc = "                 Output = message_digest(input buffer)."]
    #[doc = ""]
    #[doc = " \\param md_info  The information structure of the message-digest algorithm"]
    #[doc = "                 to use."]
    #[doc = " \\param input    The buffer holding the data."]
    #[doc = " \\param ilen     The length of the input data."]
    #[doc = " \\param output   The generic message-digest checksum result."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                 failure."]
    #[link_name = "\u{1}mbedtls_md"]
    pub fn md(
        md_info: *const md_info_t,
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the HMAC key and prepares to"]
    #[doc = "                  authenticate a new message."]
    #[doc = ""]
    #[doc = "                  Call this function after mbedtls_md_setup(), to use"]
    #[doc = "                  the MD context for an HMAC calculation, then call"]
    #[doc = "                  mbedtls_md_hmac_update() to provide the input data, and"]
    #[doc = "                  mbedtls_md_hmac_finish() to get the HMAC value."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = " \\param key       The HMAC secret key."]
    #[doc = " \\param keylen    The length of the HMAC key in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[link_name = "\u{1}mbedtls_md_hmac_starts"]
    pub fn md_hmac_starts(
        ctx: *mut md_context_t,
        key: *const crate::types::c_uchar,
        keylen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing HMAC"]
    #[doc = "                  computation."]
    #[doc = ""]
    #[doc = "                  Call mbedtls_md_hmac_starts() or mbedtls_md_hmac_reset()"]
    #[doc = "                  before calling this function."]
    #[doc = "                  You may call this function multiple times to pass the"]
    #[doc = "                  input piecewise."]
    #[doc = "                  Afterwards, call mbedtls_md_hmac_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param ilen      The length of the input data."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[link_name = "\u{1}mbedtls_md_hmac_update"]
    pub fn md_hmac_update(
        ctx: *mut md_context_t,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the HMAC operation, and writes"]
    #[doc = "                  the result to the output buffer."]
    #[doc = ""]
    #[doc = "                  Call this function after mbedtls_md_hmac_starts() and"]
    #[doc = "                  mbedtls_md_hmac_update() to get the HMAC value. Afterwards"]
    #[doc = "                  you may either call mbedtls_md_free() to clear the context,"]
    #[doc = "                  or call mbedtls_md_hmac_reset() to reuse the context with"]
    #[doc = "                  the same HMAC key."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = " \\param output    The generic HMAC checksum result."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[link_name = "\u{1}mbedtls_md_hmac_finish"]
    pub fn md_hmac_finish(
        ctx: *mut md_context_t,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function prepares to authenticate a new message with"]
    #[doc = "                  the same key as the previous HMAC operation."]
    #[doc = ""]
    #[doc = "                  You may call this function after mbedtls_md_hmac_finish()."]
    #[doc = "                  Afterwards call mbedtls_md_hmac_update() to pass the new"]
    #[doc = "                  input."]
    #[doc = ""]
    #[doc = " \\param ctx       The message digest context containing an embedded HMAC"]
    #[doc = "                  context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                  failure."]
    #[link_name = "\u{1}mbedtls_md_hmac_reset"]
    pub fn md_hmac_reset(ctx: *mut md_context_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the full generic HMAC"]
    #[doc = "                 on the input buffer with the provided key."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The HMAC result is calculated as"]
    #[doc = "                 output = generic HMAC(hmac key, input buffer)."]
    #[doc = ""]
    #[doc = " \\param md_info  The information structure of the message-digest algorithm"]
    #[doc = "                 to use."]
    #[doc = " \\param key      The HMAC secret key."]
    #[doc = " \\param keylen   The length of the HMAC secret key in Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = " \\param ilen     The length of the input data."]
    #[doc = " \\param output   The generic HMAC result."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification"]
    #[doc = "                 failure."]
    #[link_name = "\u{1}mbedtls_md_hmac"]
    pub fn md_hmac(
        md_info: *const md_info_t,
        key: *const crate::types::c_uchar,
        keylen: usize,
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md_process"]
    pub fn md_process(
        ctx: *mut md_context_t,
        data: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
#[doc = " Message digest information."]
#[doc = " Allows message digest functions to be called in a generic way."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct md_info_t {
    #[doc = " Name of the message digest"]
    pub name: *const crate::types::c_char,
    #[doc = " Digest identifier"]
    pub type_: md_type_t,
    #[doc = " Output length of the digest function in bytes"]
    pub size: crate::types::c_uchar,
    #[doc = " Block length of the digest function in bytes"]
    pub block_size: crate::types::c_uchar,
}
#[test]
fn bindgen_test_layout_md_info_t() {
    assert_eq!(
        ::core::mem::size_of::<md_info_t>(),
        12usize,
        concat!("Size of: ", stringify!(md_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<md_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(md_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).block_size as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(block_size)
        )
    );
}
impl Default for md_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_md5_info"]
    pub static md5_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ripemd160_info"]
    pub static ripemd160_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha1_info"]
    pub static sha1_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha224_info"]
    pub static sha224_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha256_info"]
    pub static sha256_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha384_info"]
    pub static sha384_info: md_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_sha512_info"]
    pub static sha512_info: md_info_t;
}
#[repr(u32)]
#[doc = " Domain-parameter identifiers: curve, subgroup, and generator."]
#[doc = ""]
#[doc = " \\note Only curves over prime fields are supported."]
#[doc = ""]
#[doc = " \\warning This library does not support validation of arbitrary domain"]
#[doc = " parameters. Therefore, only standardized domain parameters from trusted"]
#[doc = " sources should be used. See mbedtls_ecp_group_load()."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ecp_group_id {
    #[doc = "< Curve not defined."]
    ECP_DP_NONE = 0,
    #[doc = "< Domain parameters for the 192-bit curve defined by FIPS 186-4 and SEC1."]
    ECP_DP_SECP192R1 = 1,
    #[doc = "< Domain parameters for the 224-bit curve defined by FIPS 186-4 and SEC1."]
    ECP_DP_SECP224R1 = 2,
    #[doc = "< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1."]
    ECP_DP_SECP256R1 = 3,
    #[doc = "< Domain parameters for the 384-bit curve defined by FIPS 186-4 and SEC1."]
    ECP_DP_SECP384R1 = 4,
    #[doc = "< Domain parameters for the 521-bit curve defined by FIPS 186-4 and SEC1."]
    ECP_DP_SECP521R1 = 5,
    #[doc = "< Domain parameters for 256-bit Brainpool curve."]
    ECP_DP_BP256R1 = 6,
    #[doc = "< Domain parameters for 384-bit Brainpool curve."]
    ECP_DP_BP384R1 = 7,
    #[doc = "< Domain parameters for 512-bit Brainpool curve."]
    ECP_DP_BP512R1 = 8,
    #[doc = "< Domain parameters for Curve25519."]
    ECP_DP_CURVE25519 = 9,
    #[doc = "< Domain parameters for 192-bit \"Koblitz\" curve."]
    ECP_DP_SECP192K1 = 10,
    #[doc = "< Domain parameters for 224-bit \"Koblitz\" curve."]
    ECP_DP_SECP224K1 = 11,
    #[doc = "< Domain parameters for 256-bit \"Koblitz\" curve."]
    ECP_DP_SECP256K1 = 12,
    #[doc = "< Domain parameters for Curve448."]
    ECP_DP_CURVE448 = 13,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ecp_curve_type {
    ECP_TYPE_NONE = 0,
    ECP_TYPE_SHORT_WEIERSTRASS = 1,
    ECP_TYPE_MONTGOMERY = 2,
}
#[doc = " Curve information, for use by other modules."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecp_curve_info {
    #[doc = "< An internal identifier."]
    pub grp_id: ecp_group_id,
    #[doc = "< The TLS NamedCurve identifier."]
    pub tls_id: u16,
    #[doc = "< The curve size in bits."]
    pub bit_size: u16,
    #[doc = "< A human-friendly name."]
    pub name: *const crate::types::c_char,
}
#[test]
fn bindgen_test_layout_ecp_curve_info() {
    assert_eq!(
        ::core::mem::size_of::<ecp_curve_info>(),
        12usize,
        concat!("Size of: ", stringify!(ecp_curve_info))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_curve_info>(),
        4usize,
        concat!("Alignment of ", stringify!(ecp_curve_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_curve_info>())).grp_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(grp_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_curve_info>())).tls_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(tls_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_curve_info>())).bit_size as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_curve_info>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(name)
        )
    );
}
impl Default for ecp_curve_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " \\brief           The ECP point structure, in Jacobian coordinates."]
#[doc = ""]
#[doc = " \\note            All functions expect and return points satisfying"]
#[doc = "                  the following condition: <code>Z == 0</code> or"]
#[doc = "                  <code>Z == 1</code>. Other values of \\p Z are"]
#[doc = "                  used only by internal functions."]
#[doc = "                  The point is zero, or \"at infinity\", if <code>Z == 0</code>."]
#[doc = "                  Otherwise, \\p X and \\p Y are its standard (affine)"]
#[doc = "                  coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecp_point {
    #[doc = "< The X coordinate of the ECP point."]
    pub X: mpi,
    #[doc = "< The Y coordinate of the ECP point."]
    pub Y: mpi,
    #[doc = "< The Z coordinate of the ECP point."]
    pub Z: mpi,
}
#[test]
fn bindgen_test_layout_ecp_point() {
    assert_eq!(
        ::core::mem::size_of::<ecp_point>(),
        36usize,
        concat!("Size of: ", stringify!(ecp_point))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_point>(),
        4usize,
        concat!("Alignment of ", stringify!(ecp_point))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_point>())).X as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_point),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_point>())).Y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_point),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_point>())).Z as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_point),
            "::",
            stringify!(Z)
        )
    );
}
impl Default for ecp_point {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " \\brief           The ECP group structure."]
#[doc = ""]
#[doc = " We consider two types of curve equations:"]
#[doc = " <ul><li>Short Weierstrass: <code>y^2 = x^3 + A x + B mod P</code>"]
#[doc = " (SEC1 + RFC-4492)</li>"]
#[doc = " <li>Montgomery: <code>y^2 = x^3 + A x^2 + x mod P</code> (Curve25519,"]
#[doc = " Curve448)</li></ul>"]
#[doc = " In both cases, the generator (\\p G) for a prime-order subgroup is fixed."]
#[doc = ""]
#[doc = " For Short Weierstrass, this subgroup is the whole curve, and its"]
#[doc = " cardinality is denoted by \\p N. Our code requires that \\p N is an"]
#[doc = " odd prime as mbedtls_ecp_mul() requires an odd number, and"]
#[doc = " mbedtls_ecdsa_sign() requires that it is prime for blinding purposes."]
#[doc = ""]
#[doc = " For Montgomery curves, we do not store \\p A, but <code>(A + 2) / 4</code>,"]
#[doc = " which is the quantity used in the formulas. Additionally, \\p nbits is"]
#[doc = " not the size of \\p N but the required size for private keys."]
#[doc = ""]
#[doc = " If \\p modp is NULL, reduction modulo \\p P is done using a generic algorithm."]
#[doc = " Otherwise, \\p modp must point to a function that takes an \\p mbedtls_mpi in the"]
#[doc = " range of <code>0..2^(2*pbits)-1</code>, and transforms it in-place to an integer"]
#[doc = " which is congruent mod \\p P to the given MPI, and is close enough to \\p pbits"]
#[doc = " in size, so that it may be efficiently brought in the 0..P-1 range by a few"]
#[doc = " additions or subtractions. Therefore, it is only an approximative modular"]
#[doc = " reduction. It must return 0 on success and non-zero on failure."]
#[doc = ""]
#[doc = " \\note        Alternative implementations must keep the group IDs distinct. If"]
#[doc = "              two group structures have the same ID, then they must be"]
#[doc = "              identical."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecp_group {
    #[doc = "< An internal group identifier."]
    pub id: ecp_group_id,
    #[doc = "< The prime modulus of the base field."]
    pub P: mpi,
    #[doc = "< For Short Weierstrass: \\p A in the equation. For"]
    #[doc = "Montgomery curves: <code>(A + 2) / 4</code>."]
    pub A: mpi,
    #[doc = "< For Short Weierstrass: \\p B in the equation."]
    #[doc = "For Montgomery curves: unused."]
    pub B: mpi,
    #[doc = "< The generator of the subgroup used."]
    pub G: ecp_point,
    #[doc = "< The order of \\p G."]
    pub N: mpi,
    #[doc = "< The number of bits in \\p P."]
    pub pbits: usize,
    #[doc = "< For Short Weierstrass: The number of bits in \\p P."]
    #[doc = "For Montgomery curves: the number of bits in the"]
    #[doc = "private keys."]
    pub nbits: usize,
    #[doc = "< \\internal 1 if the constants are static."]
    pub h: crate::types::c_uint,
    #[doc = "< The function for fast pseudo-reduction"]
    #[doc = "mod \\p P (see above)."]
    pub modp: ::core::option::Option<unsafe extern "C" fn(arg1: *mut mpi) -> crate::types::c_int>,
    #[doc = "< Unused."]
    pub t_pre: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ecp_point,
            arg2: *mut crate::types::c_void,
        ) -> crate::types::c_int,
    >,
    #[doc = "< Unused."]
    pub t_post: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ecp_point,
            arg2: *mut crate::types::c_void,
        ) -> crate::types::c_int,
    >,
    #[doc = "< Unused."]
    pub t_data: *mut crate::types::c_void,
    #[doc = "< Pre-computed points for ecp_mul_comb()."]
    pub T: *mut ecp_point,
    #[doc = "< The number of pre-computed points."]
    pub T_size: usize,
}
#[test]
fn bindgen_test_layout_ecp_group() {
    assert_eq!(
        ::core::mem::size_of::<ecp_group>(),
        124usize,
        concat!("Size of: ", stringify!(ecp_group))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_group>(),
        4usize,
        concat!("Alignment of ", stringify!(ecp_group))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).P as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).A as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).B as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).G as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).N as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).pbits as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(pbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).nbits as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(nbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).h as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).modp as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(modp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).t_pre as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(t_pre)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).t_post as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(t_post)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).t_data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(t_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).T as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(T)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).T_size as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(T_size)
        )
    );
}
impl Default for ecp_group {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ecp_restart_ctx = crate::types::c_void;
#[doc = " \\brief    The ECP key-pair structure."]
#[doc = ""]
#[doc = " A generic key-pair that may be used for ECDSA and fixed ECDH, for example."]
#[doc = ""]
#[doc = " \\note    Members are deliberately in the same order as in the"]
#[doc = "          ::mbedtls_ecdsa_context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecp_keypair {
    #[doc = "<  Elliptic curve and base point"]
    pub grp: ecp_group,
    #[doc = "<  our secret value"]
    pub d: mpi,
    #[doc = "<  our public value"]
    pub Q: ecp_point,
}
#[test]
fn bindgen_test_layout_ecp_keypair() {
    assert_eq!(
        ::core::mem::size_of::<ecp_keypair>(),
        172usize,
        concat!("Size of: ", stringify!(ecp_keypair))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_keypair>(),
        4usize,
        concat!("Alignment of ", stringify!(ecp_keypair))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_keypair>())).grp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_keypair),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_keypair>())).d as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_keypair),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_keypair>())).Q as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_keypair),
            "::",
            stringify!(Q)
        )
    );
}
impl Default for ecp_keypair {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecp_get_type"]
    pub fn ecp_get_type(grp: *const ecp_group) -> ecp_curve_type;
}
extern "C" {
    #[doc = " \\brief           This function retrieves the information defined in"]
    #[doc = "                  mbedtls_ecp_curve_info() for all supported curves in order"]
    #[doc = "                  of preference."]
    #[doc = ""]
    #[doc = " \\note            This function returns information about all curves"]
    #[doc = "                  supported by the library. Some curves may not be"]
    #[doc = "                  supported for all algorithms. Call mbedtls_ecdh_can_do()"]
    #[doc = "                  or mbedtls_ecdsa_can_do() to check if a curve is"]
    #[doc = "                  supported for ECDH or ECDSA."]
    #[doc = ""]
    #[doc = " \\return          A statically allocated array. The last entry is 0."]
    #[link_name = "\u{1}mbedtls_ecp_curve_list"]
    pub fn ecp_curve_list() -> *const ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves the list of internal group"]
    #[doc = "                  identifiers of all supported curves in the order of"]
    #[doc = "                  preference."]
    #[doc = ""]
    #[doc = " \\note            This function returns information about all curves"]
    #[doc = "                  supported by the library. Some curves may not be"]
    #[doc = "                  supported for all algorithms. Call mbedtls_ecdh_can_do()"]
    #[doc = "                  or mbedtls_ecdsa_can_do() to check if a curve is"]
    #[doc = "                  supported for ECDH or ECDSA."]
    #[doc = ""]
    #[doc = " \\return          A statically allocated array,"]
    #[doc = "                  terminated with MBEDTLS_ECP_DP_NONE."]
    #[link_name = "\u{1}mbedtls_ecp_grp_id_list"]
    pub fn ecp_grp_id_list() -> *const ecp_group_id;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from an internal"]
    #[doc = "                  group identifier."]
    #[doc = ""]
    #[doc = " \\param grp_id    An \\c MBEDTLS_ECP_DP_XXX value."]
    #[doc = ""]
    #[doc = " \\return          The associated curve information on success."]
    #[doc = " \\return          NULL on failure."]
    #[link_name = "\u{1}mbedtls_ecp_curve_info_from_grp_id"]
    pub fn ecp_curve_info_from_grp_id(grp_id: ecp_group_id) -> *const ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a TLS"]
    #[doc = "                  NamedCurve value."]
    #[doc = ""]
    #[doc = " \\param tls_id    An \\c MBEDTLS_ECP_DP_XXX value."]
    #[doc = ""]
    #[doc = " \\return          The associated curve information on success."]
    #[doc = " \\return          NULL on failure."]
    #[link_name = "\u{1}mbedtls_ecp_curve_info_from_tls_id"]
    pub fn ecp_curve_info_from_tls_id(tls_id: u16) -> *const ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a"]
    #[doc = "                  human-readable name."]
    #[doc = ""]
    #[doc = " \\param name      The human-readable name."]
    #[doc = ""]
    #[doc = " \\return          The associated curve information on success."]
    #[doc = " \\return          NULL on failure."]
    #[link_name = "\u{1}mbedtls_ecp_curve_info_from_name"]
    pub fn ecp_curve_info_from_name(name: *const crate::types::c_char) -> *const ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function initializes a point as zero."]
    #[doc = ""]
    #[doc = " \\param pt        The point to initialize."]
    #[link_name = "\u{1}mbedtls_ecp_point_init"]
    pub fn ecp_point_init(pt: *mut ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECP group context"]
    #[doc = "                  without loading any domain parameters."]
    #[doc = ""]
    #[doc = " \\note            After this function is called, domain parameters"]
    #[doc = "                  for various ECP groups can be loaded through the"]
    #[doc = "                  mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()"]
    #[doc = "                  functions."]
    #[link_name = "\u{1}mbedtls_ecp_group_init"]
    pub fn ecp_group_init(grp: *mut ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function initializes a key pair as an invalid one."]
    #[doc = ""]
    #[doc = " \\param key       The key pair to initialize."]
    #[link_name = "\u{1}mbedtls_ecp_keypair_init"]
    pub fn ecp_keypair_init(key: *mut ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a point."]
    #[doc = ""]
    #[doc = " \\param pt        The point to free."]
    #[link_name = "\u{1}mbedtls_ecp_point_free"]
    pub fn ecp_point_free(pt: *mut ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of an ECP group."]
    #[doc = ""]
    #[doc = " \\param grp       The group to free. This may be \\c NULL, in which"]
    #[doc = "                  case this function returns immediately. If it is not"]
    #[doc = "                  \\c NULL, it must point to an initialized ECP group."]
    #[link_name = "\u{1}mbedtls_ecp_group_free"]
    pub fn ecp_group_free(grp: *mut ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a key pair."]
    #[doc = ""]
    #[doc = " \\param key       The key pair to free. This may be \\c NULL, in which"]
    #[doc = "                  case this function returns immediately. If it is not"]
    #[doc = "                  \\c NULL, it must point to an initialized ECP key pair."]
    #[link_name = "\u{1}mbedtls_ecp_keypair_free"]
    pub fn ecp_keypair_free(key: *mut ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of point \\p Q into"]
    #[doc = "                  point \\p P."]
    #[doc = ""]
    #[doc = " \\param P         The destination point. This must be initialized."]
    #[doc = " \\param Q         The source point. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          Another negative error code for other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_copy"]
    pub fn ecp_copy(P: *mut ecp_point, Q: *const ecp_point) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of group \\p src into"]
    #[doc = "                  group \\p dst."]
    #[doc = ""]
    #[doc = " \\param dst       The destination group. This must be initialized."]
    #[doc = " \\param src       The source group. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_group_copy"]
    pub fn ecp_group_copy(dst: *mut ecp_group, src: *const ecp_group) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets a point to the point at infinity."]
    #[doc = ""]
    #[doc = " \\param pt        The point to set. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_set_zero"]
    pub fn ecp_set_zero(pt: *mut ecp_point) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks if a point is the point at infinity."]
    #[doc = ""]
    #[doc = " \\param pt        The point to test. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 1 if the point is zero."]
    #[doc = " \\return          \\c 0 if the point is non-zero."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_ecp_is_zero"]
    pub fn ecp_is_zero(pt: *mut ecp_point) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function compares two points."]
    #[doc = ""]
    #[doc = " \\note            This assumes that the points are normalized. Otherwise,"]
    #[doc = "                  they may compare as \"not equal\" even if they are."]
    #[doc = ""]
    #[doc = " \\param P         The first point to compare. This must be initialized."]
    #[doc = " \\param Q         The second point to compare. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the points are equal."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the points are not equal."]
    #[link_name = "\u{1}mbedtls_ecp_point_cmp"]
    pub fn ecp_point_cmp(P: *const ecp_point, Q: *const ecp_point) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a non-zero point from two ASCII"]
    #[doc = "                  strings."]
    #[doc = ""]
    #[doc = " \\param P         The destination point. This must be initialized."]
    #[doc = " \\param radix     The numeric base of the input."]
    #[doc = " \\param x         The first affine coordinate, as a null-terminated string."]
    #[doc = " \\param y         The second affine coordinate, as a null-terminated string."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecp_point_read_string"]
    pub fn ecp_point_read_string(
        P: *mut ecp_point,
        radix: crate::types::c_int,
        x: *const crate::types::c_char,
        y: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point into unsigned binary data."]
    #[doc = ""]
    #[doc = " \\param grp       The group to which the point should belong."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param P         The point to export. This must be initialized."]
    #[doc = " \\param format    The point format. This must be either"]
    #[doc = "                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED."]
    #[doc = "                  (For groups without these formats, this parameter is"]
    #[doc = "                  ignored. But it still has to be either of the above"]
    #[doc = "                  values.)"]
    #[doc = " \\param olen      The address at which to store the length of"]
    #[doc = "                  the output in Bytes. This must not be \\c NULL."]
    #[doc = " \\param buf       The output buffer. This must be a writable buffer"]
    #[doc = "                  of length \\p buflen Bytes."]
    #[doc = " \\param buflen    The length of the output buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output buffer"]
    #[doc = "                  is too small to hold the point."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format"]
    #[doc = "                  or the export for the given group is not implemented."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_point_write_binary"]
    pub fn ecp_point_write_binary(
        grp: *const ecp_group,
        P: *const ecp_point,
        format: crate::types::c_int,
        olen: *mut usize,
        buf: *mut crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from unsigned binary data."]
    #[doc = ""]
    #[doc = " \\note            This function does not check that the point actually"]
    #[doc = "                  belongs to the given group, see mbedtls_ecp_check_pubkey()"]
    #[doc = "                  for that."]
    #[doc = ""]
    #[doc = " \\param grp       The group to which the point should belong."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param P         The destination context to import the point to."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param buf       The input buffer. This must be a readable buffer"]
    #[doc = "                  of length \\p ilen Bytes."]
    #[doc = " \\param ilen      The length of the input buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the import for the"]
    #[doc = "                  given group is not implemented."]
    #[link_name = "\u{1}mbedtls_ecp_point_read_binary"]
    pub fn ecp_point_read_binary(
        grp: *const ecp_group,
        P: *mut ecp_point,
        buf: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from a TLS ECPoint record."]
    #[doc = ""]
    #[doc = " \\note            On function return, \\p *buf is updated to point immediately"]
    #[doc = "                  after the ECPoint record."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param pt        The destination point."]
    #[doc = " \\param buf       The address of the pointer to the start of the input buffer."]
    #[doc = " \\param len       The length of the buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on initialization"]
    #[doc = "                  failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    #[link_name = "\u{1}mbedtls_ecp_tls_read_point"]
    pub fn ecp_tls_read_point(
        grp: *const ecp_group,
        pt: *mut ecp_point,
        buf: *mut *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point as a TLS ECPoint record"]
    #[doc = "                  defined in RFC 4492, Section 5.4."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param pt        The point to be exported. This must be initialized."]
    #[doc = " \\param format    The point format to use. This must be either"]
    #[doc = "                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED."]
    #[doc = " \\param olen      The address at which to store the length in Bytes"]
    #[doc = "                  of the data written."]
    #[doc = " \\param buf       The target buffer. This must be a writable buffer of"]
    #[doc = "                  length \\p blen Bytes."]
    #[doc = " \\param blen      The length of the target buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the target buffer"]
    #[doc = "                  is too small to hold the exported point."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_tls_write_point"]
    pub fn ecp_tls_write_point(
        grp: *const ecp_group,
        pt: *const ecp_point,
        format: crate::types::c_int,
        olen: *mut usize,
        buf: *mut crate::types::c_uchar,
        blen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECP group context"]
    #[doc = "                  from a standardized set of domain parameters."]
    #[doc = ""]
    #[doc = " \\note            The index should be a value of the NamedCurve enum,"]
    #[doc = "                  as defined in <em>RFC-4492: Elliptic Curve Cryptography"]
    #[doc = "                  (ECC) Cipher Suites for Transport Layer Security (TLS)</em>,"]
    #[doc = "                  usually in the form of an \\c MBEDTLS_ECP_DP_XXX macro."]
    #[doc = ""]
    #[doc = " \\param grp       The group context to setup. This must be initialized."]
    #[doc = " \\param id        The identifier of the domain parameter set to load."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p id doesn't"]
    #[doc = "                  correspond to a known group."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_group_load"]
    pub fn ecp_group_load(grp: *mut ecp_group, id: ecp_group_id) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECP group context from a TLS"]
    #[doc = "                  ECParameters record as defined in RFC 4492, Section 5.4."]
    #[doc = ""]
    #[doc = " \\note            The read pointer \\p buf is updated to point right after"]
    #[doc = "                  the ECParameters record on exit."]
    #[doc = ""]
    #[doc = " \\param grp       The group context to setup. This must be initialized."]
    #[doc = " \\param buf       The address of the pointer to the start of the input buffer."]
    #[doc = " \\param len       The length of the input buffer \\c *buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not"]
    #[doc = "                  recognized."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_tls_read_group"]
    pub fn ecp_tls_read_group(
        grp: *mut ecp_group,
        buf: *mut *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function extracts an elliptic curve group ID from a"]
    #[doc = "                  TLS ECParameters record as defined in RFC 4492, Section 5.4."]
    #[doc = ""]
    #[doc = " \\note            The read pointer \\p buf is updated to point right after"]
    #[doc = "                  the ECParameters record on exit."]
    #[doc = ""]
    #[doc = " \\param grp       The address at which to store the group id."]
    #[doc = "                  This must not be \\c NULL."]
    #[doc = " \\param buf       The address of the pointer to the start of the input buffer."]
    #[doc = " \\param len       The length of the input buffer \\c *buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not"]
    #[doc = "                  recognized."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_tls_read_group_id"]
    pub fn ecp_tls_read_group_id(
        grp: *mut ecp_group_id,
        buf: *mut *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports an elliptic curve as a TLS"]
    #[doc = "                  ECParameters record as defined in RFC 4492, Section 5.4."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to be exported."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param olen      The address at which to store the number of Bytes written."]
    #[doc = "                  This must not be \\c NULL."]
    #[doc = " \\param buf       The buffer to write to. This must be a writable buffer"]
    #[doc = "                  of length \\p blen Bytes."]
    #[doc = " \\param blen      The length of the output buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output"]
    #[doc = "                  buffer is too small to hold the exported group."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_tls_write_group"]
    pub fn ecp_tls_write_group(
        grp: *const ecp_group,
        olen: *mut usize,
        buf: *mut crate::types::c_uchar,
        blen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a scalar multiplication of a point"]
    #[doc = "                  by an integer: \\p R = \\p m * \\p P."]
    #[doc = ""]
    #[doc = "                  It is not thread-safe to use same group in multiple threads."]
    #[doc = ""]
    #[doc = " \\note            To prevent timing attacks, this function"]
    #[doc = "                  executes the exact same sequence of base-field"]
    #[doc = "                  operations for any valid \\p m. It avoids any if-branch or"]
    #[doc = "                  array index depending on the value of \\p m."]
    #[doc = ""]
    #[doc = " \\note            If \\p f_rng is not NULL, it is used to randomize"]
    #[doc = "                  intermediate results to prevent potential timing attacks"]
    #[doc = "                  targeting these results. We recommend always providing"]
    #[doc = "                  a non-NULL \\p f_rng. The overhead is negligible."]
    #[doc = "                  Note: unless #MBEDTLS_ECP_NO_INTERNAL_RNG is defined, when"]
    #[doc = "                  \\p f_rng is NULL, an internal RNG (seeded from the value"]
    #[doc = "                  of \\p m) will be used instead."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param R         The point in which to store the result of the calculation."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param m         The integer by which to multiply. This must be initialized."]
    #[doc = " \\param P         The point to multiply. This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This may be \\c NULL if randomization"]
    #[doc = "                  of intermediate results isn't desired (discouraged)."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p p_rng."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private"]
    #[doc = "                  key, or \\p P is not a valid public key."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_mul"]
    pub fn ecp_mul(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication of a point by"]
    #[doc = "                  an integer: \\p R = \\p m * \\p P in a restartable way."]
    #[doc = ""]
    #[doc = " \\see             mbedtls_ecp_mul()"]
    #[doc = ""]
    #[doc = " \\note            This function does the same as \\c mbedtls_ecp_mul(), but"]
    #[doc = "                  it can return early and restart according to the limit set"]
    #[doc = "                  with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param R         The point in which to store the result of the calculation."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param m         The integer by which to multiply. This must be initialized."]
    #[doc = " \\param P         The point to multiply. This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This may be \\c NULL if randomization"]
    #[doc = "                  of intermediate results isn't desired (discouraged)."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p p_rng."]
    #[doc = " \\param rs_ctx    The restart context (NULL disables restart)."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private"]
    #[doc = "                  key, or \\p P is not a valid public key."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_mul_restartable"]
    pub fn ecp_mul_restartable(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        rs_ctx: *mut ecp_restart_ctx,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication and addition of two"]
    #[doc = "                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q"]
    #[doc = ""]
    #[doc = "                  It is not thread-safe to use same group in multiple threads."]
    #[doc = ""]
    #[doc = " \\note            In contrast to mbedtls_ecp_mul(), this function does not"]
    #[doc = "                  guarantee a constant execution flow and timing."]
    #[doc = ""]
    #[doc = " \\note            This function is only defined for short Weierstrass curves."]
    #[doc = "                  It may not be included in builds without any short"]
    #[doc = "                  Weierstrass curve."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param R         The point in which to store the result of the calculation."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param m         The integer by which to multiply \\p P."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param P         The point to multiply by \\p m. This must be initialized."]
    #[doc = " \\param n         The integer by which to multiply \\p Q."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The point to be multiplied by \\p n."]
    #[doc = "                  This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not"]
    #[doc = "                  valid private keys, or \\p P or \\p Q are not valid public"]
    #[doc = "                  keys."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not"]
    #[doc = "                  designate a short Weierstrass curve."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_muladd"]
    pub fn ecp_muladd(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        n: *const mpi,
        Q: *const ecp_point,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication and addition of two"]
    #[doc = "                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q in a"]
    #[doc = "                  restartable way."]
    #[doc = ""]
    #[doc = " \\see             \\c mbedtls_ecp_muladd()"]
    #[doc = ""]
    #[doc = " \\note            This function works the same as \\c mbedtls_ecp_muladd(),"]
    #[doc = "                  but it can return early and restart according to the limit"]
    #[doc = "                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\note            This function is only defined for short Weierstrass curves."]
    #[doc = "                  It may not be included in builds without any short"]
    #[doc = "                  Weierstrass curve."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param R         The point in which to store the result of the calculation."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param m         The integer by which to multiply \\p P."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param P         The point to multiply by \\p m. This must be initialized."]
    #[doc = " \\param n         The integer by which to multiply \\p Q."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The point to be multiplied by \\p n."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param rs_ctx    The restart context (NULL disables restart)."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not"]
    #[doc = "                  valid private keys, or \\p P or \\p Q are not valid public"]
    #[doc = "                  keys."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not"]
    #[doc = "                  designate a short Weierstrass curve."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_muladd_restartable"]
    pub fn ecp_muladd_restartable(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        n: *const mpi,
        Q: *const ecp_point,
        rs_ctx: *mut ecp_restart_ctx,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that a point is a valid public key"]
    #[doc = "                  on this curve."]
    #[doc = ""]
    #[doc = "                  It only checks that the point is non-zero, has"]
    #[doc = "                  valid coordinates and lies on the curve. It does not verify"]
    #[doc = "                  that it is indeed a multiple of \\p G. This additional"]
    #[doc = "                  check is computationally more expensive, is not required"]
    #[doc = "                  by standards, and should not be necessary if the group"]
    #[doc = "                  used has a small cofactor. In particular, it is useless for"]
    #[doc = "                  the NIST groups which all have a cofactor of 1."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure, to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group the point should belong to."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param pt        The point to check. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the point is a valid public key."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not"]
    #[doc = "                  a valid public key for the given curve."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_check_pubkey"]
    pub fn ecp_check_pubkey(grp: *const ecp_group, pt: *const ecp_point) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that an \\p mbedtls_mpi is a"]
    #[doc = "                  valid private key for this curve."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group the private key should belong to."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param d         The integer to check. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the point is a valid private key."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not a valid"]
    #[doc = "                  private key for the given curve."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_check_privkey"]
    pub fn ecp_check_privkey(grp: *const ecp_group, d: *const mpi) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a private key."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to generate a private key for."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param d         The destination MPI (secret part). This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG parameter to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    #[link_name = "\u{1}mbedtls_ecp_gen_privkey"]
    pub fn ecp_gen_privkey(
        grp: *const ecp_group,
        d: *mut mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a keypair with a configurable base"]
    #[doc = "                  point."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to generate a key pair for."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param G         The base point to use. This must be initialized"]
    #[doc = "                  and belong to \\p grp. It replaces the default base"]
    #[doc = "                  point \\c grp->G used by mbedtls_ecp_gen_keypair()."]
    #[doc = " \\param d         The destination MPI (secret part)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The destination point (public part)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                  be \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    #[link_name = "\u{1}mbedtls_ecp_gen_keypair_base"]
    pub fn ecp_gen_keypair_base(
        grp: *mut ecp_group,
        G: *const ecp_point,
        d: *mut mpi,
        Q: *mut ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP keypair."]
    #[doc = ""]
    #[doc = " \\note            This function uses bare components rather than an"]
    #[doc = "                  ::mbedtls_ecp_keypair structure to ease use with other"]
    #[doc = "                  structures, such as ::mbedtls_ecdh_context or"]
    #[doc = "                  ::mbedtls_ecdsa_context."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to generate a key pair for."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param d         The destination MPI (secret part)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The destination point (public part)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                  be \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    #[link_name = "\u{1}mbedtls_ecp_gen_keypair"]
    pub fn ecp_gen_keypair(
        grp: *mut ecp_group,
        d: *mut mpi,
        Q: *mut ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP key."]
    #[doc = ""]
    #[doc = " \\param grp_id    The ECP group identifier."]
    #[doc = " \\param key       The destination key. This must be initialized."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                  be \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code"]
    #[doc = "                  on failure."]
    #[link_name = "\u{1}mbedtls_ecp_gen_key"]
    pub fn ecp_gen_key(
        grp_id: ecp_group_id,
        key: *mut ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads an elliptic curve private key."]
    #[doc = ""]
    #[doc = " \\param grp_id    The ECP group identifier."]
    #[doc = " \\param key       The destination key."]
    #[doc = " \\param buf       The the buffer containing the binary representation of the"]
    #[doc = "                  key. (Big endian integer for Weierstrass curves, byte"]
    #[doc = "                  string for Montgomery curves.)"]
    #[doc = " \\param buflen    The length of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_INVALID_KEY error if the key is"]
    #[doc = "                  invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for"]
    #[doc = "                  the group is not implemented."]
    #[doc = " \\return          Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_read_key"]
    pub fn ecp_read_key(
        grp_id: ecp_group_id,
        key: *mut ecp_keypair,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports an elliptic curve private key."]
    #[doc = ""]
    #[doc = " \\param key       The private key."]
    #[doc = " \\param buf       The output buffer for containing the binary representation"]
    #[doc = "                  of the key. (Big endian integer for Weierstrass curves, byte"]
    #[doc = "                  string for Montgomery curves.)"]
    #[doc = " \\param buflen    The total length of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the \\p key"]
    #[doc = "representation is larger than the available space in \\p buf."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for"]
    #[doc = "                  the group is not implemented."]
    #[doc = " \\return          Another negative error code on different kinds of failure."]
    #[link_name = "\u{1}mbedtls_ecp_write_key"]
    pub fn ecp_write_key(
        key: *mut ecp_keypair,
        buf: *mut crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that the keypair objects"]
    #[doc = "                  \\p pub and \\p prv have the same group and the"]
    #[doc = "                  same public point, and that the private key in"]
    #[doc = "                  \\p prv is consistent with the public key."]
    #[doc = ""]
    #[doc = " \\param pub       The keypair structure holding the public key. This"]
    #[doc = "                  must be initialized. If it contains a private key, that"]
    #[doc = "                  part is ignored."]
    #[doc = " \\param prv       The keypair structure holding the full keypair."]
    #[doc = "                  This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success, meaning that the keys are valid and match."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the keys are invalid or do not match."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or an \\c MBEDTLS_ERR_MPI_XXX"]
    #[doc = "                  error code on calculation failure."]
    #[link_name = "\u{1}mbedtls_ecp_check_pub_priv"]
    pub fn ecp_check_pub_priv(
        pub_: *const ecp_keypair,
        prv: *const ecp_keypair,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          The ECP checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_ecp_self_test"]
    pub fn ecp_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief   The RSA context structure."]
#[doc = ""]
#[doc = " \\note    Direct manipulation of the members of this structure"]
#[doc = "          is deprecated. All manipulation should instead be done through"]
#[doc = "          the public interface functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_context {
    #[doc = "<  Always 0."]
    pub ver: crate::types::c_int,
    #[doc = "<  The size of \\p N in Bytes."]
    pub len: usize,
    #[doc = "<  The public modulus."]
    pub N: mpi,
    #[doc = "<  The public exponent."]
    pub E: mpi,
    #[doc = "<  The private exponent."]
    pub D: mpi,
    #[doc = "<  The first prime factor."]
    pub P: mpi,
    #[doc = "<  The second prime factor."]
    pub Q: mpi,
    #[doc = "<  <code>D % (P - 1)</code>."]
    pub DP: mpi,
    #[doc = "<  <code>D % (Q - 1)</code>."]
    pub DQ: mpi,
    #[doc = "<  <code>1 / (Q % P)</code>."]
    pub QP: mpi,
    #[doc = "<  cached <code>R^2 mod N</code>."]
    pub RN: mpi,
    #[doc = "<  cached <code>R^2 mod P</code>."]
    pub RP: mpi,
    #[doc = "<  cached <code>R^2 mod Q</code>."]
    pub RQ: mpi,
    #[doc = "<  The cached blinding value."]
    pub Vi: mpi,
    #[doc = "<  The cached un-blinding value."]
    pub Vf: mpi,
    #[doc = "< Selects padding mode:"]
    #[doc = "#MBEDTLS_RSA_PKCS_V15 for 1.5 padding and"]
    #[doc = "#MBEDTLS_RSA_PKCS_V21 for OAEP or PSS."]
    pub padding: crate::types::c_int,
    #[doc = "< Hash identifier of mbedtls_md_type_t type,"]
    #[doc = "as specified in md.h for use in the MGF"]
    #[doc = "mask generating function used in the"]
    #[doc = "EME-OAEP and EMSA-PSS encodings."]
    pub hash_id: crate::types::c_int,
}
#[test]
fn bindgen_test_layout_rsa_context() {
    assert_eq!(
        ::core::mem::size_of::<rsa_context>(),
        172usize,
        concat!("Size of: ", stringify!(rsa_context))
    );
    assert_eq!(
        ::core::mem::align_of::<rsa_context>(),
        4usize,
        concat!("Alignment of ", stringify!(rsa_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).ver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).N as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).E as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(E)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).D as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(D)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).P as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).Q as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(Q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).DP as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(DP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).DQ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(DQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).QP as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(QP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).RN as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(RN)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).RP as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(RP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).RQ as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(RQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).Vi as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(Vi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).Vf as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(Vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).padding as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).hash_id as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(hash_id)
        )
    );
}
impl Default for rsa_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes an RSA context."]
    #[doc = ""]
    #[doc = " \\note           Set padding to #MBEDTLS_RSA_PKCS_V21 for the RSAES-OAEP"]
    #[doc = "                 encryption scheme and the RSASSA-PSS signature scheme."]
    #[doc = ""]
    #[doc = " \\note           The \\p hash_id parameter is ignored when using"]
    #[doc = "                 #MBEDTLS_RSA_PKCS_V15 padding."]
    #[doc = ""]
    #[doc = " \\note           The choice of padding mode is strictly enforced for private key"]
    #[doc = "                 operations, since there might be security concerns in"]
    #[doc = "                 mixing padding modes. For public key operations it is"]
    #[doc = "                 a default value, which can be overridden by calling specific"]
    #[doc = "                 \\c rsa_rsaes_xxx or \\c rsa_rsassa_xxx functions."]
    #[doc = ""]
    #[doc = " \\note           The hash selected in \\p hash_id is always used for OEAP"]
    #[doc = "                 encryption. For PSS signatures, it is always used for"]
    #[doc = "                 making signatures, but can be overridden for verifying them."]
    #[doc = "                 If set to #MBEDTLS_MD_NONE, it is always overridden."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context to initialize. This must not be \\c NULL."]
    #[doc = " \\param padding  The padding mode to use. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PKCS_V15 or #MBEDTLS_RSA_PKCS_V21."]
    #[doc = " \\param hash_id  The hash identifier of ::mbedtls_md_type_t type, if"]
    #[doc = "                 \\p padding is #MBEDTLS_RSA_PKCS_V21. It is unused"]
    #[doc = "                 otherwise."]
    #[link_name = "\u{1}mbedtls_rsa_init"]
    pub fn rsa_init(
        ctx: *mut rsa_context,
        padding: crate::types::c_int,
        hash_id: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          This function imports a set of core parameters into an"]
    #[doc = "                 RSA context."]
    #[doc = ""]
    #[doc = " \\note           This function can be called multiple times for successive"]
    #[doc = "                 imports, if the parameters are not simultaneously present."]
    #[doc = ""]
    #[doc = "                 Any sequence of calls to this function should be followed"]
    #[doc = "                 by a call to mbedtls_rsa_complete(), which checks and"]
    #[doc = "                 completes the provided information to a ready-for-use"]
    #[doc = "                 public or private RSA key."]
    #[doc = ""]
    #[doc = " \\note           See mbedtls_rsa_complete() for more information on which"]
    #[doc = "                 parameters are necessary to set up a private or public"]
    #[doc = "                 RSA key."]
    #[doc = ""]
    #[doc = " \\note           The imported parameters are copied and need not be preserved"]
    #[doc = "                 for the lifetime of the RSA context being set up."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to store the parameters in."]
    #[doc = " \\param N        The RSA modulus. This may be \\c NULL."]
    #[doc = " \\param P        The first prime factor of \\p N. This may be \\c NULL."]
    #[doc = " \\param Q        The second prime factor of \\p N. This may be \\c NULL."]
    #[doc = " \\param D        The private exponent. This may be \\c NULL."]
    #[doc = " \\param E        The public exponent. This may be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A non-zero error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_import"]
    pub fn rsa_import(
        ctx: *mut rsa_context,
        N: *const mpi,
        P: *const mpi,
        Q: *const mpi,
        D: *const mpi,
        E: *const mpi,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports core RSA parameters, in raw big-endian"]
    #[doc = "                 binary format, into an RSA context."]
    #[doc = ""]
    #[doc = " \\note           This function can be called multiple times for successive"]
    #[doc = "                 imports, if the parameters are not simultaneously present."]
    #[doc = ""]
    #[doc = "                 Any sequence of calls to this function should be followed"]
    #[doc = "                 by a call to mbedtls_rsa_complete(), which checks and"]
    #[doc = "                 completes the provided information to a ready-for-use"]
    #[doc = "                 public or private RSA key."]
    #[doc = ""]
    #[doc = " \\note           See mbedtls_rsa_complete() for more information on which"]
    #[doc = "                 parameters are necessary to set up a private or public"]
    #[doc = "                 RSA key."]
    #[doc = ""]
    #[doc = " \\note           The imported parameters are copied and need not be preserved"]
    #[doc = "                 for the lifetime of the RSA context being set up."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to store the parameters in."]
    #[doc = " \\param N        The RSA modulus. This may be \\c NULL."]
    #[doc = " \\param N_len    The Byte length of \\p N; it is ignored if \\p N == NULL."]
    #[doc = " \\param P        The first prime factor of \\p N. This may be \\c NULL."]
    #[doc = " \\param P_len    The Byte length of \\p P; it ns ignored if \\p P == NULL."]
    #[doc = " \\param Q        The second prime factor of \\p N. This may be \\c NULL."]
    #[doc = " \\param Q_len    The Byte length of \\p Q; it is ignored if \\p Q == NULL."]
    #[doc = " \\param D        The private exponent. This may be \\c NULL."]
    #[doc = " \\param D_len    The Byte length of \\p D; it is ignored if \\p D == NULL."]
    #[doc = " \\param E        The public exponent. This may be \\c NULL."]
    #[doc = " \\param E_len    The Byte length of \\p E; it is ignored if \\p E == NULL."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A non-zero error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_import_raw"]
    pub fn rsa_import_raw(
        ctx: *mut rsa_context,
        N: *const crate::types::c_uchar,
        N_len: usize,
        P: *const crate::types::c_uchar,
        P_len: usize,
        Q: *const crate::types::c_uchar,
        Q_len: usize,
        D: *const crate::types::c_uchar,
        D_len: usize,
        E: *const crate::types::c_uchar,
        E_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function completes an RSA context from"]
    #[doc = "                 a set of imported core parameters."]
    #[doc = ""]
    #[doc = "                 To setup an RSA public key, precisely \\p N and \\p E"]
    #[doc = "                 must have been imported."]
    #[doc = ""]
    #[doc = "                 To setup an RSA private key, sufficient information must"]
    #[doc = "                 be present for the other parameters to be derivable."]
    #[doc = ""]
    #[doc = "                 The default implementation supports the following:"]
    #[doc = "                 <ul><li>Derive \\p P, \\p Q from \\p N, \\p D, \\p E.</li>"]
    #[doc = "                 <li>Derive \\p N, \\p D from \\p P, \\p Q, \\p E.</li></ul>"]
    #[doc = "                 Alternative implementations need not support these."]
    #[doc = ""]
    #[doc = "                 If this function runs successfully, it guarantees that"]
    #[doc = "                 the RSA context can be used for RSA operations without"]
    #[doc = "                 the risk of failure or crash."]
    #[doc = ""]
    #[doc = " \\warning        This function need not perform consistency checks"]
    #[doc = "                 for the imported parameters. In particular, parameters that"]
    #[doc = "                 are not needed by the implementation might be silently"]
    #[doc = "                 discarded and left unchecked. To check the consistency"]
    #[doc = "                 of the key material, see mbedtls_rsa_check_privkey()."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context holding imported parameters."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_RSA_BAD_INPUT_DATA if the attempted derivations"]
    #[doc = "                 failed."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_rsa_complete"]
    pub fn rsa_complete(ctx: *mut rsa_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports the core parameters of an RSA key."]
    #[doc = ""]
    #[doc = "                 If this function runs successfully, the non-NULL buffers"]
    #[doc = "                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully"]
    #[doc = "                 written, with additional unused space filled leading by"]
    #[doc = "                 zero Bytes."]
    #[doc = ""]
    #[doc = "                 Possible reasons for returning"]
    #[doc = "                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>"]
    #[doc = "                 <li>An alternative RSA implementation is in use, which"]
    #[doc = "                 stores the key externally, and either cannot or should"]
    #[doc = "                 not export it into RAM.</li>"]
    #[doc = "                 <li>A SW or HW implementation might not support a certain"]
    #[doc = "                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,"]
    #[doc = "                 and \\p E if the former are not part of the"]
    #[doc = "                 implementation.</li></ul>"]
    #[doc = ""]
    #[doc = "                 If the function fails due to an unsupported operation,"]
    #[doc = "                 the RSA context stays intact and remains usable."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = " \\param N        The MPI to hold the RSA modulus."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = " \\param P        The MPI to hold the first prime factor of \\p N."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = " \\param Q        The MPI to hold the second prime factor of \\p N."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = " \\param D        The MPI to hold the private exponent."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = " \\param E        The MPI to hold the public exponent."]
    #[doc = "                 This may be \\c NULL if this field need not be exported."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the"]
    #[doc = "                 requested parameters cannot be done due to missing"]
    #[doc = "                 functionality or because of security policies."]
    #[doc = " \\return         A non-zero return code on any other failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_rsa_export"]
    pub fn rsa_export(
        ctx: *const rsa_context,
        N: *mut mpi,
        P: *mut mpi,
        Q: *mut mpi,
        D: *mut mpi,
        E: *mut mpi,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports core parameters of an RSA key"]
    #[doc = "                 in raw big-endian binary format."]
    #[doc = ""]
    #[doc = "                 If this function runs successfully, the non-NULL buffers"]
    #[doc = "                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully"]
    #[doc = "                 written, with additional unused space filled leading by"]
    #[doc = "                 zero Bytes."]
    #[doc = ""]
    #[doc = "                 Possible reasons for returning"]
    #[doc = "                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>"]
    #[doc = "                 <li>An alternative RSA implementation is in use, which"]
    #[doc = "                 stores the key externally, and either cannot or should"]
    #[doc = "                 not export it into RAM.</li>"]
    #[doc = "                 <li>A SW or HW implementation might not support a certain"]
    #[doc = "                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,"]
    #[doc = "                 and \\p E if the former are not part of the"]
    #[doc = "                 implementation.</li></ul>"]
    #[doc = "                 If the function fails due to an unsupported operation,"]
    #[doc = "                 the RSA context stays intact and remains usable."]
    #[doc = ""]
    #[doc = " \\note           The length parameters are ignored if the corresponding"]
    #[doc = "                 buffer pointers are NULL."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = " \\param N        The Byte array to store the RSA modulus,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param N_len    The size of the buffer for the modulus."]
    #[doc = " \\param P        The Byte array to hold the first prime factor of \\p N,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param P_len    The size of the buffer for the first prime factor."]
    #[doc = " \\param Q        The Byte array to hold the second prime factor of \\p N,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param Q_len    The size of the buffer for the second prime factor."]
    #[doc = " \\param D        The Byte array to hold the private exponent,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param D_len    The size of the buffer for the private exponent."]
    #[doc = " \\param E        The Byte array to hold the public exponent,"]
    #[doc = "                 or \\c NULL if this field need not be exported."]
    #[doc = " \\param E_len    The size of the buffer for the public exponent."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the"]
    #[doc = "                 requested parameters cannot be done due to missing"]
    #[doc = "                 functionality or because of security policies."]
    #[doc = " \\return         A non-zero return code on any other failure."]
    #[link_name = "\u{1}mbedtls_rsa_export_raw"]
    pub fn rsa_export_raw(
        ctx: *const rsa_context,
        N: *mut crate::types::c_uchar,
        N_len: usize,
        P: *mut crate::types::c_uchar,
        P_len: usize,
        Q: *mut crate::types::c_uchar,
        Q_len: usize,
        D: *mut crate::types::c_uchar,
        D_len: usize,
        E: *mut crate::types::c_uchar,
        E_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports CRT parameters of a private RSA key."]
    #[doc = ""]
    #[doc = " \\note           Alternative RSA implementations not using CRT-parameters"]
    #[doc = "                 internally can implement this function based on"]
    #[doc = "                 mbedtls_rsa_deduce_opt()."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = " \\param DP       The MPI to hold \\c D modulo `P-1`,"]
    #[doc = "                 or \\c NULL if it need not be exported."]
    #[doc = " \\param DQ       The MPI to hold \\c D modulo `Q-1`,"]
    #[doc = "                 or \\c NULL if it need not be exported."]
    #[doc = " \\param QP       The MPI to hold modular inverse of \\c Q modulo \\c P,"]
    #[doc = "                 or \\c NULL if it need not be exported."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A non-zero error code on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_rsa_export_crt"]
    pub fn rsa_export_crt(
        ctx: *const rsa_context,
        DP: *mut mpi,
        DQ: *mut mpi,
        QP: *mut mpi,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets padding for an already initialized RSA"]
    #[doc = "                 context. See mbedtls_rsa_init() for details."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to be configured."]
    #[doc = " \\param padding  The padding mode to use. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PKCS_V15 or #MBEDTLS_RSA_PKCS_V21."]
    #[doc = " \\param hash_id  The #MBEDTLS_RSA_PKCS_V21 hash identifier."]
    #[link_name = "\u{1}mbedtls_rsa_set_padding"]
    pub fn rsa_set_padding(
        ctx: *mut rsa_context,
        padding: crate::types::c_int,
        hash_id: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          This function retrieves the length of RSA modulus in Bytes."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context."]
    #[doc = ""]
    #[doc = " \\return         The length of the RSA modulus in Bytes."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_rsa_get_len"]
    pub fn rsa_get_len(ctx: *const rsa_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          This function generates an RSA keypair."]
    #[doc = ""]
    #[doc = " \\note           mbedtls_rsa_init() must be called before this function,"]
    #[doc = "                 to set up the RSA context."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context used to hold the key."]
    #[doc = " \\param f_rng    The RNG function to be used for key generation."]
    #[doc = "                 This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng."]
    #[doc = "                 This may be \\c NULL if \\p f_rng doesn't need a context."]
    #[doc = " \\param nbits    The size of the public key in bits."]
    #[doc = " \\param exponent The public exponent to use. For example, \\c 65537."]
    #[doc = "                 This must be odd and greater than \\c 1."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_gen_key"]
    pub fn rsa_gen_key(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        nbits: crate::types::c_uint,
        exponent: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks if a context contains at least an RSA"]
    #[doc = "                 public key."]
    #[doc = ""]
    #[doc = "                 If the function runs successfully, it is guaranteed that"]
    #[doc = "                 enough information is present to perform an RSA public key"]
    #[doc = "                 operation using mbedtls_rsa_public()."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to check."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_rsa_check_pubkey"]
    pub fn rsa_check_pubkey(ctx: *const rsa_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function checks if a context contains an RSA private key"]
    #[doc = "             and perform basic consistency checks."]
    #[doc = ""]
    #[doc = " \\note       The consistency checks performed by this function not only"]
    #[doc = "             ensure that mbedtls_rsa_private() can be called successfully"]
    #[doc = "             on the given context, but that the various parameters are"]
    #[doc = "             mutually consistent with high probability, in the sense that"]
    #[doc = "             mbedtls_rsa_public() and mbedtls_rsa_private() are inverses."]
    #[doc = ""]
    #[doc = " \\warning    This function should catch accidental misconfigurations"]
    #[doc = "             like swapping of parameters, but it cannot establish full"]
    #[doc = "             trust in neither the quality nor the consistency of the key"]
    #[doc = "             material that was used to setup the given RSA context:"]
    #[doc = "             <ul><li>Consistency: Imported parameters that are irrelevant"]
    #[doc = "             for the implementation might be silently dropped. If dropped,"]
    #[doc = "             the current function does not have access to them,"]
    #[doc = "             and therefore cannot check them. See mbedtls_rsa_complete()."]
    #[doc = "             If you want to check the consistency of the entire"]
    #[doc = "             content of an PKCS1-encoded RSA private key, for example, you"]
    #[doc = "             should use mbedtls_rsa_validate_params() before setting"]
    #[doc = "             up the RSA context."]
    #[doc = "             Additionally, if the implementation performs empirical checks,"]
    #[doc = "             these checks substantiate but do not guarantee consistency.</li>"]
    #[doc = "             <li>Quality: This function is not expected to perform"]
    #[doc = "             extended quality assessments like checking that the prime"]
    #[doc = "             factors are safe. Additionally, it is the responsibility of the"]
    #[doc = "             user to ensure the trustworthiness of the source of his RSA"]
    #[doc = "             parameters, which goes beyond what is effectively checkable"]
    #[doc = "             by the library.</li></ul>"]
    #[doc = ""]
    #[doc = " \\param ctx  The initialized RSA context to check."]
    #[doc = ""]
    #[doc = " \\return     \\c 0 on success."]
    #[doc = " \\return     An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_check_privkey"]
    pub fn rsa_check_privkey(ctx: *const rsa_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks a public-private RSA key pair."]
    #[doc = ""]
    #[doc = "                 It checks each of the contexts, and makes sure they match."]
    #[doc = ""]
    #[doc = " \\param pub      The initialized RSA context holding the public key."]
    #[doc = " \\param prv      The initialized RSA context holding the private key."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_check_pub_priv"]
    pub fn rsa_check_pub_priv(
        pub_: *const rsa_context,
        prv: *const rsa_context,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA public key operation."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param input    The input buffer. This must be a readable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = " \\param output   The output buffer. This must be a writable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\note           This function does not handle message padding."]
    #[doc = ""]
    #[doc = " \\note           Make sure to set \\p input[0] = 0 or ensure that"]
    #[doc = "                 input is smaller than \\p N."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_public"]
    pub fn rsa_public(
        ctx: *mut rsa_context,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA private key operation."]
    #[doc = ""]
    #[doc = " \\note           Blinding is used if and only if a PRNG is provided."]
    #[doc = ""]
    #[doc = " \\note           If blinding is used, both the base of exponentation"]
    #[doc = "                 and the exponent are blinded, providing protection"]
    #[doc = "                 against some side-channel attacks."]
    #[doc = ""]
    #[doc = " \\warning        It is deprecated and a security risk to not provide"]
    #[doc = "                 a PRNG here and thereby prevent the use of blinding."]
    #[doc = "                 Future versions of the library may enforce the presence"]
    #[doc = "                 of a PRNG."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function, used for blinding. It is discouraged"]
    #[doc = "                 and deprecated to pass \\c NULL here, in which case"]
    #[doc = "                 blinding will be omitted."]
    #[doc = " \\param p_rng    The RNG context to pass to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng is \\c NULL or if \\p f_rng doesn't need a context."]
    #[doc = " \\param input    The input buffer. This must be a readable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = " \\param output   The output buffer. This must be a writable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_rsa_private"]
    pub fn rsa_private(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function adds the message padding, then performs an RSA"]
    #[doc = "                 operation."]
    #[doc = ""]
    #[doc = "                 It is the generic wrapper for performing a PKCS#1 encryption"]
    #[doc = "                 operation using the \\p mode from the context."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG to use. It is mandatory for PKCS#1 v2.1 padding"]
    #[doc = "                 encoding, and for PKCS#1 v1.5 padding encoding when used"]
    #[doc = "                 with \\p mode set to #MBEDTLS_RSA_PUBLIC. For PKCS#1 v1.5"]
    #[doc = "                 padding encoding and \\p mode set to #MBEDTLS_RSA_PRIVATE,"]
    #[doc = "                 it is used for blinding and should be provided in this"]
    #[doc = "                 case; see mbedtls_rsa_private() for more."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. May be"]
    #[doc = "                 \\c NULL if \\p f_rng is \\c NULL or if \\p f_rng doesn't"]
    #[doc = "                 need a context argument."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE (deprecated)."]
    #[doc = " \\param ilen     The length of the plaintext in Bytes."]
    #[doc = " \\param input    The input data to encrypt. This must be a readable"]
    #[doc = "                 buffer of size \\p ilen Bytes. It may be \\c NULL if"]
    #[doc = "                 `ilen == 0`."]
    #[doc = " \\param output   The output buffer. This must be a writable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_pkcs1_encrypt"]
    pub fn rsa_pkcs1_encrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        ilen: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 encryption operation"]
    #[doc = "                 (RSAES-PKCS1-v1_5-ENCRYPT)."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function to use. It is needed for padding generation"]
    #[doc = "                 if \\p mode is #MBEDTLS_RSA_PUBLIC. If \\p mode is"]
    #[doc = "                 #MBEDTLS_RSA_PRIVATE (discouraged), it is used for"]
    #[doc = "                 blinding and should be provided; see mbedtls_rsa_private()."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                 be \\c NULL if \\p f_rng is \\c NULL or if \\p f_rng"]
    #[doc = "                 doesn't need a context argument."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE (deprecated)."]
    #[doc = " \\param ilen     The length of the plaintext in Bytes."]
    #[doc = " \\param input    The input data to encrypt. This must be a readable"]
    #[doc = "                 buffer of size \\p ilen Bytes. It may be \\c NULL if"]
    #[doc = "                 `ilen == 0`."]
    #[doc = " \\param output   The output buffer. This must be a writable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_rsaes_pkcs1_v15_encrypt"]
    pub fn rsa_rsaes_pkcs1_v15_encrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        ilen: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP encryption"]
    #[doc = "                   operation (RSAES-OAEP-ENCRYPT)."]
    #[doc = ""]
    #[doc = " \\note             The output buffer must be as large as the size"]
    #[doc = "                   of ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\deprecated       It is deprecated and discouraged to call this function"]
    #[doc = "                   in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                   are likely to remove the \\p mode argument and have it"]
    #[doc = "                   implicitly set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note             Alternative implementations of RSA need not support"]
    #[doc = "                   mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                   return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx        The initnialized RSA context to use."]
    #[doc = " \\param f_rng      The RNG function to use. This is needed for padding"]
    #[doc = "                   generation and must be provided."]
    #[doc = " \\param p_rng      The RNG context to be passed to \\p f_rng. This may"]
    #[doc = "                   be \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = " \\param mode       The mode of operation. This must be either"]
    #[doc = "                   #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE (deprecated)."]
    #[doc = " \\param label      The buffer holding the custom label to use."]
    #[doc = "                   This must be a readable buffer of length \\p label_len"]
    #[doc = "                   Bytes. It may be \\c NULL if \\p label_len is \\c 0."]
    #[doc = " \\param label_len  The length of the label in Bytes."]
    #[doc = " \\param ilen       The length of the plaintext buffer \\p input in Bytes."]
    #[doc = " \\param input      The input data to encrypt. This must be a readable"]
    #[doc = "                   buffer of size \\p ilen Bytes. It may be \\c NULL if"]
    #[doc = "                   `ilen == 0`."]
    #[doc = " \\param output     The output buffer. This must be a writable buffer"]
    #[doc = "                   of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                   for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return           \\c 0 on success."]
    #[doc = " \\return           An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_rsaes_oaep_encrypt"]
    pub fn rsa_rsaes_oaep_encrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        label: *const crate::types::c_uchar,
        label_len: usize,
        ilen: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA operation, then removes the"]
    #[doc = "                 message padding."]
    #[doc = ""]
    #[doc = "                 It is the generic wrapper for performing a PKCS#1 decryption"]
    #[doc = "                 operation using the \\p mode from the context."]
    #[doc = ""]
    #[doc = " \\note           The output buffer length \\c output_max_len should be"]
    #[doc = "                 as large as the size \\p ctx->len of \\p ctx->N (for example,"]
    #[doc = "                 128 Bytes if RSA-1024 is used) to be able to hold an"]
    #[doc = "                 arbitrary decrypted message. If it is not large enough to"]
    #[doc = "                 hold the decryption of the particular ciphertext provided,"]
    #[doc = "                 the function returns \\c MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function. If \\p mode is #MBEDTLS_RSA_PRIVATE,"]
    #[doc = "                 this is used for blinding and should be provided; see"]
    #[doc = "                 mbedtls_rsa_private() for more. If \\p mode is"]
    #[doc = "                 #MBEDTLS_RSA_PUBLIC, it is ignored."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng is \\c NULL or doesn't need a context."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PRIVATE or #MBEDTLS_RSA_PUBLIC (deprecated)."]
    #[doc = " \\param olen     The address at which to store the length of"]
    #[doc = "                 the plaintext. This must not be \\c NULL."]
    #[doc = " \\param input    The ciphertext buffer. This must be a readable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = " \\param output   The buffer used to hold the plaintext. This must"]
    #[doc = "                 be a writable buffer of length \\p output_max_len Bytes."]
    #[doc = " \\param output_max_len The length in Bytes of the output buffer \\p output."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_pkcs1_decrypt"]
    pub fn rsa_pkcs1_decrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        olen: *mut usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        output_max_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 decryption"]
    #[doc = "                 operation (RSAES-PKCS1-v1_5-DECRYPT)."]
    #[doc = ""]
    #[doc = " \\note           The output buffer length \\c output_max_len should be"]
    #[doc = "                 as large as the size \\p ctx->len of \\p ctx->N, for example,"]
    #[doc = "                 128 Bytes if RSA-1024 is used, to be able to hold an"]
    #[doc = "                 arbitrary decrypted message. If it is not large enough to"]
    #[doc = "                 hold the decryption of the particular ciphertext provided,"]
    #[doc = "                 the function returns #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function. If \\p mode is #MBEDTLS_RSA_PRIVATE,"]
    #[doc = "                 this is used for blinding and should be provided; see"]
    #[doc = "                 mbedtls_rsa_private() for more. If \\p mode is"]
    #[doc = "                 #MBEDTLS_RSA_PUBLIC, it is ignored."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng is \\c NULL or doesn't need a context."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PRIVATE or #MBEDTLS_RSA_PUBLIC (deprecated)."]
    #[doc = " \\param olen     The address at which to store the length of"]
    #[doc = "                 the plaintext. This must not be \\c NULL."]
    #[doc = " \\param input    The ciphertext buffer. This must be a readable buffer"]
    #[doc = "                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = " \\param output   The buffer used to hold the plaintext. This must"]
    #[doc = "                 be a writable buffer of length \\p output_max_len Bytes."]
    #[doc = " \\param output_max_len The length in Bytes of the output buffer \\p output."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_rsa_rsaes_pkcs1_v15_decrypt"]
    pub fn rsa_rsaes_pkcs1_v15_decrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        olen: *mut usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        output_max_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP decryption"]
    #[doc = "                   operation (RSAES-OAEP-DECRYPT)."]
    #[doc = ""]
    #[doc = " \\note             The output buffer length \\c output_max_len should be"]
    #[doc = "                   as large as the size \\p ctx->len of \\p ctx->N, for"]
    #[doc = "                   example, 128 Bytes if RSA-1024 is used, to be able to"]
    #[doc = "                   hold an arbitrary decrypted message. If it is not"]
    #[doc = "                   large enough to hold the decryption of the particular"]
    #[doc = "                   ciphertext provided, the function returns"]
    #[doc = "                   #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE."]
    #[doc = ""]
    #[doc = " \\deprecated       It is deprecated and discouraged to call this function"]
    #[doc = "                   in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                   are likely to remove the \\p mode argument and have it"]
    #[doc = "                   implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note             Alternative implementations of RSA need not support"]
    #[doc = "                   mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                   return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx        The initialized RSA context to use."]
    #[doc = " \\param f_rng      The RNG function. If \\p mode is #MBEDTLS_RSA_PRIVATE,"]
    #[doc = "                   this is used for blinding and should be provided; see"]
    #[doc = "                   mbedtls_rsa_private() for more. If \\p mode is"]
    #[doc = "                   #MBEDTLS_RSA_PUBLIC, it is ignored."]
    #[doc = " \\param p_rng      The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                   \\c NULL if \\p f_rng is \\c NULL or doesn't need a context."]
    #[doc = " \\param mode       The mode of operation. This must be either"]
    #[doc = "                   #MBEDTLS_RSA_PRIVATE or #MBEDTLS_RSA_PUBLIC (deprecated)."]
    #[doc = " \\param label      The buffer holding the custom label to use."]
    #[doc = "                   This must be a readable buffer of length \\p label_len"]
    #[doc = "                   Bytes. It may be \\c NULL if \\p label_len is \\c 0."]
    #[doc = " \\param label_len  The length of the label in Bytes."]
    #[doc = " \\param olen       The address at which to store the length of"]
    #[doc = "                   the plaintext. This must not be \\c NULL."]
    #[doc = " \\param input      The ciphertext buffer. This must be a readable buffer"]
    #[doc = "                   of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                   for an 2048-bit RSA modulus."]
    #[doc = " \\param output     The buffer used to hold the plaintext. This must"]
    #[doc = "                   be a writable buffer of length \\p output_max_len Bytes."]
    #[doc = " \\param output_max_len The length in Bytes of the output buffer \\p output."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_rsaes_oaep_decrypt"]
    pub fn rsa_rsaes_oaep_decrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        label: *const crate::types::c_uchar,
        label_len: usize,
        olen: *mut usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        output_max_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a private RSA operation to sign"]
    #[doc = "                 a message digest using PKCS#1."]
    #[doc = ""]
    #[doc = "                 It is the generic wrapper for performing a PKCS#1"]
    #[doc = "                 signature using the \\p mode from the context."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           For PKCS#1 v2.1 encoding, see comments on"]
    #[doc = "                 mbedtls_rsa_rsassa_pss_sign() for details on"]
    #[doc = "                 \\p md_alg and \\p hash_id."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function to use. If the padding mode is PKCS#1 v2.1,"]
    #[doc = "                 this must be provided. If the padding mode is PKCS#1 v1.5 and"]
    #[doc = "                 \\p mode is #MBEDTLS_RSA_PRIVATE, it is used for blinding"]
    #[doc = "                 and should be provided; see mbedtls_rsa_private() for more"]
    #[doc = "                 more. It is ignored otherwise."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng is \\c NULL or doesn't need a context argument."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PRIVATE or #MBEDTLS_RSA_PUBLIC (deprecated)."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest."]
    #[doc = "                 Ths is only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 If \\p md_alg is #MBEDTLS_MD_NONE, this must be a readable"]
    #[doc = "                 buffer of length \\p hashlen Bytes. If \\p md_alg is not"]
    #[doc = "                 #MBEDTLS_MD_NONE, it must be a readable buffer of length"]
    #[doc = "                 the size of the hash corresponding to \\p md_alg."]
    #[doc = " \\param sig      The buffer to hold the signature. This must be a writable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus. A buffer length of"]
    #[doc = "                 #MBEDTLS_MPI_MAX_SIZE is always safe."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_pkcs1_sign"]
    pub fn rsa_pkcs1_sign(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        md_alg: md_type_t,
        hashlen: crate::types::c_uint,
        hash: *const crate::types::c_uchar,
        sig: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 signature"]
    #[doc = "                 operation (RSASSA-PKCS1-v1_5-SIGN)."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function. If \\p mode is #MBEDTLS_RSA_PRIVATE,"]
    #[doc = "                 this is used for blinding and should be provided; see"]
    #[doc = "                 mbedtls_rsa_private() for more. If \\p mode is"]
    #[doc = "                 #MBEDTLS_RSA_PUBLIC, it is ignored."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng is \\c NULL or doesn't need a context argument."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PRIVATE or #MBEDTLS_RSA_PUBLIC (deprecated)."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest."]
    #[doc = "                 Ths is only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 If \\p md_alg is #MBEDTLS_MD_NONE, this must be a readable"]
    #[doc = "                 buffer of length \\p hashlen Bytes. If \\p md_alg is not"]
    #[doc = "                 #MBEDTLS_MD_NONE, it must be a readable buffer of length"]
    #[doc = "                 the size of the hash corresponding to \\p md_alg."]
    #[doc = " \\param sig      The buffer to hold the signature. This must be a writable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus. A buffer length of"]
    #[doc = "                 #MBEDTLS_MPI_MAX_SIZE is always safe."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pkcs1_v15_sign"]
    pub fn rsa_rsassa_pkcs1_v15_sign(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        md_alg: md_type_t,
        hashlen: crate::types::c_uint,
        hash: *const crate::types::c_uchar,
        sig: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS signature"]
    #[doc = "                 operation (RSASSA-PSS-SIGN)."]
    #[doc = ""]
    #[doc = " \\note           The \\p hash_id in the RSA context is the one used for the"]
    #[doc = "                 encoding. \\p md_alg in the function call is the type of hash"]
    #[doc = "                 that is encoded. According to <em>RFC-3447: Public-Key"]
    #[doc = "                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography"]
    #[doc = "                 Specifications</em> it is advised to keep both hashes the"]
    #[doc = "                 same."]
    #[doc = ""]
    #[doc = " \\note           This function always uses the maximum possible salt size,"]
    #[doc = "                 up to the length of the payload hash. This choice of salt"]
    #[doc = "                 size complies with FIPS 186-4 §5.5 (e) and RFC 8017 (PKCS#1"]
    #[doc = "                 v2.2) §9.1.1 step 3. Furthermore this function enforces a"]
    #[doc = "                 minimum salt size which is the hash size minus 2 bytes. If"]
    #[doc = "                 this minimum size is too large given the key size (the salt"]
    #[doc = "                 size, plus the hash size, plus 2 bytes must be no more than"]
    #[doc = "                 the key size in bytes), this function returns"]
    #[doc = "                 #MBEDTLS_ERR_RSA_BAD_INPUT_DATA."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PUBLIC mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PRIVATE."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PUBLIC and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA context to use."]
    #[doc = " \\param f_rng    The RNG function. It must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng doesn't need a context argument."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PRIVATE or #MBEDTLS_RSA_PUBLIC (deprecated)."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest."]
    #[doc = "                 Ths is only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 If \\p md_alg is #MBEDTLS_MD_NONE, this must be a readable"]
    #[doc = "                 buffer of length \\p hashlen Bytes. If \\p md_alg is not"]
    #[doc = "                 #MBEDTLS_MD_NONE, it must be a readable buffer of length"]
    #[doc = "                 the size of the hash corresponding to \\p md_alg."]
    #[doc = " \\param sig      The buffer to hold the signature. This must be a writable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus. A buffer length of"]
    #[doc = "                 #MBEDTLS_MPI_MAX_SIZE is always safe."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the signing operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pss_sign"]
    pub fn rsa_rsassa_pss_sign(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        md_alg: md_type_t,
        hashlen: crate::types::c_uint,
        hash: *const crate::types::c_uchar,
        sig: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a public RSA operation and checks"]
    #[doc = "                 the message digest."]
    #[doc = ""]
    #[doc = "                 This is the generic wrapper for performing a PKCS#1"]
    #[doc = "                 verification using the mode from the context."]
    #[doc = ""]
    #[doc = " \\note           For PKCS#1 v2.1 encoding, see comments on"]
    #[doc = "                 mbedtls_rsa_rsassa_pss_verify() about \\p md_alg and"]
    #[doc = "                 \\p hash_id."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA public key context to use."]
    #[doc = " \\param f_rng    The RNG function to use. If \\p mode is #MBEDTLS_RSA_PRIVATE,"]
    #[doc = "                 this is used for blinding and should be provided; see"]
    #[doc = "                 mbedtls_rsa_private() for more. Otherwise, it is ignored."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng is \\c NULL or doesn't need a context."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE (deprecated)."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest."]
    #[doc = "                 This is only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 If \\p md_alg is #MBEDTLS_MD_NONE, this must be a readable"]
    #[doc = "                 buffer of length \\p hashlen Bytes. If \\p md_alg is not"]
    #[doc = "                 #MBEDTLS_MD_NONE, it must be a readable buffer of length"]
    #[doc = "                 the size of the hash corresponding to \\p md_alg."]
    #[doc = " \\param sig      The buffer holding the signature. This must be a readable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_pkcs1_verify"]
    pub fn rsa_pkcs1_verify(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        md_alg: md_type_t,
        hashlen: crate::types::c_uint,
        hash: *const crate::types::c_uchar,
        sig: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 verification"]
    #[doc = "                 operation (RSASSA-PKCS1-v1_5-VERIFY)."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA public key context to use."]
    #[doc = " \\param f_rng    The RNG function to use. If \\p mode is #MBEDTLS_RSA_PRIVATE,"]
    #[doc = "                 this is used for blinding and should be provided; see"]
    #[doc = "                 mbedtls_rsa_private() for more. Otherwise, it is ignored."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng is \\c NULL or doesn't need a context."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE (deprecated)."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest."]
    #[doc = "                 This is only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 If \\p md_alg is #MBEDTLS_MD_NONE, this must be a readable"]
    #[doc = "                 buffer of length \\p hashlen Bytes. If \\p md_alg is not"]
    #[doc = "                 #MBEDTLS_MD_NONE, it must be a readable buffer of length"]
    #[doc = "                 the size of the hash corresponding to \\p md_alg."]
    #[doc = " \\param sig      The buffer holding the signature. This must be a readable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pkcs1_v15_verify"]
    pub fn rsa_rsassa_pkcs1_v15_verify(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        md_alg: md_type_t,
        hashlen: crate::types::c_uint,
        hash: *const crate::types::c_uchar,
        sig: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification"]
    #[doc = "                 operation (RSASSA-PSS-VERIFY)."]
    #[doc = ""]
    #[doc = "                 The hash function for the MGF mask generating function"]
    #[doc = "                 is that specified in the RSA context."]
    #[doc = ""]
    #[doc = " \\note           The \\p hash_id in the RSA context is the one used for the"]
    #[doc = "                 verification. \\p md_alg in the function call is the type of"]
    #[doc = "                 hash that is verified. According to <em>RFC-3447: Public-Key"]
    #[doc = "                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography"]
    #[doc = "                 Specifications</em> it is advised to keep both hashes the"]
    #[doc = "                 same. If \\p hash_id in the RSA context is unset,"]
    #[doc = "                 the \\p md_alg from the function call is used."]
    #[doc = ""]
    #[doc = " \\deprecated     It is deprecated and discouraged to call this function"]
    #[doc = "                 in #MBEDTLS_RSA_PRIVATE mode. Future versions of the library"]
    #[doc = "                 are likely to remove the \\p mode argument and have it"]
    #[doc = "                 implicitly set to #MBEDTLS_RSA_PUBLIC."]
    #[doc = ""]
    #[doc = " \\note           Alternative implementations of RSA need not support"]
    #[doc = "                 mode being set to #MBEDTLS_RSA_PRIVATE and might instead"]
    #[doc = "                 return #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA public key context to use."]
    #[doc = " \\param f_rng    The RNG function to use. If \\p mode is #MBEDTLS_RSA_PRIVATE,"]
    #[doc = "                 this is used for blinding and should be provided; see"]
    #[doc = "                 mbedtls_rsa_private() for more. Otherwise, it is ignored."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng is \\c NULL or doesn't need a context."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE (deprecated)."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest."]
    #[doc = "                 This is only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 If \\p md_alg is #MBEDTLS_MD_NONE, this must be a readable"]
    #[doc = "                 buffer of length \\p hashlen Bytes. If \\p md_alg is not"]
    #[doc = "                 #MBEDTLS_MD_NONE, it must be a readable buffer of length"]
    #[doc = "                 the size of the hash corresponding to \\p md_alg."]
    #[doc = " \\param sig      The buffer holding the signature. This must be a readable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pss_verify"]
    pub fn rsa_rsassa_pss_verify(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        md_alg: md_type_t,
        hashlen: crate::types::c_uint,
        hash: *const crate::types::c_uchar,
        sig: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification"]
    #[doc = "                 operation (RSASSA-PSS-VERIFY)."]
    #[doc = ""]
    #[doc = "                 The hash function for the MGF mask generating function"]
    #[doc = "                 is that specified in \\p mgf1_hash_id."]
    #[doc = ""]
    #[doc = " \\note           The \\p sig buffer must be as large as the size"]
    #[doc = "                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used."]
    #[doc = ""]
    #[doc = " \\note           The \\p hash_id in the RSA context is ignored."]
    #[doc = ""]
    #[doc = " \\param ctx      The initialized RSA public key context to use."]
    #[doc = " \\param f_rng    The RNG function to use. If \\p mode is #MBEDTLS_RSA_PRIVATE,"]
    #[doc = "                 this is used for blinding and should be provided; see"]
    #[doc = "                 mbedtls_rsa_private() for more. Otherwise, it is ignored."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng is \\c NULL or doesn't need a context."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_RSA_PUBLIC or #MBEDTLS_RSA_PRIVATE."]
    #[doc = " \\param md_alg   The message-digest algorithm used to hash the original data."]
    #[doc = "                 Use #MBEDTLS_MD_NONE for signing raw data."]
    #[doc = " \\param hashlen  The length of the message digest."]
    #[doc = "                 This is only used if \\p md_alg is #MBEDTLS_MD_NONE."]
    #[doc = " \\param hash     The buffer holding the message digest or raw data."]
    #[doc = "                 If \\p md_alg is #MBEDTLS_MD_NONE, this must be a readable"]
    #[doc = "                 buffer of length \\p hashlen Bytes. If \\p md_alg is not"]
    #[doc = "                 #MBEDTLS_MD_NONE, it must be a readable buffer of length"]
    #[doc = "                 the size of the hash corresponding to \\p md_alg."]
    #[doc = " \\param mgf1_hash_id      The message digest used for mask generation."]
    #[doc = " \\param expected_salt_len The length of the salt used in padding. Use"]
    #[doc = "                          #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length."]
    #[doc = " \\param sig      The buffer holding the signature. This must be a readable"]
    #[doc = "                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes"]
    #[doc = "                 for an 2048-bit RSA modulus."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the verify operation was successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_rsa_rsassa_pss_verify_ext"]
    pub fn rsa_rsassa_pss_verify_ext(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        md_alg: md_type_t,
        hashlen: crate::types::c_uint,
        hash: *const crate::types::c_uchar,
        mgf1_hash_id: md_type_t,
        expected_salt_len: crate::types::c_int,
        sig: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function copies the components of an RSA context."]
    #[doc = ""]
    #[doc = " \\param dst      The destination context. This must be initialized."]
    #[doc = " \\param src      The source context. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory allocation failure."]
    #[link_name = "\u{1}mbedtls_rsa_copy"]
    pub fn rsa_copy(dst: *mut rsa_context, src: *const rsa_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function frees the components of an RSA key."]
    #[doc = ""]
    #[doc = " \\param ctx      The RSA context to free. May be \\c NULL, in which case"]
    #[doc = "                 this function is a no-op. If it is not \\c NULL, it must"]
    #[doc = "                 point to an initialized RSA context."]
    #[link_name = "\u{1}mbedtls_rsa_free"]
    pub fn rsa_free(ctx: *mut rsa_context);
}
extern "C" {
    #[doc = " \\brief          The RSA checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_rsa_self_test"]
    pub fn rsa_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief           The ECDSA context structure."]
#[doc = ""]
#[doc = " \\warning         Performing multiple operations concurrently on the same"]
#[doc = "                  ECDSA context is not supported; objects of this type"]
#[doc = "                  should not be shared between multiple threads."]
pub type ecdsa_context = ecp_keypair;
pub type ecdsa_restart_ctx = crate::types::c_void;
extern "C" {
    #[doc = " \\brief          This function checks whether a given group can be used"]
    #[doc = "                 for ECDSA."]
    #[doc = ""]
    #[doc = " \\param gid      The ECP group ID to check."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if the group can be used, \\c 0 otherwise"]
    #[link_name = "\u{1}mbedtls_ecdsa_can_do"]
    pub fn ecdsa_can_do(gid: ecp_group_id) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a"]
    #[doc = "                  previously-hashed message."]
    #[doc = ""]
    #[doc = " \\note            The deterministic version implemented in"]
    #[doc = "                  mbedtls_ecdsa_sign_det() is usually preferred."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated"]
    #[doc = "                  as defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The context for the elliptic curve to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param r         The MPI context in which to store the first part"]
    #[doc = "                  the signature. This must be initialized."]
    #[doc = " \\param s         The MPI context in which to store the second part"]
    #[doc = "                  the signature. This must be initialized."]
    #[doc = " \\param d         The private signing key. This must be initialized."]
    #[doc = " \\param buf       The content to be signed. This is usually the hash of"]
    #[doc = "                  the original data to be signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                  \\p blen is zero."]
    #[doc = " \\param blen      The length of \\p buf in Bytes."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX"]
    #[doc = "                  or \\c MBEDTLS_MPI_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdsa_sign"]
    pub fn ecdsa_sign(
        grp: *mut ecp_group,
        r: *mut mpi,
        s: *mut mpi,
        d: *const mpi,
        buf: *const crate::types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a"]
    #[doc = "                  previously-hashed message, deterministic version."]
    #[doc = ""]
    #[doc = "                  For more information, see <em>RFC-6979: Deterministic"]
    #[doc = "                  Usage of the Digital Signature Algorithm (DSA) and Elliptic"]
    #[doc = "                  Curve Digital Signature Algorithm (ECDSA)</em>."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\warning         Since the output of the internal RNG is always the same for"]
    #[doc = "                  the same key and message, this limits the efficiency of"]
    #[doc = "                  blinding and leaks information through side channels. For"]
    #[doc = "                  secure behavior use mbedtls_ecdsa_sign_det_ext() instead."]
    #[doc = ""]
    #[doc = "                  (Optimally the blinding is a random value that is different"]
    #[doc = "                  on every execution. In this case the blinding is still"]
    #[doc = "                  random from the attackers perspective, but is the same on"]
    #[doc = "                  each execution. This means that this blinding does not"]
    #[doc = "                  prevent attackers from recovering secrets by combining"]
    #[doc = "                  several measurement traces, but may prevent some attacks"]
    #[doc = "                  that exploit relationships between secret data.)"]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The context for the elliptic curve to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param r         The MPI context in which to store the first part"]
    #[doc = "                  the signature. This must be initialized."]
    #[doc = " \\param s         The MPI context in which to store the second part"]
    #[doc = "                  the signature. This must be initialized."]
    #[doc = " \\param d         The private signing key. This must be initialized"]
    #[doc = "                  and setup, for example through mbedtls_ecp_gen_privkey()."]
    #[doc = " \\param buf       The hashed content to be signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                  \\p blen is zero."]
    #[doc = " \\param blen      The length of \\p buf in Bytes."]
    #[doc = " \\param md_alg    The hash algorithm used to hash the original data."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX"]
    #[doc = "                  error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdsa_sign_det"]
    pub fn ecdsa_sign_det(
        grp: *mut ecp_group,
        r: *mut mpi,
        s: *mut mpi,
        d: *const mpi,
        buf: *const crate::types::c_uchar,
        blen: usize,
        md_alg: md_type_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a"]
    #[doc = "                  previously-hashed message, deterministic version."]
    #[doc = ""]
    #[doc = "                  For more information, see <em>RFC-6979: Deterministic"]
    #[doc = "                  Usage of the Digital Signature Algorithm (DSA) and Elliptic"]
    #[doc = "                  Curve Digital Signature Algorithm (ECDSA)</em>."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp           The context for the elliptic curve to use."]
    #[doc = "                      This must be initialized and have group parameters"]
    #[doc = "                      set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param r             The MPI context in which to store the first part"]
    #[doc = "                      the signature. This must be initialized."]
    #[doc = " \\param s             The MPI context in which to store the second part"]
    #[doc = "                      the signature. This must be initialized."]
    #[doc = " \\param d             The private signing key. This must be initialized"]
    #[doc = "                      and setup, for example through mbedtls_ecp_gen_privkey()."]
    #[doc = " \\param buf           The hashed content to be signed. This must be a readable"]
    #[doc = "                      buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                      \\p blen is zero."]
    #[doc = " \\param blen          The length of \\p buf in Bytes."]
    #[doc = " \\param md_alg        The hash algorithm used to hash the original data."]
    #[doc = " \\param f_rng_blind   The RNG function used for blinding. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = " \\param p_rng_blind   The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                      \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX"]
    #[doc = "                  error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdsa_sign_det_ext"]
    pub fn ecdsa_sign_det_ext(
        grp: *mut ecp_group,
        r: *mut mpi,
        s: *mut mpi,
        d: *const mpi,
        buf: *const crate::types::c_uchar,
        blen: usize,
        md_alg: md_type_t,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng_blind: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function verifies the ECDSA signature of a"]
    #[doc = "                  previously-hashed message."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.4, step 3."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use."]
    #[doc = "                  This must be initialized and have group parameters"]
    #[doc = "                  set, for example through mbedtls_ecp_group_load()."]
    #[doc = " \\param buf       The hashed content that was signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes. It may be \\c NULL if"]
    #[doc = "                  \\p blen is zero."]
    #[doc = " \\param blen      The length of \\p buf in Bytes."]
    #[doc = " \\param Q         The public key to use for verification. This must be"]
    #[doc = "                  initialized and setup."]
    #[doc = " \\param r         The first integer of the signature."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param s         The second integer of the signature."]
    #[doc = "                  This must be initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the signature"]
    #[doc = "                  is invalid."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX"]
    #[doc = "                  error code on failure for any other reason."]
    #[link_name = "\u{1}mbedtls_ecdsa_verify"]
    pub fn ecdsa_verify(
        grp: *mut ecp_group,
        buf: *const crate::types::c_uchar,
        blen: usize,
        Q: *const ecp_point,
        r: *const mpi,
        s: *const mpi,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature and writes it"]
    #[doc = "                  to a buffer, serialized as defined in <em>RFC-4492:"]
    #[doc = "                  Elliptic Curve Cryptography (ECC) Cipher Suites for"]
    #[doc = "                  Transport Layer Security (TLS)</em>."]
    #[doc = ""]
    #[doc = " \\warning         It is not thread-safe to use the same context in"]
    #[doc = "                  multiple threads."]
    #[doc = ""]
    #[doc = " \\note            The deterministic version is used if"]
    #[doc = "                  #MBEDTLS_ECDSA_DETERMINISTIC is defined. For more"]
    #[doc = "                  information, see <em>RFC-6979: Deterministic Usage"]
    #[doc = "                  of the Digital Signature Algorithm (DSA) and Elliptic"]
    #[doc = "                  Curve Digital Signature Algorithm (ECDSA)</em>."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to use. This must be initialized"]
    #[doc = "                  and have a group and private key bound to it, for example"]
    #[doc = "                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair()."]
    #[doc = " \\param md_alg    The message digest that was used to hash the message."]
    #[doc = " \\param hash      The message hash to be signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes."]
    #[doc = " \\param hlen      The length of the hash \\p hash in Bytes."]
    #[doc = " \\param sig       The buffer to which to write the signature. This must be a"]
    #[doc = "                  writable buffer of length at least twice as large as the"]
    #[doc = "                  size of the curve used, plus 9. For example, 73 Bytes if"]
    #[doc = "                  a 256-bit curve is used. A buffer length of"]
    #[doc = "                  #MBEDTLS_ECDSA_MAX_LEN is always safe."]
    #[doc = " \\param slen      The address at which to store the actual length of"]
    #[doc = "                  the signature written. Must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL if"]
    #[doc = "                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,"]
    #[doc = "                  it is used only for blinding and may be set to \\c NULL, but"]
    #[doc = "                  doing so is DEPRECATED."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or"]
    #[doc = "                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdsa_write_signature"]
    pub fn ecdsa_write_signature(
        ctx: *mut ecdsa_context,
        md_alg: md_type_t,
        hash: *const crate::types::c_uchar,
        hlen: usize,
        sig: *mut crate::types::c_uchar,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature and writes it"]
    #[doc = "                  to a buffer, in a restartable way."]
    #[doc = ""]
    #[doc = " \\see             \\c mbedtls_ecdsa_write_signature()"]
    #[doc = ""]
    #[doc = " \\note            This function is like \\c mbedtls_ecdsa_write_signature()"]
    #[doc = "                  but it can return early and restart according to the limit"]
    #[doc = "                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to use. This must be initialized"]
    #[doc = "                  and have a group and private key bound to it, for example"]
    #[doc = "                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair()."]
    #[doc = " \\param md_alg    The message digest that was used to hash the message."]
    #[doc = " \\param hash      The message hash to be signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes."]
    #[doc = " \\param hlen      The length of the hash \\p hash in Bytes."]
    #[doc = " \\param sig       The buffer to which to write the signature. This must be a"]
    #[doc = "                  writable buffer of length at least twice as large as the"]
    #[doc = "                  size of the curve used, plus 9. For example, 73 Bytes if"]
    #[doc = "                  a 256-bit curve is used. A buffer length of"]
    #[doc = "                  #MBEDTLS_ECDSA_MAX_LEN is always safe."]
    #[doc = " \\param slen      The address at which to store the actual length of"]
    #[doc = "                  the signature written. Must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function. This must not be \\c NULL if"]
    #[doc = "                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,"]
    #[doc = "                  it is unused and may be set to \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context."]
    #[doc = " \\param rs_ctx    The restart context to use. This may be \\c NULL to disable"]
    #[doc = "                  restarting. If it is not \\c NULL, it must point to an"]
    #[doc = "                  initialized restart context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or"]
    #[doc = "                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdsa_write_signature_restartable"]
    pub fn ecdsa_write_signature_restartable(
        ctx: *mut ecdsa_context,
        md_alg: md_type_t,
        hash: *const crate::types::c_uchar,
        hlen: usize,
        sig: *mut crate::types::c_uchar,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        rs_ctx: *mut ecdsa_restart_ctx,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes an ECDSA signature and writes"]
    #[doc = "                  it to a buffer, serialized as defined in <em>RFC-4492:"]
    #[doc = "                  Elliptic Curve Cryptography (ECC) Cipher Suites for"]
    #[doc = "                  Transport Layer Security (TLS)</em>."]
    #[doc = ""]
    #[doc = "                  The deterministic version is defined in <em>RFC-6979:"]
    #[doc = "                  Deterministic Usage of the Digital Signature Algorithm (DSA)"]
    #[doc = "                  and Elliptic Curve Digital Signature Algorithm (ECDSA)</em>."]
    #[doc = ""]
    #[doc = " \\warning         It is not thread-safe to use the same context in"]
    #[doc = "                  multiple threads."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.3, step 5."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\deprecated      Superseded by mbedtls_ecdsa_write_signature() in"]
    #[doc = "                  Mbed TLS version 2.0 and later."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to use. This must be initialized"]
    #[doc = "                  and have a group and private key bound to it, for example"]
    #[doc = "                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair()."]
    #[doc = " \\param hash      The message hash to be signed. This must be a readable"]
    #[doc = "                  buffer of length \\p blen Bytes."]
    #[doc = " \\param hlen      The length of the hash \\p hash in Bytes."]
    #[doc = " \\param sig       The buffer to which to write the signature. This must be a"]
    #[doc = "                  writable buffer of length at least twice as large as the"]
    #[doc = "                  size of the curve used, plus 9. For example, 73 Bytes if"]
    #[doc = "                  a 256-bit curve is used. A buffer length of"]
    #[doc = "                  #MBEDTLS_ECDSA_MAX_LEN is always safe."]
    #[doc = " \\param slen      The address at which to store the actual length of"]
    #[doc = "                  the signature written. Must not be \\c NULL."]
    #[doc = " \\param md_alg    The message digest that was used to hash the message."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or"]
    #[doc = "                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdsa_write_signature_det"]
    pub fn ecdsa_write_signature_det(
        ctx: *mut ecdsa_context,
        hash: *const crate::types::c_uchar,
        hlen: usize,
        sig: *mut crate::types::c_uchar,
        slen: *mut usize,
        md_alg: md_type_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads and verifies an ECDSA signature."]
    #[doc = ""]
    #[doc = " \\note            If the bitlength of the message hash is larger than the"]
    #[doc = "                  bitlength of the group order, then the hash is truncated as"]
    #[doc = "                  defined in <em>Standards for Efficient Cryptography Group"]
    #[doc = "                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section"]
    #[doc = "                  4.1.4, step 3."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to use. This must be initialized"]
    #[doc = "                  and have a group and public key bound to it."]
    #[doc = " \\param hash      The message hash that was signed. This must be a readable"]
    #[doc = "                  buffer of length \\p size Bytes."]
    #[doc = " \\param hlen      The size of the hash \\p hash."]
    #[doc = " \\param sig       The signature to read and verify. This must be a readable"]
    #[doc = "                  buffer of length \\p slen Bytes."]
    #[doc = " \\param slen      The size of \\p sig in Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in \\p sig, but its length is less than \\p siglen."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX"]
    #[doc = "                  error code on failure for any other reason."]
    #[link_name = "\u{1}mbedtls_ecdsa_read_signature"]
    pub fn ecdsa_read_signature(
        ctx: *mut ecdsa_context,
        hash: *const crate::types::c_uchar,
        hlen: usize,
        sig: *const crate::types::c_uchar,
        slen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads and verifies an ECDSA signature,"]
    #[doc = "                  in a restartable way."]
    #[doc = ""]
    #[doc = " \\see             \\c mbedtls_ecdsa_read_signature()"]
    #[doc = ""]
    #[doc = " \\note            This function is like \\c mbedtls_ecdsa_read_signature()"]
    #[doc = "                  but it can return early and restart according to the limit"]
    #[doc = "                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to use. This must be initialized"]
    #[doc = "                  and have a group and public key bound to it."]
    #[doc = " \\param hash      The message hash that was signed. This must be a readable"]
    #[doc = "                  buffer of length \\p size Bytes."]
    #[doc = " \\param hlen      The size of the hash \\p hash."]
    #[doc = " \\param sig       The signature to read and verify. This must be a readable"]
    #[doc = "                  buffer of length \\p slen Bytes."]
    #[doc = " \\param slen      The size of \\p sig in Bytes."]
    #[doc = " \\param rs_ctx    The restart context to use. This may be \\c NULL to disable"]
    #[doc = "                  restarting. If it is not \\c NULL, it must point to an"]
    #[doc = "                  initialized restart context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in \\p sig, but its length is less than \\p siglen."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX"]
    #[doc = "                  error code on failure for any other reason."]
    #[link_name = "\u{1}mbedtls_ecdsa_read_signature_restartable"]
    pub fn ecdsa_read_signature_restartable(
        ctx: *mut ecdsa_context,
        hash: *const crate::types::c_uchar,
        hlen: usize,
        sig: *const crate::types::c_uchar,
        slen: usize,
        rs_ctx: *mut ecdsa_restart_ctx,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function generates an ECDSA keypair on the given curve."]
    #[doc = ""]
    #[doc = " \\see            ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx      The ECDSA context to store the keypair in."]
    #[doc = "                 This must be initialized."]
    #[doc = " \\param gid      The elliptic curve to use. One of the various"]
    #[doc = "                 \\c MBEDTLS_ECP_DP_XXX macros depending on configuration."]
    #[doc = " \\param f_rng    The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    #[link_name = "\u{1}mbedtls_ecdsa_genkey"]
    pub fn ecdsa_genkey(
        ctx: *mut ecdsa_context,
        gid: ecp_group_id,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECDSA context from an EC key pair."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to setup. This must be initialized."]
    #[doc = " \\param key       The EC key to use. This must be initialized and hold"]
    #[doc = "                  a private-public key pair or a public key. In the former"]
    #[doc = "                  case, the ECDSA context may be used for signature creation"]
    #[doc = "                  and verification after this call. In the latter case, it"]
    #[doc = "                  may be used for signature verification."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    #[link_name = "\u{1}mbedtls_ecdsa_from_keypair"]
    pub fn ecdsa_from_keypair(
        ctx: *mut ecdsa_context,
        key: *const ecp_keypair,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDSA context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to initialize."]
    #[doc = "                  This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_ecdsa_init"]
    pub fn ecdsa_init(ctx: *mut ecdsa_context);
}
extern "C" {
    #[doc = " \\brief           This function frees an ECDSA context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDSA context to free. This may be \\c NULL,"]
    #[doc = "                  in which case this function does nothing. If it"]
    #[doc = "                  is not \\c NULL, it must be initialized."]
    #[link_name = "\u{1}mbedtls_ecdsa_free"]
    pub fn ecdsa_free(ctx: *mut ecdsa_context);
}
#[repr(u32)]
#[doc = " Defines the source of the imported EC key."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ecdh_side {
    #[doc = "< Our key."]
    ECDH_OURS = 0,
    #[doc = "< The key of the peer."]
    ECDH_THEIRS = 1,
}
#[doc = " \\warning         Performing multiple operations concurrently on the same"]
#[doc = "                  ECDSA context is not supported; objects of this type"]
#[doc = "                  should not be shared between multiple threads."]
#[doc = " \\brief           The ECDH context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecdh_context {
    #[doc = "< The elliptic curve used."]
    pub grp: ecp_group,
    #[doc = "< The private key."]
    pub d: mpi,
    #[doc = "< The public key."]
    pub Q: ecp_point,
    #[doc = "< The value of the public key of the peer."]
    pub Qp: ecp_point,
    #[doc = "< The shared secret."]
    pub z: mpi,
    #[doc = "< The format of point export in TLS messages."]
    pub point_format: crate::types::c_int,
    #[doc = "< The blinding value."]
    pub Vi: ecp_point,
    #[doc = "< The unblinding value."]
    pub Vf: ecp_point,
    #[doc = "< The previous \\p d."]
    pub _d: mpi,
}
#[test]
fn bindgen_test_layout_ecdh_context() {
    assert_eq!(
        ::core::mem::size_of::<ecdh_context>(),
        308usize,
        concat!("Size of: ", stringify!(ecdh_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ecdh_context>(),
        4usize,
        concat!("Alignment of ", stringify!(ecdh_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).grp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).d as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).Q as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).Qp as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).z as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).point_format as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(point_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).Vi as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Vi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).Vf as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>()))._d as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(_d)
        )
    );
}
impl Default for ecdh_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Check whether a given group can be used for ECDH."]
    #[doc = ""]
    #[doc = " \\param gid      The ECP group ID to check."]
    #[doc = ""]
    #[doc = " \\return         \\c 1 if the group can be used, \\c 0 otherwise"]
    #[link_name = "\u{1}mbedtls_ecdh_can_do"]
    pub fn ecdh_can_do(gid: ecp_group_id) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECDH keypair on an elliptic"]
    #[doc = "                  curve."]
    #[doc = ""]
    #[doc = "                  This function performs the first of two core computations"]
    #[doc = "                  implemented during the ECDH key exchange. The second core"]
    #[doc = "                  computation is performed by mbedtls_ecdh_compute_shared()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use. This must be initialized and have"]
    #[doc = "                  domain parameters loaded, for example through"]
    #[doc = "                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group()."]
    #[doc = " \\param d         The destination MPI (private key)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The destination point (public key)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL in case \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX or"]
    #[doc = "                  \\c MBEDTLS_MPI_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdh_gen_public"]
    pub fn ecdh_gen_public(
        grp: *mut ecp_group,
        d: *mut mpi,
        Q: *mut ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the shared secret."]
    #[doc = ""]
    #[doc = "                  This function performs the second of two core computations"]
    #[doc = "                  implemented during the ECDH key exchange. The first core"]
    #[doc = "                  computation is performed by mbedtls_ecdh_gen_public()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\note            If \\p f_rng is not NULL, it is used to implement"]
    #[doc = "                  countermeasures against side-channel attacks."]
    #[doc = "                  For more information, see mbedtls_ecp_mul()."]
    #[doc = ""]
    #[doc = " \\param grp       The ECP group to use. This must be initialized and have"]
    #[doc = "                  domain parameters loaded, for example through"]
    #[doc = "                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group()."]
    #[doc = " \\param z         The destination MPI (shared secret)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param Q         The public key from another party."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param d         Our secret exponent (private key)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param f_rng     The RNG function. This may be \\c NULL if randomization"]
    #[doc = "                  of intermediate results during the ECP computations is"]
    #[doc = "                  not needed (discouraged). See the documentation of"]
    #[doc = "                  mbedtls_ecp_mul() for more."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL if \\p f_rng is \\c NULL or doesn't need a"]
    #[doc = "                  context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX or"]
    #[doc = "                  \\c MBEDTLS_MPI_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdh_compute_shared"]
    pub fn ecdh_compute_shared(
        grp: *mut ecp_group,
        z: *mut mpi,
        Q: *const ecp_point,
        d: *const mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDH context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to initialize. This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_ecdh_init"]
    pub fn ecdh_init(ctx: *mut ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function sets up the ECDH context with the information"]
    #[doc = "                  given."]
    #[doc = ""]
    #[doc = "                  This function should be called after mbedtls_ecdh_init() but"]
    #[doc = "                  before mbedtls_ecdh_make_params(). There is no need to call"]
    #[doc = "                  this function before mbedtls_ecdh_read_params()."]
    #[doc = ""]
    #[doc = "                  This is the first function used by a TLS server for ECDHE"]
    #[doc = "                  ciphersuites."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to set up. This must be initialized."]
    #[doc = " \\param grp_id    The group id of the group to set up the context for."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_ecdh_setup"]
    pub fn ecdh_setup(ctx: *mut ecdh_context, grp_id: ecp_group_id) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function frees a context."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to free. This may be \\c NULL, in which"]
    #[doc = "                  case this function does nothing. If it is not \\c NULL,"]
    #[doc = "                  it must point to an initialized ECDH context."]
    #[link_name = "\u{1}mbedtls_ecdh_free"]
    pub fn ecdh_free(ctx: *mut ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function generates an EC key pair and exports its"]
    #[doc = "                  in the format used in a TLS ServerKeyExchange handshake"]
    #[doc = "                  message."]
    #[doc = ""]
    #[doc = "                  This is the second function used by a TLS server for ECDHE"]
    #[doc = "                  ciphersuites. (It is called after mbedtls_ecdh_setup().)"]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to use. This must be initialized"]
    #[doc = "                  and bound to a group, for example via mbedtls_ecdh_setup()."]
    #[doc = " \\param olen      The address at which to store the number of Bytes written."]
    #[doc = " \\param buf       The destination buffer. This must be a writable buffer of"]
    #[doc = "                  length \\p blen Bytes."]
    #[doc = " \\param blen      The length of the destination buffer \\p buf in Bytes."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL in case \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdh_make_params"]
    pub fn ecdh_make_params(
        ctx: *mut ecdh_context,
        olen: *mut usize,
        buf: *mut crate::types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function parses the ECDHE parameters in a"]
    #[doc = "                  TLS ServerKeyExchange handshake message."]
    #[doc = ""]
    #[doc = " \\note            In a TLS handshake, this is the how the client"]
    #[doc = "                  sets up its ECDHE context from the server's public"]
    #[doc = "                  ECDHE key material."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDHE context to use. This must be initialized."]
    #[doc = " \\param buf       On input, \\c *buf must be the start of the input buffer."]
    #[doc = "                  On output, \\c *buf is updated to point to the end of the"]
    #[doc = "                  data that has been read. On success, this is the first byte"]
    #[doc = "                  past the end of the ServerKeyExchange parameters."]
    #[doc = "                  On error, this is the point at which an error has been"]
    #[doc = "                  detected, which is usually not useful except to debug"]
    #[doc = "                  failures."]
    #[doc = " \\param end       The end of the input buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_ecdh_read_params"]
    pub fn ecdh_read_params(
        ctx: *mut ecdh_context,
        buf: *mut *const crate::types::c_uchar,
        end: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECDH context from an EC key."]
    #[doc = ""]
    #[doc = "                  It is used by clients and servers in place of the"]
    #[doc = "                  ServerKeyEchange for static ECDH, and imports ECDH"]
    #[doc = "                  parameters from the EC key information of a certificate."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to set up. This must be initialized."]
    #[doc = " \\param key       The EC key to use. This must be initialized."]
    #[doc = " \\param side      Defines the source of the key. Possible values are:"]
    #[doc = "                  - #MBEDTLS_ECDH_OURS: The key is ours."]
    #[doc = "                  - #MBEDTLS_ECDH_THEIRS: The key is that of the peer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_ecdh_get_params"]
    pub fn ecdh_get_params(
        ctx: *mut ecdh_context,
        key: *const ecp_keypair,
        side: ecdh_side,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a public key and exports it"]
    #[doc = "                  as a TLS ClientKeyExchange payload."]
    #[doc = ""]
    #[doc = "                  This is the second function used by a TLS client for ECDH(E)"]
    #[doc = "                  ciphersuites."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to use. This must be initialized"]
    #[doc = "                  and bound to a group, the latter usually by"]
    #[doc = "                  mbedtls_ecdh_read_params()."]
    #[doc = " \\param olen      The address at which to store the number of Bytes written."]
    #[doc = "                  This must not be \\c NULL."]
    #[doc = " \\param buf       The destination buffer. This must be a writable buffer"]
    #[doc = "                  of length \\p blen Bytes."]
    #[doc = " \\param blen      The size of the destination buffer \\p buf in Bytes."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                  \\c NULL in case \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdh_make_public"]
    pub fn ecdh_make_public(
        ctx: *mut ecdh_context,
        olen: *mut usize,
        buf: *mut crate::types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       This function parses and processes the ECDHE payload of a"]
    #[doc = "              TLS ClientKeyExchange message."]
    #[doc = ""]
    #[doc = "              This is the third function used by a TLS server for ECDH(E)"]
    #[doc = "              ciphersuites. (It is called after mbedtls_ecdh_setup() and"]
    #[doc = "              mbedtls_ecdh_make_params().)"]
    #[doc = ""]
    #[doc = " \\see         ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx   The ECDH context to use. This must be initialized"]
    #[doc = "              and bound to a group, for example via mbedtls_ecdh_setup()."]
    #[doc = " \\param buf   The pointer to the ClientKeyExchange payload. This must"]
    #[doc = "              be a readable buffer of length \\p blen Bytes."]
    #[doc = " \\param blen  The length of the input buffer \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\return      \\c 0 on success."]
    #[doc = " \\return      An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdh_read_public"]
    pub fn ecdh_read_public(
        ctx: *mut ecdh_context,
        buf: *const crate::types::c_uchar,
        blen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function derives and exports the shared secret."]
    #[doc = ""]
    #[doc = "                  This is the last function used by both TLS client"]
    #[doc = "                  and servers."]
    #[doc = ""]
    #[doc = " \\note            If \\p f_rng is not NULL, it is used to implement"]
    #[doc = "                  countermeasures against side-channel attacks."]
    #[doc = "                  For more information, see mbedtls_ecp_mul()."]
    #[doc = ""]
    #[doc = " \\see             ecp.h"]
    #[doc = ""]
    #[doc = " \\param ctx       The ECDH context to use. This must be initialized"]
    #[doc = "                  and have its own private key generated and the peer's"]
    #[doc = "                  public key imported."]
    #[doc = " \\param olen      The address at which to store the total number of"]
    #[doc = "                  Bytes written on success. This must not be \\c NULL."]
    #[doc = " \\param buf       The buffer to write the generated shared key to. This"]
    #[doc = "                  must be a writable buffer of size \\p blen Bytes."]
    #[doc = " \\param blen      The length of the destination buffer \\p buf in Bytes."]
    #[doc = " \\param f_rng     The RNG function, for blinding purposes. This may"]
    #[doc = "                  b \\c NULL if blinding isn't needed."]
    #[doc = " \\param p_rng     The RNG context. This may be \\c NULL if \\p f_rng"]
    #[doc = "                  doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[doc = " \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ecdh_calc_secret"]
    pub fn ecdh_calc_secret(
        ctx: *mut ecdh_context,
        olen: *mut usize,
        buf: *mut crate::types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_buf {
    #[doc = "< ASN1 type, e.g. MBEDTLS_ASN1_UTF8_STRING."]
    pub tag: crate::types::c_int,
    #[doc = "< ASN1 length, in octets."]
    pub len: usize,
    #[doc = "< ASN1 data, e.g. in ASCII."]
    pub p: *mut crate::types::c_uchar,
}
#[test]
fn bindgen_test_layout_asn1_buf() {
    assert_eq!(
        ::core::mem::size_of::<asn1_buf>(),
        12usize,
        concat!("Size of: ", stringify!(asn1_buf))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_buf>(),
        4usize,
        concat!("Alignment of ", stringify!(asn1_buf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_buf>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_buf),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_buf>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_buf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_buf>())).p as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_buf),
            "::",
            stringify!(p)
        )
    );
}
impl Default for asn1_buf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Container for ASN1 bit strings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_bitstring {
    #[doc = "< ASN1 length, in octets."]
    pub len: usize,
    #[doc = "< Number of unused bits at the end of the string"]
    pub unused_bits: crate::types::c_uchar,
    #[doc = "< Raw ASN1 data for the bit string"]
    pub p: *mut crate::types::c_uchar,
}
#[test]
fn bindgen_test_layout_asn1_bitstring() {
    assert_eq!(
        ::core::mem::size_of::<asn1_bitstring>(),
        12usize,
        concat!("Size of: ", stringify!(asn1_bitstring))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_bitstring>(),
        4usize,
        concat!("Alignment of ", stringify!(asn1_bitstring))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_bitstring>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_bitstring),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_bitstring>())).unused_bits as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_bitstring),
            "::",
            stringify!(unused_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_bitstring>())).p as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_bitstring),
            "::",
            stringify!(p)
        )
    );
}
impl Default for asn1_bitstring {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Container for a sequence of ASN.1 items"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_sequence {
    #[doc = "< Buffer containing the given ASN.1 item."]
    pub buf: asn1_buf,
    #[doc = "< The next entry in the sequence."]
    pub next: *mut asn1_sequence,
}
#[test]
fn bindgen_test_layout_asn1_sequence() {
    assert_eq!(
        ::core::mem::size_of::<asn1_sequence>(),
        16usize,
        concat!("Size of: ", stringify!(asn1_sequence))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_sequence>(),
        4usize,
        concat!("Alignment of ", stringify!(asn1_sequence))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_sequence>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_sequence),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_sequence>())).next as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_sequence),
            "::",
            stringify!(next)
        )
    );
}
impl Default for asn1_sequence {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Container for a sequence or list of 'named' ASN.1 data items"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct asn1_named_data {
    #[doc = "< The object identifier."]
    pub oid: asn1_buf,
    #[doc = "< The named value."]
    pub val: asn1_buf,
    #[doc = "< The next entry in the sequence."]
    pub next: *mut asn1_named_data,
    #[doc = "< Merge next item into the current one?"]
    pub next_merged: crate::types::c_uchar,
}
#[test]
fn bindgen_test_layout_asn1_named_data() {
    assert_eq!(
        ::core::mem::size_of::<asn1_named_data>(),
        32usize,
        concat!("Size of: ", stringify!(asn1_named_data))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_named_data>(),
        4usize,
        concat!("Alignment of ", stringify!(asn1_named_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_named_data>())).oid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_named_data>())).val as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_named_data>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_named_data>())).next_merged as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(next_merged)
        )
    );
}
impl Default for asn1_named_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief       Get the length of an ASN.1 element."]
    #[doc = "              Updates the pointer to immediately behind the length."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the first byte of the length,"]
    #[doc = "              i.e. immediately after the tag."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              after the length, i.e. the first byte of the content."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param len   On successful completion, \\c *len contains the length"]
    #[doc = "              read from the ASN.1 input."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element"]
    #[doc = "              would end beyond \\p end."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparseable."]
    #[link_name = "\u{1}mbedtls_asn1_get_len"]
    pub fn asn1_get_len(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        len: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Get the tag and length of the element."]
    #[doc = "              Check for the requested tag."]
    #[doc = "              Updates the pointer to immediately behind the tag and length."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              after the length, i.e. the first byte of the content."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param len   On successful completion, \\c *len contains the length"]
    #[doc = "              read from the ASN.1 input."]
    #[doc = " \\param tag   The expected tag."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the data does not start"]
    #[doc = "              with the requested tag."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element"]
    #[doc = "              would end beyond \\p end."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparseable."]
    #[link_name = "\u{1}mbedtls_asn1_get_tag"]
    pub fn asn1_get_tag(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        len: *mut usize,
        tag: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a boolean ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the ASN.1 element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param val   On success, the parsed value (\\c 0 or \\c 1)."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 BOOLEAN."]
    #[link_name = "\u{1}mbedtls_asn1_get_bool"]
    pub fn asn1_get_bool(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        val: *mut crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an integer ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the ASN.1 element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param val   On success, the parsed value."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 INTEGER."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does"]
    #[doc = "              not fit in an \\c int."]
    #[link_name = "\u{1}mbedtls_asn1_get_int"]
    pub fn asn1_get_int(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        val: *mut crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an enumerated ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the ASN.1 element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param val   On success, the parsed value."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 ENUMERATED."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does"]
    #[doc = "              not fit in an \\c int."]
    #[link_name = "\u{1}mbedtls_asn1_get_enum"]
    pub fn asn1_get_enum(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        val: *mut crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p is equal to \\p end."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param bs    On success, ::mbedtls_asn1_bitstring information about"]
    #[doc = "              the parsed value."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains"]
    #[doc = "              extra data after a valid BIT STRING."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 BIT STRING."]
    #[link_name = "\u{1}mbedtls_asn1_get_bitstring"]
    pub fn asn1_get_bitstring(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        bs: *mut asn1_bitstring,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag without unused bits and its"]
    #[doc = "              value."]
    #[doc = "              Updates the pointer to the beginning of the bit/octet string."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              of the content of the BIT STRING."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param len   On success, \\c *len is the length of the content in bytes."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_DATA if the input starts with"]
    #[doc = "              a valid BIT STRING with a nonzero number of unused bits."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 BIT STRING."]
    #[link_name = "\u{1}mbedtls_asn1_get_bitstring_null"]
    pub fn asn1_get_bitstring_null(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        len: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Parses and splits an ASN.1 \"SEQUENCE OF <tag>\"."]
    #[doc = "              Updates the pointer to immediately behind the full sequence tag."]
    #[doc = ""]
    #[doc = " This function allocates memory for the sequence elements. You can free"]
    #[doc = " the allocated memory with mbedtls_asn1_sequence_free()."]
    #[doc = ""]
    #[doc = " \\note        On error, this function may return a partial list in \\p cur."]
    #[doc = "              You must set `cur->next = NULL` before calling this function!"]
    #[doc = "              Otherwise it is impossible to distinguish a previously non-null"]
    #[doc = "              pointer from a pointer to an object allocated by this function."]
    #[doc = ""]
    #[doc = " \\note        If the sequence is empty, this function does not modify"]
    #[doc = "              \\c *cur. If the sequence is valid and non-empty, this"]
    #[doc = "              function sets `cur->buf.tag` to \\p tag. This allows"]
    #[doc = "              callers to distinguish between an empty sequence and"]
    #[doc = "              a one-element sequence."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p is equal to \\p end."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param cur   A ::mbedtls_asn1_sequence which this function fills."]
    #[doc = "              When this function returns, \\c *cur is the head of a linked"]
    #[doc = "              list. Each node in this list is allocated with"]
    #[doc = "              mbedtls_calloc() apart from \\p cur itself, and should"]
    #[doc = "              therefore be freed with mbedtls_free()."]
    #[doc = "              The list describes the content of the sequence."]
    #[doc = "              The head of the list (i.e. \\c *cur itself) describes the"]
    #[doc = "              first element, `*cur->next` describes the second element, etc."]
    #[doc = "              For each element, `buf.tag == tag`, `buf.len` is the length"]
    #[doc = "              of the content of the content of the element, and `buf.p`"]
    #[doc = "              points to the first byte of the content (i.e. immediately"]
    #[doc = "              past the length of the element)."]
    #[doc = "              Note that list elements may be allocated even on error."]
    #[doc = " \\param tag   Each element of the sequence must have this tag."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains"]
    #[doc = "              extra data after a valid SEQUENCE OF \\p tag."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts with"]
    #[doc = "              an ASN.1 SEQUENCE in which an element has a tag that"]
    #[doc = "              is different from \\p tag."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_ALLOC_FAILED if a memory allocation failed."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 SEQUENCE."]
    #[link_name = "\u{1}mbedtls_asn1_get_sequence_of"]
    pub fn asn1_get_sequence_of(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        cur: *mut asn1_sequence,
        tag: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Free a heap-allocated linked list presentation of"]
    #[doc = "                 an ASN.1 sequence, including the first element."]
    #[doc = ""]
    #[doc = " There are two common ways to manage the memory used for the representation"]
    #[doc = " of a parsed ASN.1 sequence:"]
    #[doc = " - Allocate a head node `mbedtls_asn1_sequence *head` with mbedtls_calloc()."]
    #[doc = "   Pass this node as the `cur` argument to mbedtls_asn1_get_sequence_of()."]
    #[doc = "   When you have finished processing the sequence,"]
    #[doc = "   call mbedtls_asn1_sequence_free() on `head`."]
    #[doc = " - Allocate a head node `mbedtls_asn1_sequence *head` in any manner,"]
    #[doc = "   for example on the stack. Make sure that `head->next == NULL`."]
    #[doc = "   Pass `head` as the `cur` argument to mbedtls_asn1_get_sequence_of()."]
    #[doc = "   When you have finished processing the sequence,"]
    #[doc = "   call mbedtls_asn1_sequence_free() on `head->cur`,"]
    #[doc = "   then free `head` itself in the appropriate manner."]
    #[doc = ""]
    #[doc = " \\param seq      The address of the first sequence component. This may"]
    #[doc = "                 be \\c NULL, in which case this functions returns"]
    #[doc = "                 immediately."]
    #[link_name = "\u{1}mbedtls_asn1_sequence_free"]
    pub fn asn1_sequence_free(seq: *mut asn1_sequence);
}
extern "C" {
    #[doc = " \\brief                Traverse an ASN.1 SEQUENCE container and"]
    #[doc = "                       call a callback for each entry."]
    #[doc = ""]
    #[doc = " This function checks that the input is a SEQUENCE of elements that"]
    #[doc = " each have a \"must\" tag, and calls a callback function on the elements"]
    #[doc = " that have a \"may\" tag."]
    #[doc = ""]
    #[doc = " For example, to validate that the input is a SEQUENCE of `tag1` and call"]
    #[doc = " `cb` on each element, use"]
    #[doc = " ```"]
    #[doc = " mbedtls_asn1_traverse_sequence_of(&p, end, 0xff, tag1, 0, 0, cb, ctx);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " To validate that the input is a SEQUENCE of ANY and call `cb` on"]
    #[doc = " each element, use"]
    #[doc = " ```"]
    #[doc = " mbedtls_asn1_traverse_sequence_of(&p, end, 0, 0, 0, 0, cb, ctx);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " To validate that the input is a SEQUENCE of CHOICE {NULL, OCTET STRING}"]
    #[doc = " and call `cb` on each element that is an OCTET STRING, use"]
    #[doc = " ```"]
    #[doc = " mbedtls_asn1_traverse_sequence_of(&p, end, 0xfe, 0x04, 0xff, 0x04, cb, ctx);"]
    #[doc = " ```"]
    #[doc = ""]
    #[doc = " The callback is called on the elements with a \"may\" tag from left to"]
    #[doc = " right. If the input is not a valid SEQUENCE of elements with a \"must\" tag,"]
    #[doc = " the callback is called on the elements up to the leftmost point where"]
    #[doc = " the input is invalid."]
    #[doc = ""]
    #[doc = " \\warning              This function is still experimental and may change"]
    #[doc = "                       at any time."]
    #[doc = ""]
    #[doc = " \\param p              The address of the pointer to the beginning of"]
    #[doc = "                       the ASN.1 SEQUENCE header. This is updated to"]
    #[doc = "                       point to the end of the ASN.1 SEQUENCE container"]
    #[doc = "                       on a successful invocation."]
    #[doc = " \\param end            The end of the ASN.1 SEQUENCE container."]
    #[doc = " \\param tag_must_mask  A mask to be applied to the ASN.1 tags found within"]
    #[doc = "                       the SEQUENCE before comparing to \\p tag_must_value."]
    #[doc = " \\param tag_must_val   The required value of each ASN.1 tag found in the"]
    #[doc = "                       SEQUENCE, after masking with \\p tag_must_mask."]
    #[doc = "                       Mismatching tags lead to an error."]
    #[doc = "                       For example, a value of \\c 0 for both \\p tag_must_mask"]
    #[doc = "                       and \\p tag_must_val means that every tag is allowed,"]
    #[doc = "                       while a value of \\c 0xFF for \\p tag_must_mask means"]
    #[doc = "                       that \\p tag_must_val is the only allowed tag."]
    #[doc = " \\param tag_may_mask   A mask to be applied to the ASN.1 tags found within"]
    #[doc = "                       the SEQUENCE before comparing to \\p tag_may_value."]
    #[doc = " \\param tag_may_val    The desired value of each ASN.1 tag found in the"]
    #[doc = "                       SEQUENCE, after masking with \\p tag_may_mask."]
    #[doc = "                       Mismatching tags will be silently ignored."]
    #[doc = "                       For example, a value of \\c 0 for \\p tag_may_mask and"]
    #[doc = "                       \\p tag_may_val means that any tag will be considered,"]
    #[doc = "                       while a value of \\c 0xFF for \\p tag_may_mask means"]
    #[doc = "                       that all tags with value different from \\p tag_may_val"]
    #[doc = "                       will be ignored."]
    #[doc = " \\param cb             The callback to trigger for each component"]
    #[doc = "                       in the ASN.1 SEQUENCE that matches \\p tag_may_val."]
    #[doc = "                       The callback function is called with the following"]
    #[doc = "                       parameters:"]
    #[doc = "                       - \\p ctx."]
    #[doc = "                       - The tag of the current element."]
    #[doc = "                       - A pointer to the start of the current element's"]
    #[doc = "                         content inside the input."]
    #[doc = "                       - The length of the content of the current element."]
    #[doc = "                       If the callback returns a non-zero value,"]
    #[doc = "                       the function stops immediately,"]
    #[doc = "                       forwarding the callback's return value."]
    #[doc = " \\param ctx            The context to be passed to the callback \\p cb."]
    #[doc = ""]
    #[doc = " \\return               \\c 0 if successful the entire ASN.1 SEQUENCE"]
    #[doc = "                       was traversed without parsing or callback errors."]
    #[doc = " \\return               #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input"]
    #[doc = "                       contains extra data after a valid SEQUENCE"]
    #[doc = "                       of elements with an accepted tag."]
    #[doc = " \\return               #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts"]
    #[doc = "                       with an ASN.1 SEQUENCE in which an element has a tag"]
    #[doc = "                       that is not accepted."]
    #[doc = " \\return               An ASN.1 error code if the input does not start with"]
    #[doc = "                       a valid ASN.1 SEQUENCE."]
    #[doc = " \\return               A non-zero error code forwarded from the callback"]
    #[doc = "                       \\p cb in case the latter returns a non-zero value."]
    #[link_name = "\u{1}mbedtls_asn1_traverse_sequence_of"]
    pub fn asn1_traverse_sequence_of(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        tag_must_mask: crate::types::c_uchar,
        tag_must_val: crate::types::c_uchar,
        tag_may_mask: crate::types::c_uchar,
        tag_may_val: crate::types::c_uchar,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut crate::types::c_void,
                tag: crate::types::c_int,
                start: *mut crate::types::c_uchar,
                len: usize,
            ) -> crate::types::c_int,
        >,
        ctx: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an integer ASN.1 tag and its value."]
    #[doc = "              Updates the pointer to immediately behind the full tag."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the ASN.1 element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param X     On success, the parsed value."]
    #[doc = ""]
    #[doc = " \\return      0 if successful."]
    #[doc = " \\return      An ASN.1 error code if the input does not start with"]
    #[doc = "              a valid ASN.1 INTEGER."]
    #[doc = " \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does"]
    #[doc = "              not fit in an \\c int."]
    #[doc = " \\return      An MPI error code if the parsed value is too large."]
    #[link_name = "\u{1}mbedtls_asn1_get_mpi"]
    pub fn asn1_get_mpi(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        X: *mut mpi,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence."]
    #[doc = "              Updates the pointer to immediately behind the full"]
    #[doc = "              AlgorithmIdentifier."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the AlgorithmIdentifier element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param alg   The buffer to receive the OID."]
    #[doc = " \\param params The buffer to receive the parameters."]
    #[doc = "              This is zeroized if there are no parameters."]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 or MPI error code."]
    #[link_name = "\u{1}mbedtls_asn1_get_alg"]
    pub fn asn1_get_alg(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        alg: *mut asn1_buf,
        params: *mut asn1_buf,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no"]
    #[doc = "              params."]
    #[doc = "              Updates the pointer to immediately behind the full"]
    #[doc = "              AlgorithmIdentifier."]
    #[doc = ""]
    #[doc = " \\param p     On entry, \\c *p points to the start of the ASN.1 element."]
    #[doc = "              On successful completion, \\c *p points to the first byte"]
    #[doc = "              beyond the AlgorithmIdentifier element."]
    #[doc = "              On error, the value of \\c *p is undefined."]
    #[doc = " \\param end   End of data."]
    #[doc = " \\param alg   The buffer to receive the OID."]
    #[doc = ""]
    #[doc = " \\return      0 if successful or a specific ASN.1 or MPI error code."]
    #[link_name = "\u{1}mbedtls_asn1_get_alg_null"]
    pub fn asn1_get_alg_null(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        alg: *mut asn1_buf,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Find a specific named_data entry in a sequence or list based on"]
    #[doc = "              the OID."]
    #[doc = ""]
    #[doc = " \\param list  The list to seek through"]
    #[doc = " \\param oid   The OID to look for"]
    #[doc = " \\param len   Size of the OID"]
    #[doc = ""]
    #[doc = " \\return      NULL if not found, or a pointer to the existing entry."]
    #[link_name = "\u{1}mbedtls_asn1_find_named_data"]
    pub fn asn1_find_named_data(
        list: *mut asn1_named_data,
        oid: *const crate::types::c_char,
        len: usize,
    ) -> *mut asn1_named_data;
}
extern "C" {
    #[doc = " \\brief       Free a mbedtls_asn1_named_data entry"]
    #[doc = ""]
    #[doc = " \\param entry The named data entry to free."]
    #[doc = "              This function calls mbedtls_free() on"]
    #[doc = "              `entry->oid.p` and `entry->val.p`."]
    #[link_name = "\u{1}mbedtls_asn1_free_named_data"]
    pub fn asn1_free_named_data(entry: *mut asn1_named_data);
}
extern "C" {
    #[doc = " \\brief       Free all entries in a mbedtls_asn1_named_data list."]
    #[doc = ""]
    #[doc = " \\param head  Pointer to the head of the list of named data entries to free."]
    #[doc = "              This function calls mbedtls_asn1_free_named_data() and"]
    #[doc = "              mbedtls_free() on each list element and"]
    #[doc = "              sets \\c *head to \\c NULL."]
    #[link_name = "\u{1}mbedtls_asn1_free_named_data_list"]
    pub fn asn1_free_named_data_list(head: *mut *mut asn1_named_data);
}
#[repr(u32)]
#[doc = " \\brief          Public key types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pk_type_t {
    PK_NONE = 0,
    PK_RSA = 1,
    PK_ECKEY = 2,
    PK_ECKEY_DH = 3,
    PK_ECDSA = 4,
    PK_RSA_ALT = 5,
    PK_RSASSA_PSS = 6,
    PK_OPAQUE = 7,
}
#[doc = " \\brief           Options for RSASSA-PSS signature verification."]
#[doc = "                  See \\c mbedtls_rsa_rsassa_pss_verify_ext()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pk_rsassa_pss_options {
    pub mgf1_hash_id: md_type_t,
    pub expected_salt_len: crate::types::c_int,
}
#[test]
fn bindgen_test_layout_pk_rsassa_pss_options() {
    assert_eq!(
        ::core::mem::size_of::<pk_rsassa_pss_options>(),
        8usize,
        concat!("Size of: ", stringify!(pk_rsassa_pss_options))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_rsassa_pss_options>(),
        4usize,
        concat!("Alignment of ", stringify!(pk_rsassa_pss_options))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pk_rsassa_pss_options>())).mgf1_hash_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_rsassa_pss_options),
            "::",
            stringify!(mgf1_hash_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pk_rsassa_pss_options>())).expected_salt_len as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_rsassa_pss_options),
            "::",
            stringify!(expected_salt_len)
        )
    );
}
impl Default for pk_rsassa_pss_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(u32)]
#[doc = " \\brief           Types for interfacing with the debug module"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pk_debug_type {
    PK_DEBUG_NONE = 0,
    PK_DEBUG_MPI = 1,
    PK_DEBUG_ECP = 2,
}
#[doc = " \\brief           Item to send to the debug module"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pk_debug_item {
    pub type_: pk_debug_type,
    pub name: *const crate::types::c_char,
    pub value: *mut crate::types::c_void,
}
#[test]
fn bindgen_test_layout_pk_debug_item() {
    assert_eq!(
        ::core::mem::size_of::<pk_debug_item>(),
        12usize,
        concat!("Size of: ", stringify!(pk_debug_item))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_debug_item>(),
        4usize,
        concat!("Alignment of ", stringify!(pk_debug_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_debug_item>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_debug_item),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_debug_item>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_debug_item),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_debug_item>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_debug_item),
            "::",
            stringify!(value)
        )
    );
}
impl Default for pk_debug_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " \\brief           Public key container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pk_context {
    #[doc = "< Public key information"]
    pub pk_info: *const pk_info_t,
    #[doc = "< Underlying public key context"]
    pub pk_ctx: *mut crate::types::c_void,
}
#[test]
fn bindgen_test_layout_pk_context() {
    assert_eq!(
        ::core::mem::size_of::<pk_context>(),
        8usize,
        concat!("Size of: ", stringify!(pk_context))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_context>(),
        4usize,
        concat!("Alignment of ", stringify!(pk_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_context>())).pk_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_context),
            "::",
            stringify!(pk_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_context>())).pk_ctx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_context),
            "::",
            stringify!(pk_ctx)
        )
    );
}
impl Default for pk_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type pk_restart_ctx = crate::types::c_void;
#[doc = " \\brief           Types for RSA-alt abstraction"]
pub type pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::types::c_void,
        mode: crate::types::c_int,
        olen: *mut usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        output_max_len: usize,
    ) -> crate::types::c_int,
>;
pub type pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::types::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        mode: crate::types::c_int,
        md_alg: md_type_t,
        hashlen: crate::types::c_uint,
        hash: *const crate::types::c_uchar,
        sig: *mut crate::types::c_uchar,
    ) -> crate::types::c_int,
>;
pub type pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::types::c_void) -> usize>;
extern "C" {
    #[doc = " \\brief           Return information associated with the given PK type"]
    #[doc = ""]
    #[doc = " \\param pk_type   PK type to search for."]
    #[doc = ""]
    #[doc = " \\return          The PK info associated with the type or NULL if not found."]
    #[link_name = "\u{1}mbedtls_pk_info_from_type"]
    pub fn pk_info_from_type(pk_type: pk_type_t) -> *const pk_info_t;
}
extern "C" {
    #[doc = " \\brief           Initialize a #mbedtls_pk_context (as NONE)."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to initialize."]
    #[doc = "                  This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_pk_init"]
    pub fn pk_init(ctx: *mut pk_context);
}
extern "C" {
    #[doc = " \\brief           Free the components of a #mbedtls_pk_context."]
    #[doc = ""]
    #[doc = " \\param ctx       The context to clear. It must have been initialized."]
    #[doc = "                  If this is \\c NULL, this function does nothing."]
    #[doc = ""]
    #[doc = " \\note            For contexts that have been set up with"]
    #[doc = "                  mbedtls_pk_setup_opaque(), this does not free the underlying"]
    #[doc = "                  PSA key and you still need to call psa_destroy_key()"]
    #[doc = "                  independently if you want to destroy that key."]
    #[link_name = "\u{1}mbedtls_pk_free"]
    pub fn pk_free(ctx: *mut pk_context);
}
extern "C" {
    #[doc = " \\brief           Initialize a PK context with the information given"]
    #[doc = "                  and allocates the type-specific PK subcontext."]
    #[doc = ""]
    #[doc = " \\param ctx       Context to initialize. It must not have been set"]
    #[doc = "                  up yet (type #MBEDTLS_PK_NONE)."]
    #[doc = " \\param info      Information to use"]
    #[doc = ""]
    #[doc = " \\return          0 on success,"]
    #[doc = "                  MBEDTLS_ERR_PK_BAD_INPUT_DATA on invalid input,"]
    #[doc = "                  MBEDTLS_ERR_PK_ALLOC_FAILED on allocation failure."]
    #[doc = ""]
    #[doc = " \\note            For contexts holding an RSA-alt key, use"]
    #[doc = "                  \\c mbedtls_pk_setup_rsa_alt() instead."]
    #[link_name = "\u{1}mbedtls_pk_setup"]
    pub fn pk_setup(ctx: *mut pk_context, info: *const pk_info_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Initialize an RSA-alt context"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to initialize. It must not have been set"]
    #[doc = "                  up yet (type #MBEDTLS_PK_NONE)."]
    #[doc = " \\param key       RSA key pointer"]
    #[doc = " \\param decrypt_func  Decryption function"]
    #[doc = " \\param sign_func     Signing function"]
    #[doc = " \\param key_len_func  Function returning key length in bytes"]
    #[doc = ""]
    #[doc = " \\return          0 on success, or MBEDTLS_ERR_PK_BAD_INPUT_DATA if the"]
    #[doc = "                  context wasn't already initialized as RSA_ALT."]
    #[doc = ""]
    #[doc = " \\note            This function replaces \\c mbedtls_pk_setup() for RSA-alt."]
    #[link_name = "\u{1}mbedtls_pk_setup_rsa_alt"]
    pub fn pk_setup_rsa_alt(
        ctx: *mut pk_context,
        key: *mut crate::types::c_void,
        decrypt_func: pk_rsa_alt_decrypt_func,
        sign_func: pk_rsa_alt_sign_func,
        key_len_func: pk_rsa_alt_key_len_func,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Get the size in bits of the underlying key"]
    #[doc = ""]
    #[doc = " \\param ctx       The context to query. It must have been initialized."]
    #[doc = ""]
    #[doc = " \\return          Key size in bits, or 0 on error"]
    #[link_name = "\u{1}mbedtls_pk_get_bitlen"]
    pub fn pk_get_bitlen(ctx: *const pk_context) -> usize;
}
extern "C" {
    #[doc = " \\brief           Tell if a context can do the operation given by type"]
    #[doc = ""]
    #[doc = " \\param ctx       The context to query. It must have been initialized."]
    #[doc = " \\param type      The desired type."]
    #[doc = ""]
    #[doc = " \\return          1 if the context can do operations on the given type."]
    #[doc = " \\return          0 if the context cannot do the operations on the given"]
    #[doc = "                  type. This is always the case for a context that has"]
    #[doc = "                  been initialized but not set up, or that has been"]
    #[doc = "                  cleared with mbedtls_pk_free()."]
    #[link_name = "\u{1}mbedtls_pk_can_do"]
    pub fn pk_can_do(ctx: *const pk_context, type_: pk_type_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature (including padding if relevant)."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes)"]
    #[doc = " \\param sig       Signature to verify"]
    #[doc = " \\param sig_len   Signature length"]
    #[doc = ""]
    #[doc = " \\return          0 on success (signature is valid),"]
    #[doc = "                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in sig but its length is less than \\p siglen,"]
    #[doc = "                  or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = "                  Use \\c mbedtls_pk_verify_ext( MBEDTLS_PK_RSASSA_PSS, ... )"]
    #[doc = "                  to verify RSASSA_PSS signatures."]
    #[doc = ""]
    #[doc = " \\note            If hash_len is 0, then the length associated with md_alg"]
    #[doc = "                  is used instead, or an error returned if it is invalid."]
    #[doc = ""]
    #[doc = " \\note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0"]
    #[link_name = "\u{1}mbedtls_pk_verify"]
    pub fn pk_verify(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const crate::types::c_uchar,
        hash_len: usize,
        sig: *const crate::types::c_uchar,
        sig_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Restartable version of \\c mbedtls_pk_verify()"]
    #[doc = ""]
    #[doc = " \\note            Performs the same job as \\c mbedtls_pk_verify(), but can"]
    #[doc = "                  return early and restart according to the limit set with"]
    #[doc = "                  \\c mbedtls_ecp_set_max_ops() to reduce blocking for ECC"]
    #[doc = "                  operations. For RSA, same as \\c mbedtls_pk_verify()."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes)"]
    #[doc = " \\param sig       Signature to verify"]
    #[doc = " \\param sig_len   Signature length"]
    #[doc = " \\param rs_ctx    Restart context (NULL to disable restart)"]
    #[doc = ""]
    #[doc = " \\return          See \\c mbedtls_pk_verify(), or"]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[link_name = "\u{1}mbedtls_pk_verify_restartable"]
    pub fn pk_verify_restartable(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const crate::types::c_uchar,
        hash_len: usize,
        sig: *const crate::types::c_uchar,
        sig_len: usize,
        rs_ctx: *mut pk_restart_ctx,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature, with options."]
    #[doc = "                  (Includes verification of the padding depending on type.)"]
    #[doc = ""]
    #[doc = " \\param type      Signature type (inc. possible padding type) to verify"]
    #[doc = " \\param options   Pointer to type-specific options, or NULL"]
    #[doc = " \\param ctx       The PK context to use. It must have been set up."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes)"]
    #[doc = " \\param sig       Signature to verify"]
    #[doc = " \\param sig_len   Signature length"]
    #[doc = ""]
    #[doc = " \\return          0 on success (signature is valid),"]
    #[doc = "                  #MBEDTLS_ERR_PK_TYPE_MISMATCH if the PK context can't be"]
    #[doc = "                  used for this type of signatures,"]
    #[doc = "                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid"]
    #[doc = "                  signature in sig but its length is less than \\p siglen,"]
    #[doc = "                  or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            If hash_len is 0, then the length associated with md_alg"]
    #[doc = "                  is used instead, or an error returned if it is invalid."]
    #[doc = ""]
    #[doc = " \\note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0"]
    #[doc = ""]
    #[doc = " \\note            If type is MBEDTLS_PK_RSASSA_PSS, then options must point"]
    #[doc = "                  to a mbedtls_pk_rsassa_pss_options structure,"]
    #[doc = "                  otherwise it must be NULL."]
    #[link_name = "\u{1}mbedtls_pk_verify_ext"]
    pub fn pk_verify_ext(
        type_: pk_type_t,
        options: *const crate::types::c_void,
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const crate::types::c_uchar,
        hash_len: usize,
        sig: *const crate::types::c_uchar,
        sig_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Make signature, including padding if relevant."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up"]
    #[doc = "                  with a private key."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes)"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes)"]
    #[doc = " \\param sig       Place to write the signature."]
    #[doc = "                  It must have enough room for the signature."]
    #[doc = "                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough."]
    #[doc = "                  You may use a smaller buffer if it is large enough"]
    #[doc = "                  given the key type."]
    #[doc = " \\param sig_len   On successful return,"]
    #[doc = "                  the number of bytes written to \\p sig."]
    #[doc = " \\param f_rng     RNG function"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = "                  There is no interface in the PK module to make RSASSA-PSS"]
    #[doc = "                  signatures yet."]
    #[doc = ""]
    #[doc = " \\note            If hash_len is 0, then the length associated with md_alg"]
    #[doc = "                  is used instead, or an error returned if it is invalid."]
    #[doc = ""]
    #[doc = " \\note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0."]
    #[doc = "                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE."]
    #[link_name = "\u{1}mbedtls_pk_sign"]
    pub fn pk_sign(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const crate::types::c_uchar,
        hash_len: usize,
        sig: *mut crate::types::c_uchar,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Restartable version of \\c mbedtls_pk_sign()"]
    #[doc = ""]
    #[doc = " \\note            Performs the same job as \\c mbedtls_pk_sign(), but can"]
    #[doc = "                  return early and restart according to the limit set with"]
    #[doc = "                  \\c mbedtls_ecp_set_max_ops() to reduce blocking for ECC"]
    #[doc = "                  operations. For RSA, same as \\c mbedtls_pk_sign()."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up"]
    #[doc = "                  with a private key."]
    #[doc = " \\param md_alg    Hash algorithm used (see notes for mbedtls_pk_sign())"]
    #[doc = " \\param hash      Hash of the message to sign"]
    #[doc = " \\param hash_len  Hash length or 0 (see notes for mbedtls_pk_sign())"]
    #[doc = " \\param sig       Place to write the signature."]
    #[doc = "                  It must have enough room for the signature."]
    #[doc = "                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough."]
    #[doc = "                  You may use a smaller buffer if it is large enough"]
    #[doc = "                  given the key type."]
    #[doc = " \\param sig_len   On successful return,"]
    #[doc = "                  the number of bytes written to \\p sig."]
    #[doc = " \\param f_rng     RNG function"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = " \\param rs_ctx    Restart context (NULL to disable restart)"]
    #[doc = ""]
    #[doc = " \\return          See \\c mbedtls_pk_sign()."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[link_name = "\u{1}mbedtls_pk_sign_restartable"]
    pub fn pk_sign_restartable(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const crate::types::c_uchar,
        hash_len: usize,
        sig: *mut crate::types::c_uchar,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        rs_ctx: *mut pk_restart_ctx,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Decrypt message (including padding if relevant)."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up"]
    #[doc = "                  with a private key."]
    #[doc = " \\param input     Input to decrypt"]
    #[doc = " \\param ilen      Input size"]
    #[doc = " \\param output    Decrypted output"]
    #[doc = " \\param olen      Decrypted message length"]
    #[doc = " \\param osize     Size of the output buffer"]
    #[doc = " \\param f_rng     RNG function"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    #[link_name = "\u{1}mbedtls_pk_decrypt"]
    pub fn pk_decrypt(
        ctx: *mut pk_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Encrypt message (including padding if relevant)."]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been set up."]
    #[doc = " \\param input     Message to encrypt"]
    #[doc = " \\param ilen      Message size"]
    #[doc = " \\param output    Encrypted output"]
    #[doc = " \\param olen      Encrypted output length"]
    #[doc = " \\param osize     Size of the output buffer"]
    #[doc = " \\param f_rng     RNG function"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\note            For RSA keys, the default padding type is PKCS#1 v1.5."]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific error code."]
    #[link_name = "\u{1}mbedtls_pk_encrypt"]
    pub fn pk_encrypt(
        ctx: *mut pk_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Check if a public-private pair of keys matches."]
    #[doc = ""]
    #[doc = " \\param pub       Context holding a public key."]
    #[doc = " \\param prv       Context holding a private (and public) key."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success (keys were checked and match each other)."]
    #[doc = " \\return          #MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE if the keys could not"]
    #[doc = "                  be checked - in that case they may or may not match."]
    #[doc = " \\return          #MBEDTLS_ERR_PK_BAD_INPUT_DATA if a context is invalid."]
    #[doc = " \\return          Another non-zero value if the keys do not match."]
    #[link_name = "\u{1}mbedtls_pk_check_pair"]
    pub fn pk_check_pair(pub_: *const pk_context, prv: *const pk_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Export debug information"]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been initialized."]
    #[doc = " \\param items     Place to write debug items"]
    #[doc = ""]
    #[doc = " \\return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA"]
    #[link_name = "\u{1}mbedtls_pk_debug"]
    pub fn pk_debug(ctx: *const pk_context, items: *mut pk_debug_item) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Access the type name"]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been initialized."]
    #[doc = ""]
    #[doc = " \\return          Type name on success, or \"invalid PK\""]
    #[link_name = "\u{1}mbedtls_pk_get_name"]
    pub fn pk_get_name(ctx: *const pk_context) -> *const crate::types::c_char;
}
extern "C" {
    #[doc = " \\brief           Get the key type"]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to use. It must have been initialized."]
    #[doc = ""]
    #[doc = " \\return          Type on success."]
    #[doc = " \\return          #MBEDTLS_PK_NONE for a context that has not been set up."]
    #[link_name = "\u{1}mbedtls_pk_get_type"]
    pub fn pk_get_type(ctx: *const pk_context) -> pk_type_t;
}
extern "C" {
    #[doc = " \\ingroup pk_module */"]
    #[doc = " \\brief           Parse a private key in PEM or DER format"]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to fill. It must have been initialized"]
    #[doc = "                  but not set up."]
    #[doc = " \\param key       Input buffer to parse."]
    #[doc = "                  The buffer must contain the input exactly, with no"]
    #[doc = "                  extra trailing material. For PEM, the buffer must"]
    #[doc = "                  contain a null-terminated string."]
    #[doc = " \\param keylen    Size of \\b key in bytes."]
    #[doc = "                  For PEM data, this includes the terminating null byte,"]
    #[doc = "                  so \\p keylen must be equal to `strlen(key) + 1`."]
    #[doc = " \\param pwd       Optional password for decryption."]
    #[doc = "                  Pass \\c NULL if expecting a non-encrypted key."]
    #[doc = "                  Pass a string of \\p pwdlen bytes if expecting an encrypted"]
    #[doc = "                  key; a non-encrypted key will also be accepted."]
    #[doc = "                  The empty password is not supported."]
    #[doc = " \\param pwdlen    Size of the password in bytes."]
    #[doc = "                  Ignored if \\p pwd is \\c NULL."]
    #[doc = ""]
    #[doc = " \\note            On entry, ctx must be empty, either freshly initialised"]
    #[doc = "                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a"]
    #[doc = "                  specific key type, check the result with mbedtls_pk_can_do()."]
    #[doc = ""]
    #[doc = " \\note            The key is also checked for correctness."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK or PEM error code"]
    #[link_name = "\u{1}mbedtls_pk_parse_key"]
    pub fn pk_parse_key(
        ctx: *mut pk_context,
        key: *const crate::types::c_uchar,
        keylen: usize,
        pwd: *const crate::types::c_uchar,
        pwdlen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\ingroup pk_module */"]
    #[doc = " \\brief           Parse a public key in PEM or DER format"]
    #[doc = ""]
    #[doc = " \\param ctx       The PK context to fill. It must have been initialized"]
    #[doc = "                  but not set up."]
    #[doc = " \\param key       Input buffer to parse."]
    #[doc = "                  The buffer must contain the input exactly, with no"]
    #[doc = "                  extra trailing material. For PEM, the buffer must"]
    #[doc = "                  contain a null-terminated string."]
    #[doc = " \\param keylen    Size of \\b key in bytes."]
    #[doc = "                  For PEM data, this includes the terminating null byte,"]
    #[doc = "                  so \\p keylen must be equal to `strlen(key) + 1`."]
    #[doc = ""]
    #[doc = " \\note            On entry, ctx must be empty, either freshly initialised"]
    #[doc = "                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a"]
    #[doc = "                  specific key type, check the result with mbedtls_pk_can_do()."]
    #[doc = ""]
    #[doc = " \\note            The key is also checked for correctness."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK or PEM error code"]
    #[link_name = "\u{1}mbedtls_pk_parse_public_key"]
    pub fn pk_parse_public_key(
        ctx: *mut pk_context,
        key: *const crate::types::c_uchar,
        keylen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       PK context which must contain a valid private key."]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    #[link_name = "\u{1}mbedtls_pk_write_key_der"]
    pub fn pk_write_key_der(
        ctx: *mut pk_context,
        buf: *mut crate::types::c_uchar,
        size: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a SubjectPublicKeyInfo DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       PK context which must contain a valid public or private key."]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    #[link_name = "\u{1}mbedtls_pk_write_pubkey_der"]
    pub fn pk_write_pubkey_der(
        ctx: *mut pk_context,
        buf: *mut crate::types::c_uchar,
        size: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       PK context which must contain a valid public or private key."]
    #[doc = " \\param buf       Buffer to write to. The output includes a"]
    #[doc = "                  terminating null byte."]
    #[doc = " \\param size      Size of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    #[link_name = "\u{1}mbedtls_pk_write_pubkey_pem"]
    pub fn pk_write_pubkey_pem(
        ctx: *mut pk_context,
        buf: *mut crate::types::c_uchar,
        size: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       PK context which must contain a valid private key."]
    #[doc = " \\param buf       Buffer to write to. The output includes a"]
    #[doc = "                  terminating null byte."]
    #[doc = " \\param size      Size of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    #[link_name = "\u{1}mbedtls_pk_write_key_pem"]
    pub fn pk_write_key_pem(
        ctx: *mut pk_context,
        buf: *mut crate::types::c_uchar,
        size: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Parse a SubjectPublicKeyInfo DER structure"]
    #[doc = ""]
    #[doc = " \\param p         the position in the ASN.1 data"]
    #[doc = " \\param end       end of the buffer"]
    #[doc = " \\param pk        The PK context to fill. It must have been initialized"]
    #[doc = "                  but not set up."]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific PK error code"]
    #[link_name = "\u{1}mbedtls_pk_parse_subpubkey"]
    pub fn pk_parse_subpubkey(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        pk: *mut pk_context,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a subjectPublicKey to ASN.1 data"]
    #[doc = "                  Note: function works backwards in data buffer"]
    #[doc = ""]
    #[doc = " \\param p         reference to current position pointer"]
    #[doc = " \\param start     start of the buffer (for bounds-checking)"]
    #[doc = " \\param key       PK context which must contain a valid public or private key."]
    #[doc = ""]
    #[doc = " \\return          the length written or a negative error code"]
    #[link_name = "\u{1}mbedtls_pk_write_pubkey"]
    pub fn pk_write_pubkey(
        p: *mut *mut crate::types::c_uchar,
        start: *mut crate::types::c_uchar,
        key: *const pk_context,
    ) -> crate::types::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pk_info_t {
    #[doc = " Public key type"]
    pub type_: pk_type_t,
    #[doc = " Type name"]
    pub name: *const crate::types::c_char,
    #[doc = " Get key size in bits"]
    pub get_bitlen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const crate::types::c_void) -> usize>,
    #[doc = " Tell if the context implements this type (e.g. ECKEY can do ECDSA)"]
    pub can_do:
        ::core::option::Option<unsafe extern "C" fn(type_: pk_type_t) -> crate::types::c_int>,
    #[doc = " Verify signature"]
    pub verify_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            md_alg: md_type_t,
            hash: *const crate::types::c_uchar,
            hash_len: usize,
            sig: *const crate::types::c_uchar,
            sig_len: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = " Make signature"]
    pub sign_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            md_alg: md_type_t,
            hash: *const crate::types::c_uchar,
            hash_len: usize,
            sig: *mut crate::types::c_uchar,
            sig_len: *mut usize,
            f_rng: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut crate::types::c_void,
                    arg2: *mut crate::types::c_uchar,
                    arg3: usize,
                ) -> crate::types::c_int,
            >,
            p_rng: *mut crate::types::c_void,
        ) -> crate::types::c_int,
    >,
    #[doc = " Decrypt message"]
    pub decrypt_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            input: *const crate::types::c_uchar,
            ilen: usize,
            output: *mut crate::types::c_uchar,
            olen: *mut usize,
            osize: usize,
            f_rng: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut crate::types::c_void,
                    arg2: *mut crate::types::c_uchar,
                    arg3: usize,
                ) -> crate::types::c_int,
            >,
            p_rng: *mut crate::types::c_void,
        ) -> crate::types::c_int,
    >,
    #[doc = " Encrypt message"]
    pub encrypt_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            input: *const crate::types::c_uchar,
            ilen: usize,
            output: *mut crate::types::c_uchar,
            olen: *mut usize,
            osize: usize,
            f_rng: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut crate::types::c_void,
                    arg2: *mut crate::types::c_uchar,
                    arg3: usize,
                ) -> crate::types::c_int,
            >,
            p_rng: *mut crate::types::c_void,
        ) -> crate::types::c_int,
    >,
    #[doc = " Check public-private key pair"]
    pub check_pair_func: ::core::option::Option<
        unsafe extern "C" fn(
            pub_: *const crate::types::c_void,
            prv: *const crate::types::c_void,
        ) -> crate::types::c_int,
    >,
    #[doc = " Allocate a new context"]
    pub ctx_alloc_func: ::core::option::Option<unsafe extern "C" fn() -> *mut crate::types::c_void>,
    #[doc = " Free the given context"]
    pub ctx_free_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::types::c_void)>,
    #[doc = " Interface with the debug module"]
    pub debug_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *const crate::types::c_void, items: *mut pk_debug_item),
    >,
}
#[test]
fn bindgen_test_layout_pk_info_t() {
    assert_eq!(
        ::core::mem::size_of::<pk_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(pk_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pk_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).get_bitlen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(get_bitlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).can_do as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(can_do)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).verify_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(verify_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).sign_func as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(sign_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).decrypt_func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(decrypt_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).encrypt_func as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(encrypt_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).check_pair_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(check_pair_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).ctx_alloc_func as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(ctx_alloc_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).ctx_free_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(ctx_free_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).debug_func as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(debug_func)
        )
    );
}
impl Default for pk_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_alt_context {
    pub key: *mut crate::types::c_void,
    pub decrypt_func: pk_rsa_alt_decrypt_func,
    pub sign_func: pk_rsa_alt_sign_func,
    pub key_len_func: pk_rsa_alt_key_len_func,
}
#[test]
fn bindgen_test_layout_rsa_alt_context() {
    assert_eq!(
        ::core::mem::size_of::<rsa_alt_context>(),
        16usize,
        concat!("Size of: ", stringify!(rsa_alt_context))
    );
    assert_eq!(
        ::core::mem::align_of::<rsa_alt_context>(),
        4usize,
        concat!("Alignment of ", stringify!(rsa_alt_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_alt_context>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_alt_context>())).decrypt_func as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(decrypt_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_alt_context>())).sign_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(sign_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_alt_context>())).key_len_func as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(key_len_func)
        )
    );
}
impl Default for rsa_alt_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_info"]
    pub static rsa_info: pk_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_eckey_info"]
    pub static eckey_info: pk_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_eckeydh_info"]
    pub static eckeydh_info: pk_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ecdsa_info"]
    pub static ecdsa_info: pk_info_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_rsa_alt_info"]
    pub static rsa_alt_info: pk_info_t;
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
pub type x509_buf = asn1_buf;
#[doc = " Container for ASN1 bit strings."]
pub type x509_bitstring = asn1_bitstring;
#[doc = " Container for ASN1 named information objects."]
#[doc = " It allows for Relative Distinguished Names (e.g. cn=localhost,ou=code,etc.)."]
pub type x509_name = asn1_named_data;
#[doc = " Container for a sequence of ASN.1 items"]
pub type x509_sequence = asn1_sequence;
#[doc = " Container for date and time (precision in seconds)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct x509_time {
    #[doc = "< Date."]
    pub year: crate::types::c_int,
    #[doc = "< Date."]
    pub mon: crate::types::c_int,
    #[doc = "< Date."]
    pub day: crate::types::c_int,
    #[doc = "< Time."]
    pub hour: crate::types::c_int,
    #[doc = "< Time."]
    pub min: crate::types::c_int,
    #[doc = "< Time."]
    pub sec: crate::types::c_int,
}
#[test]
fn bindgen_test_layout_x509_time() {
    assert_eq!(
        ::core::mem::size_of::<x509_time>(),
        24usize,
        concat!("Size of: ", stringify!(x509_time))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_time>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_time))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).mon as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).day as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).hour as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).min as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).sec as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(sec)
        )
    );
}
extern "C" {
    #[doc = " \\brief          Store the certificate DN in printable form into buf;"]
    #[doc = "                 no more than size characters will be written."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param dn       The X509 name to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    #[link_name = "\u{1}mbedtls_x509_dn_gets"]
    pub fn x509_dn_gets(
        buf: *mut crate::types::c_char,
        size: usize,
        dn: *const x509_name,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Store the certificate serial in printable form into buf;"]
    #[doc = "                 no more than size characters will be written."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param serial   The X509 serial to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    #[link_name = "\u{1}mbedtls_x509_serial_gets"]
    pub fn x509_serial_gets(
        buf: *mut crate::types::c_char,
        size: usize,
        serial: *const x509_buf,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time"]
    #[doc = "                 and tell if it's in the past."]
    #[doc = ""]
    #[doc = " \\note           Intended usage is \"if( is_past( valid_to ) ) ERROR\"."]
    #[doc = "                 Hence the return value of 1 if on internal errors."]
    #[doc = ""]
    #[doc = " \\param to       mbedtls_x509_time to check"]
    #[doc = ""]
    #[doc = " \\return         1 if the given time is in the past or an error occurred,"]
    #[doc = "                 0 otherwise."]
    #[link_name = "\u{1}mbedtls_x509_time_is_past"]
    pub fn x509_time_is_past(to: *const x509_time) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time"]
    #[doc = "                 and tell if it's in the future."]
    #[doc = ""]
    #[doc = " \\note           Intended usage is \"if( is_future( valid_from ) ) ERROR\"."]
    #[doc = "                 Hence the return value of 1 if on internal errors."]
    #[doc = ""]
    #[doc = " \\param from     mbedtls_x509_time to check"]
    #[doc = ""]
    #[doc = " \\return         1 if the given time is in the future or an error occurred,"]
    #[doc = "                 0 otherwise."]
    #[link_name = "\u{1}mbedtls_x509_time_is_future"]
    pub fn x509_time_is_future(from: *const x509_time) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[link_name = "\u{1}mbedtls_x509_self_test"]
    pub fn x509_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_name"]
    pub fn x509_get_name(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        cur: *mut x509_name,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_alg_null"]
    pub fn x509_get_alg_null(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        alg: *mut x509_buf,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_alg"]
    pub fn x509_get_alg(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        alg: *mut x509_buf,
        params: *mut x509_buf,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_rsassa_pss_params"]
    pub fn x509_get_rsassa_pss_params(
        params: *const x509_buf,
        md_alg: *mut md_type_t,
        mgf_md: *mut md_type_t,
        salt_len: *mut crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_sig"]
    pub fn x509_get_sig(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        sig: *mut x509_buf,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_sig_alg"]
    pub fn x509_get_sig_alg(
        sig_oid: *const x509_buf,
        sig_params: *const x509_buf,
        md_alg: *mut md_type_t,
        pk_alg: *mut pk_type_t,
        sig_opts: *mut *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_time"]
    pub fn x509_get_time(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        t: *mut x509_time,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_serial"]
    pub fn x509_get_serial(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        serial: *mut x509_buf,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_get_ext"]
    pub fn x509_get_ext(
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        ext: *mut x509_buf,
        tag: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_sig_alg_gets"]
    pub fn x509_sig_alg_gets(
        buf: *mut crate::types::c_char,
        size: usize,
        sig_oid: *const x509_buf,
        pk_alg: pk_type_t,
        md_alg: md_type_t,
        sig_opts: *const crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_key_size_helper"]
    pub fn x509_key_size_helper(
        buf: *mut crate::types::c_char,
        buf_size: usize,
        name: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_string_to_names"]
    pub fn x509_string_to_names(
        head: *mut *mut asn1_named_data,
        name: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_set_extension"]
    pub fn x509_set_extension(
        head: *mut *mut asn1_named_data,
        oid: *const crate::types::c_char,
        oid_len: usize,
        critical: crate::types::c_int,
        val: *const crate::types::c_uchar,
        val_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_write_extensions"]
    pub fn x509_write_extensions(
        p: *mut *mut crate::types::c_uchar,
        start: *mut crate::types::c_uchar,
        first: *mut asn1_named_data,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_write_names"]
    pub fn x509_write_names(
        p: *mut *mut crate::types::c_uchar,
        start: *mut crate::types::c_uchar,
        first: *mut asn1_named_data,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_write_sig"]
    pub fn x509_write_sig(
        p: *mut *mut crate::types::c_uchar,
        start: *mut crate::types::c_uchar,
        oid: *const crate::types::c_char,
        oid_len: usize,
        sig: *mut crate::types::c_uchar,
        size: usize,
    ) -> crate::types::c_int;
}
#[doc = " Certificate Signing Request (CSR) structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_csr {
    #[doc = "< The raw CSR data (DER)."]
    pub raw: x509_buf,
    #[doc = "< The raw CertificateRequestInfo body (DER)."]
    pub cri: x509_buf,
    #[doc = "< CSR version (1=v1)."]
    pub version: crate::types::c_int,
    #[doc = "< The raw subject data (DER)."]
    pub subject_raw: x509_buf,
    #[doc = "< The parsed subject data (named information object)."]
    pub subject: x509_name,
    #[doc = "< Container for the public key context."]
    pub pk: pk_context,
    pub sig_oid: x509_buf,
    pub sig: x509_buf,
    #[doc = "< Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256"]
    pub sig_md: md_type_t,
    #[doc = "< Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA"]
    pub sig_pk: pk_type_t,
    #[doc = "< Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS"]
    pub sig_opts: *mut crate::types::c_void,
}
#[test]
fn bindgen_test_layout_x509_csr() {
    assert_eq!(
        ::core::mem::size_of::<x509_csr>(),
        116usize,
        concat!("Size of: ", stringify!(x509_csr))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_csr>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_csr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).cri as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(cri)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).subject_raw as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(subject_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).subject as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).pk as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig_oid as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig_md as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_md)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig_pk as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig_opts as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_opts)
        )
    );
}
impl Default for x509_csr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Container for writing a CSR"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509write_csr {
    pub key: *mut pk_context,
    pub subject: *mut asn1_named_data,
    pub md_alg: md_type_t,
    pub extensions: *mut asn1_named_data,
}
#[test]
fn bindgen_test_layout_x509write_csr() {
    assert_eq!(
        ::core::mem::size_of::<x509write_csr>(),
        16usize,
        concat!("Size of: ", stringify!(x509write_csr))
    );
    assert_eq!(
        ::core::mem::align_of::<x509write_csr>(),
        4usize,
        concat!("Alignment of ", stringify!(x509write_csr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_csr>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_csr>())).subject as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_csr>())).md_alg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(md_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_csr>())).extensions as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(extensions)
        )
    );
}
impl Default for x509write_csr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Load a Certificate Signing Request (CSR) in DER format"]
    #[doc = ""]
    #[doc = " \\note           CSR attributes (if any) are currently silently ignored."]
    #[doc = ""]
    #[doc = " \\param csr      CSR context to fill"]
    #[doc = " \\param buf      buffer holding the CRL data"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 error code"]
    #[link_name = "\u{1}mbedtls_x509_csr_parse_der"]
    pub fn x509_csr_parse_der(
        csr: *mut x509_csr,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Load a Certificate Signing Request (CSR), DER or PEM format"]
    #[doc = ""]
    #[doc = " \\note           See notes for \\c mbedtls_x509_csr_parse_der()"]
    #[doc = ""]
    #[doc = " \\param csr      CSR context to fill"]
    #[doc = " \\param buf      buffer holding the CRL data"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = "                 (including the terminating null byte for PEM data)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 or PEM error code"]
    #[link_name = "\u{1}mbedtls_x509_csr_parse"]
    pub fn x509_csr_parse(
        csr: *mut x509_csr,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the"]
    #[doc = "                 CSR."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param csr      The X509 CSR to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    #[link_name = "\u{1}mbedtls_x509_csr_info"]
    pub fn x509_csr_info(
        buf: *mut crate::types::c_char,
        size: usize,
        prefix: *const crate::types::c_char,
        csr: *const x509_csr,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a CSR"]
    #[doc = ""]
    #[doc = " \\param csr      CSR to initialize"]
    #[link_name = "\u{1}mbedtls_x509_csr_init"]
    pub fn x509_csr_init(csr: *mut x509_csr);
}
extern "C" {
    #[doc = " \\brief          Unallocate all CSR data"]
    #[doc = ""]
    #[doc = " \\param csr      CSR to free"]
    #[link_name = "\u{1}mbedtls_x509_csr_free"]
    pub fn x509_csr_free(csr: *mut x509_csr);
}
extern "C" {
    #[doc = " \\brief           Initialize a CSR context"]
    #[doc = ""]
    #[doc = " \\param ctx       CSR context to initialize"]
    #[link_name = "\u{1}mbedtls_x509write_csr_init"]
    pub fn x509write_csr_init(ctx: *mut x509write_csr);
}
extern "C" {
    #[doc = " \\brief           Set the subject name for a CSR"]
    #[doc = "                  Subject names should contain a comma-separated list"]
    #[doc = "                  of OID types and values:"]
    #[doc = "                  e.g. \"C=UK,O=ARM,CN=mbed TLS Server 1\""]
    #[doc = ""]
    #[doc = " \\param ctx           CSR context to use"]
    #[doc = " \\param subject_name  subject name to set"]
    #[doc = ""]
    #[doc = " \\return          0 if subject name was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    #[link_name = "\u{1}mbedtls_x509write_csr_set_subject_name"]
    pub fn x509write_csr_set_subject_name(
        ctx: *mut x509write_csr,
        subject_name: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the key for a CSR (public key will be included,"]
    #[doc = "                  private key used to sign the CSR when writing it)"]
    #[doc = ""]
    #[doc = " \\param ctx       CSR context to use"]
    #[doc = " \\param key       Asymetric key to include"]
    #[link_name = "\u{1}mbedtls_x509write_csr_set_key"]
    pub fn x509write_csr_set_key(ctx: *mut x509write_csr, key: *mut pk_context);
}
extern "C" {
    #[doc = " \\brief           Set the MD algorithm to use for the signature"]
    #[doc = "                  (e.g. MBEDTLS_MD_SHA1)"]
    #[doc = ""]
    #[doc = " \\param ctx       CSR context to use"]
    #[doc = " \\param md_alg    MD algorithm to use"]
    #[link_name = "\u{1}mbedtls_x509write_csr_set_md_alg"]
    pub fn x509write_csr_set_md_alg(ctx: *mut x509write_csr, md_alg: md_type_t);
}
extern "C" {
    #[doc = " \\brief           Set the Key Usage Extension flags"]
    #[doc = "                  (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)"]
    #[doc = ""]
    #[doc = " \\param ctx       CSR context to use"]
    #[doc = " \\param key_usage key usage flags to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    #[doc = ""]
    #[doc = " \\note            The <code>decipherOnly</code> flag from the Key Usage"]
    #[doc = "                  extension is represented by bit 8 (i.e."]
    #[doc = "                  <code>0x8000</code>), which cannot typically be represented"]
    #[doc = "                  in an unsigned char. Therefore, the flag"]
    #[doc = "                  <code>decipherOnly</code> (i.e."]
    #[doc = "                  #MBEDTLS_X509_KU_DECIPHER_ONLY) cannot be set using this"]
    #[doc = "                  function."]
    #[link_name = "\u{1}mbedtls_x509write_csr_set_key_usage"]
    pub fn x509write_csr_set_key_usage(
        ctx: *mut x509write_csr,
        key_usage: crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Netscape Cert Type flags"]
    #[doc = "                  (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)"]
    #[doc = ""]
    #[doc = " \\param ctx           CSR context to use"]
    #[doc = " \\param ns_cert_type  Netscape Cert Type flags to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_x509write_csr_set_ns_cert_type"]
    pub fn x509write_csr_set_ns_cert_type(
        ctx: *mut x509write_csr,
        ns_cert_type: crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Generic function to add to or replace an extension in the"]
    #[doc = "                  CSR"]
    #[doc = ""]
    #[doc = " \\param ctx       CSR context to use"]
    #[doc = " \\param oid       OID of the extension"]
    #[doc = " \\param oid_len   length of the OID"]
    #[doc = " \\param val       value of the extension OCTET STRING"]
    #[doc = " \\param val_len   length of the value data"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_x509write_csr_set_extension"]
    pub fn x509write_csr_set_extension(
        ctx: *mut x509write_csr,
        oid: *const crate::types::c_char,
        oid_len: usize,
        val: *const crate::types::c_uchar,
        val_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Free the contents of a CSR context"]
    #[doc = ""]
    #[doc = " \\param ctx       CSR context to free"]
    #[link_name = "\u{1}mbedtls_x509write_csr_free"]
    pub fn x509write_csr_free(ctx: *mut x509write_csr);
}
extern "C" {
    #[doc = " \\brief           Write a CSR (Certificate Signing Request) to a"]
    #[doc = "                  DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       CSR to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = " \\param f_rng     RNG function (for signature, see note)"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    #[doc = ""]
    #[doc = " \\note            f_rng may be NULL if RSA is used for signature and the"]
    #[doc = "                  signature is made offline (otherwise f_rng is desirable"]
    #[doc = "                  for countermeasures against timing attacks)."]
    #[doc = "                  ECDSA signatures always require a non-NULL f_rng."]
    #[link_name = "\u{1}mbedtls_x509write_csr_der"]
    pub fn x509write_csr_der(
        ctx: *mut x509write_csr,
        buf: *mut crate::types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a CSR (Certificate Signing Request) to a"]
    #[doc = "                  PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       CSR to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = " \\param f_rng     RNG function (for signature, see note)"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    #[doc = ""]
    #[doc = " \\note            f_rng may be NULL if RSA is used for signature and the"]
    #[doc = "                  signature is made offline (otherwise f_rng is desirable"]
    #[doc = "                  for countermeasures against timing attacks)."]
    #[doc = "                  ECDSA signatures always require a non-NULL f_rng."]
    #[link_name = "\u{1}mbedtls_x509write_csr_pem"]
    pub fn x509write_csr_pem(
        ctx: *mut x509write_csr,
        buf: *mut crate::types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       Securely zeroize a buffer"]
    #[doc = ""]
    #[doc = "              The function is meant to wipe the data contained in a buffer so"]
    #[doc = "              that it can no longer be recovered even if the program memory"]
    #[doc = "              is later compromised. Call this function on sensitive data"]
    #[doc = "              stored on the stack before returning from a function, and on"]
    #[doc = "              sensitive data stored on the heap before freeing the heap"]
    #[doc = "              object."]
    #[doc = ""]
    #[doc = "              It is extremely difficult to guarantee that calls to"]
    #[doc = "              mbedtls_platform_zeroize() are not removed by aggressive"]
    #[doc = "              compiler optimizations in a portable way. For this reason, Mbed"]
    #[doc = "              TLS provides the configuration option"]
    #[doc = "              MBEDTLS_PLATFORM_ZEROIZE_ALT, which allows users to configure"]
    #[doc = "              mbedtls_platform_zeroize() to use a suitable implementation for"]
    #[doc = "              their platform and needs"]
    #[doc = ""]
    #[doc = " \\param buf   Buffer to be zeroized"]
    #[doc = " \\param len   Length of the buffer in bytes"]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_platform_zeroize"]
    pub fn platform_zeroize(buf: *mut crate::types::c_void, len: usize);
}
#[repr(u32)]
#[doc = " \\brief     Supported cipher types."]
#[doc = ""]
#[doc = " \\warning   RC4 and DES are considered weak ciphers and their use"]
#[doc = "            constitutes a security risk. Arm recommends considering stronger"]
#[doc = "            ciphers instead."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cipher_id_t {
    #[doc = "< Placeholder to mark the end of cipher ID lists."]
    CIPHER_ID_NONE = 0,
    #[doc = "< The identity cipher, treated as a stream cipher."]
    CIPHER_ID_NULL = 1,
    #[doc = "< The AES cipher."]
    CIPHER_ID_AES = 2,
    #[doc = "< The DES cipher."]
    CIPHER_ID_DES = 3,
    #[doc = "< The Triple DES cipher."]
    CIPHER_ID_3DES = 4,
    #[doc = "< The Camellia cipher."]
    CIPHER_ID_CAMELLIA = 5,
    #[doc = "< The Blowfish cipher."]
    CIPHER_ID_BLOWFISH = 6,
    #[doc = "< The RC4 cipher."]
    CIPHER_ID_ARC4 = 7,
    #[doc = "< The Aria cipher."]
    CIPHER_ID_ARIA = 8,
    #[doc = "< The ChaCha20 cipher."]
    CIPHER_ID_CHACHA20 = 9,
}
#[repr(u32)]
#[doc = " \\brief     Supported {cipher type, cipher mode} pairs."]
#[doc = ""]
#[doc = " \\warning   RC4 and DES are considered weak ciphers and their use"]
#[doc = "            constitutes a security risk. Arm recommends considering stronger"]
#[doc = "            ciphers instead."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cipher_type_t {
    #[doc = "< Placeholder to mark the end of cipher-pair lists."]
    CIPHER_NONE = 0,
    #[doc = "< The identity stream cipher."]
    CIPHER_NULL = 1,
    #[doc = "< AES cipher with 128-bit ECB mode."]
    CIPHER_AES_128_ECB = 2,
    #[doc = "< AES cipher with 192-bit ECB mode."]
    CIPHER_AES_192_ECB = 3,
    #[doc = "< AES cipher with 256-bit ECB mode."]
    CIPHER_AES_256_ECB = 4,
    #[doc = "< AES cipher with 128-bit CBC mode."]
    CIPHER_AES_128_CBC = 5,
    #[doc = "< AES cipher with 192-bit CBC mode."]
    CIPHER_AES_192_CBC = 6,
    #[doc = "< AES cipher with 256-bit CBC mode."]
    CIPHER_AES_256_CBC = 7,
    #[doc = "< AES cipher with 128-bit CFB128 mode."]
    CIPHER_AES_128_CFB128 = 8,
    #[doc = "< AES cipher with 192-bit CFB128 mode."]
    CIPHER_AES_192_CFB128 = 9,
    #[doc = "< AES cipher with 256-bit CFB128 mode."]
    CIPHER_AES_256_CFB128 = 10,
    #[doc = "< AES cipher with 128-bit CTR mode."]
    CIPHER_AES_128_CTR = 11,
    #[doc = "< AES cipher with 192-bit CTR mode."]
    CIPHER_AES_192_CTR = 12,
    #[doc = "< AES cipher with 256-bit CTR mode."]
    CIPHER_AES_256_CTR = 13,
    #[doc = "< AES cipher with 128-bit GCM mode."]
    CIPHER_AES_128_GCM = 14,
    #[doc = "< AES cipher with 192-bit GCM mode."]
    CIPHER_AES_192_GCM = 15,
    #[doc = "< AES cipher with 256-bit GCM mode."]
    CIPHER_AES_256_GCM = 16,
    #[doc = "< Camellia cipher with 128-bit ECB mode."]
    CIPHER_CAMELLIA_128_ECB = 17,
    #[doc = "< Camellia cipher with 192-bit ECB mode."]
    CIPHER_CAMELLIA_192_ECB = 18,
    #[doc = "< Camellia cipher with 256-bit ECB mode."]
    CIPHER_CAMELLIA_256_ECB = 19,
    #[doc = "< Camellia cipher with 128-bit CBC mode."]
    CIPHER_CAMELLIA_128_CBC = 20,
    #[doc = "< Camellia cipher with 192-bit CBC mode."]
    CIPHER_CAMELLIA_192_CBC = 21,
    #[doc = "< Camellia cipher with 256-bit CBC mode."]
    CIPHER_CAMELLIA_256_CBC = 22,
    #[doc = "< Camellia cipher with 128-bit CFB128 mode."]
    CIPHER_CAMELLIA_128_CFB128 = 23,
    #[doc = "< Camellia cipher with 192-bit CFB128 mode."]
    CIPHER_CAMELLIA_192_CFB128 = 24,
    #[doc = "< Camellia cipher with 256-bit CFB128 mode."]
    CIPHER_CAMELLIA_256_CFB128 = 25,
    #[doc = "< Camellia cipher with 128-bit CTR mode."]
    CIPHER_CAMELLIA_128_CTR = 26,
    #[doc = "< Camellia cipher with 192-bit CTR mode."]
    CIPHER_CAMELLIA_192_CTR = 27,
    #[doc = "< Camellia cipher with 256-bit CTR mode."]
    CIPHER_CAMELLIA_256_CTR = 28,
    #[doc = "< Camellia cipher with 128-bit GCM mode."]
    CIPHER_CAMELLIA_128_GCM = 29,
    #[doc = "< Camellia cipher with 192-bit GCM mode."]
    CIPHER_CAMELLIA_192_GCM = 30,
    #[doc = "< Camellia cipher with 256-bit GCM mode."]
    CIPHER_CAMELLIA_256_GCM = 31,
    #[doc = "< DES cipher with ECB mode."]
    CIPHER_DES_ECB = 32,
    #[doc = "< DES cipher with CBC mode."]
    CIPHER_DES_CBC = 33,
    #[doc = "< DES cipher with EDE ECB mode."]
    CIPHER_DES_EDE_ECB = 34,
    #[doc = "< DES cipher with EDE CBC mode."]
    CIPHER_DES_EDE_CBC = 35,
    #[doc = "< DES cipher with EDE3 ECB mode."]
    CIPHER_DES_EDE3_ECB = 36,
    #[doc = "< DES cipher with EDE3 CBC mode."]
    CIPHER_DES_EDE3_CBC = 37,
    #[doc = "< Blowfish cipher with ECB mode."]
    CIPHER_BLOWFISH_ECB = 38,
    #[doc = "< Blowfish cipher with CBC mode."]
    CIPHER_BLOWFISH_CBC = 39,
    #[doc = "< Blowfish cipher with CFB64 mode."]
    CIPHER_BLOWFISH_CFB64 = 40,
    #[doc = "< Blowfish cipher with CTR mode."]
    CIPHER_BLOWFISH_CTR = 41,
    #[doc = "< RC4 cipher with 128-bit mode."]
    CIPHER_ARC4_128 = 42,
    #[doc = "< AES cipher with 128-bit CCM mode."]
    CIPHER_AES_128_CCM = 43,
    #[doc = "< AES cipher with 192-bit CCM mode."]
    CIPHER_AES_192_CCM = 44,
    #[doc = "< AES cipher with 256-bit CCM mode."]
    CIPHER_AES_256_CCM = 45,
    #[doc = "< Camellia cipher with 128-bit CCM mode."]
    CIPHER_CAMELLIA_128_CCM = 46,
    #[doc = "< Camellia cipher with 192-bit CCM mode."]
    CIPHER_CAMELLIA_192_CCM = 47,
    #[doc = "< Camellia cipher with 256-bit CCM mode."]
    CIPHER_CAMELLIA_256_CCM = 48,
    #[doc = "< Aria cipher with 128-bit key and ECB mode."]
    CIPHER_ARIA_128_ECB = 49,
    #[doc = "< Aria cipher with 192-bit key and ECB mode."]
    CIPHER_ARIA_192_ECB = 50,
    #[doc = "< Aria cipher with 256-bit key and ECB mode."]
    CIPHER_ARIA_256_ECB = 51,
    #[doc = "< Aria cipher with 128-bit key and CBC mode."]
    CIPHER_ARIA_128_CBC = 52,
    #[doc = "< Aria cipher with 192-bit key and CBC mode."]
    CIPHER_ARIA_192_CBC = 53,
    #[doc = "< Aria cipher with 256-bit key and CBC mode."]
    CIPHER_ARIA_256_CBC = 54,
    #[doc = "< Aria cipher with 128-bit key and CFB-128 mode."]
    CIPHER_ARIA_128_CFB128 = 55,
    #[doc = "< Aria cipher with 192-bit key and CFB-128 mode."]
    CIPHER_ARIA_192_CFB128 = 56,
    #[doc = "< Aria cipher with 256-bit key and CFB-128 mode."]
    CIPHER_ARIA_256_CFB128 = 57,
    #[doc = "< Aria cipher with 128-bit key and CTR mode."]
    CIPHER_ARIA_128_CTR = 58,
    #[doc = "< Aria cipher with 192-bit key and CTR mode."]
    CIPHER_ARIA_192_CTR = 59,
    #[doc = "< Aria cipher with 256-bit key and CTR mode."]
    CIPHER_ARIA_256_CTR = 60,
    #[doc = "< Aria cipher with 128-bit key and GCM mode."]
    CIPHER_ARIA_128_GCM = 61,
    #[doc = "< Aria cipher with 192-bit key and GCM mode."]
    CIPHER_ARIA_192_GCM = 62,
    #[doc = "< Aria cipher with 256-bit key and GCM mode."]
    CIPHER_ARIA_256_GCM = 63,
    #[doc = "< Aria cipher with 128-bit key and CCM mode."]
    CIPHER_ARIA_128_CCM = 64,
    #[doc = "< Aria cipher with 192-bit key and CCM mode."]
    CIPHER_ARIA_192_CCM = 65,
    #[doc = "< Aria cipher with 256-bit key and CCM mode."]
    CIPHER_ARIA_256_CCM = 66,
    #[doc = "< AES 128-bit cipher in OFB mode."]
    CIPHER_AES_128_OFB = 67,
    #[doc = "< AES 192-bit cipher in OFB mode."]
    CIPHER_AES_192_OFB = 68,
    #[doc = "< AES 256-bit cipher in OFB mode."]
    CIPHER_AES_256_OFB = 69,
    #[doc = "< AES 128-bit cipher in XTS block mode."]
    CIPHER_AES_128_XTS = 70,
    #[doc = "< AES 256-bit cipher in XTS block mode."]
    CIPHER_AES_256_XTS = 71,
    #[doc = "< ChaCha20 stream cipher."]
    CIPHER_CHACHA20 = 72,
    #[doc = "< ChaCha20-Poly1305 AEAD cipher."]
    CIPHER_CHACHA20_POLY1305 = 73,
    #[doc = "< AES cipher with 128-bit NIST KW mode."]
    CIPHER_AES_128_KW = 74,
    #[doc = "< AES cipher with 192-bit NIST KW mode."]
    CIPHER_AES_192_KW = 75,
    #[doc = "< AES cipher with 256-bit NIST KW mode."]
    CIPHER_AES_256_KW = 76,
    #[doc = "< AES cipher with 128-bit NIST KWP mode."]
    CIPHER_AES_128_KWP = 77,
    #[doc = "< AES cipher with 192-bit NIST KWP mode."]
    CIPHER_AES_192_KWP = 78,
    #[doc = "< AES cipher with 256-bit NIST KWP mode."]
    CIPHER_AES_256_KWP = 79,
}
#[repr(u32)]
#[doc = " Supported cipher modes."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cipher_mode_t {
    #[doc = "< None."]
    MODE_NONE = 0,
    #[doc = "< The ECB cipher mode."]
    MODE_ECB = 1,
    #[doc = "< The CBC cipher mode."]
    MODE_CBC = 2,
    #[doc = "< The CFB cipher mode."]
    MODE_CFB = 3,
    #[doc = "< The OFB cipher mode."]
    MODE_OFB = 4,
    #[doc = "< The CTR cipher mode."]
    MODE_CTR = 5,
    #[doc = "< The GCM cipher mode."]
    MODE_GCM = 6,
    #[doc = "< The stream cipher mode."]
    MODE_STREAM = 7,
    #[doc = "< The CCM cipher mode."]
    MODE_CCM = 8,
    #[doc = "< The XTS cipher mode."]
    MODE_XTS = 9,
    #[doc = "< The ChaCha-Poly cipher mode."]
    MODE_CHACHAPOLY = 10,
    #[doc = "< The SP800-38F KW mode"]
    MODE_KW = 11,
    #[doc = "< The SP800-38F KWP mode"]
    MODE_KWP = 12,
}
#[repr(u32)]
#[doc = " Supported cipher padding types."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cipher_padding_t {
    #[doc = "< PKCS7 padding (default)."]
    PADDING_PKCS7 = 0,
    #[doc = "< ISO/IEC 7816-4 padding."]
    PADDING_ONE_AND_ZEROS = 1,
    #[doc = "< ANSI X.923 padding."]
    PADDING_ZEROS_AND_LEN = 2,
    #[doc = "< Zero padding (not reversible)."]
    PADDING_ZEROS = 3,
    #[doc = "< Never pad (full blocks only)."]
    PADDING_NONE = 4,
}
#[repr(i32)]
#[doc = " Type of operation."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum operation_t {
    OPERATION_NONE = -1,
    DECRYPT = 0,
    ENCRYPT = 1,
}
pub const KEY_LENGTH_NONE: _bindgen_ty_1 = _bindgen_ty_1::KEY_LENGTH_NONE;
pub const KEY_LENGTH_DES: _bindgen_ty_1 = _bindgen_ty_1::KEY_LENGTH_DES;
pub const KEY_LENGTH_DES_EDE: _bindgen_ty_1 = _bindgen_ty_1::KEY_LENGTH_DES_EDE;
pub const KEY_LENGTH_DES_EDE3: _bindgen_ty_1 = _bindgen_ty_1::KEY_LENGTH_DES_EDE3;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    #[doc = " Undefined key length."]
    KEY_LENGTH_NONE = 0,
    #[doc = " Key length, in bits (including parity), for DES keys."]
    KEY_LENGTH_DES = 64,
    #[doc = " Key length in bits, including parity, for DES in two-key EDE."]
    KEY_LENGTH_DES_EDE = 128,
    #[doc = " Key length in bits, including parity, for DES in three-key EDE."]
    KEY_LENGTH_DES_EDE3 = 192,
}
#[doc = " Cipher information. Allows calling cipher functions"]
#[doc = " in a generic way."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cipher_info_t {
    #[doc = " Full cipher identifier. For example,"]
    #[doc = " MBEDTLS_CIPHER_AES_256_CBC."]
    pub type_: cipher_type_t,
    #[doc = " The cipher mode. For example, MBEDTLS_MODE_CBC."]
    pub mode: cipher_mode_t,
    #[doc = " The cipher key length, in bits. This is the"]
    #[doc = " default length for variable sized ciphers."]
    #[doc = " Includes parity bits for ciphers like DES."]
    pub key_bitlen: crate::types::c_uint,
    #[doc = " Name of the cipher."]
    pub name: *const crate::types::c_char,
    #[doc = " IV or nonce size, in Bytes."]
    #[doc = " For ciphers that accept variable IV sizes,"]
    #[doc = " this is the recommended size."]
    pub iv_size: crate::types::c_uint,
    #[doc = " Bitflag comprised of MBEDTLS_CIPHER_VARIABLE_IV_LEN and"]
    #[doc = "  MBEDTLS_CIPHER_VARIABLE_KEY_LEN indicating whether the"]
    #[doc = "  cipher supports variable IV or variable key sizes, respectively."]
    pub flags: crate::types::c_int,
    #[doc = " The block size, in Bytes."]
    pub block_size: crate::types::c_uint,
    #[doc = " Struct for base cipher information and functions."]
    pub base: *const cipher_base_t,
}
#[test]
fn bindgen_test_layout_cipher_info_t() {
    assert_eq!(
        ::core::mem::size_of::<cipher_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(cipher_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cipher_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).key_bitlen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).name as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).iv_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).block_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).base as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(base)
        )
    );
}
impl Default for cipher_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Generic cipher context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cipher_context_t {
    #[doc = " Information about the associated cipher."]
    pub cipher_info: *const cipher_info_t,
    #[doc = " Key length to use."]
    pub key_bitlen: crate::types::c_int,
    #[doc = " Operation that the key of the context has been"]
    #[doc = " initialized for."]
    pub operation: operation_t,
    #[doc = " Padding functions to use, if relevant for"]
    #[doc = " the specific cipher mode."]
    pub add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut crate::types::c_uchar, olen: usize, data_len: usize),
    >,
    pub get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut crate::types::c_uchar,
            ilen: usize,
            data_len: *mut usize,
        ) -> crate::types::c_int,
    >,
    #[doc = " Buffer for input that has not been processed yet."]
    pub unprocessed_data: [crate::types::c_uchar; 16usize],
    #[doc = " Number of Bytes that have not been processed yet."]
    pub unprocessed_len: usize,
    #[doc = " Current IV or NONCE_COUNTER for CTR-mode, data unit (or sector) number"]
    #[doc = " for XTS-mode."]
    pub iv: [crate::types::c_uchar; 16usize],
    #[doc = " IV size in Bytes, for ciphers with variable-length IVs."]
    pub iv_size: usize,
    #[doc = " The cipher-specific context."]
    pub cipher_ctx: *mut crate::types::c_void,
}
#[test]
fn bindgen_test_layout_cipher_context_t() {
    assert_eq!(
        ::core::mem::size_of::<cipher_context_t>(),
        64usize,
        concat!("Size of: ", stringify!(cipher_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_context_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cipher_context_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).cipher_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(cipher_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).key_bitlen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).operation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).add_padding as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(add_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).get_padding as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(get_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cipher_context_t>())).unprocessed_data as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(unprocessed_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cipher_context_t>())).unprocessed_len as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(unprocessed_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).iv as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).iv_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).cipher_ctx as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(cipher_ctx)
        )
    );
}
impl Default for cipher_context_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief This function retrieves the list of ciphers supported"]
    #[doc = "        by the generic cipher module."]
    #[doc = ""]
    #[doc = "        For any cipher identifier in the returned list, you can"]
    #[doc = "        obtain the corresponding generic cipher information structure"]
    #[doc = "        via mbedtls_cipher_info_from_type(), which can then be used"]
    #[doc = "        to prepare a cipher context via mbedtls_cipher_setup()."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\return      A statically-allocated array of cipher identifiers"]
    #[doc = "              of type cipher_type_t. The last entry is zero."]
    #[link_name = "\u{1}mbedtls_cipher_list"]
    pub fn cipher_list() -> *const crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information"]
    #[doc = "                      structure associated with the given cipher name."]
    #[doc = ""]
    #[doc = " \\param cipher_name   Name of the cipher to search for. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = ""]
    #[doc = " \\return              The cipher information structure associated with the"]
    #[doc = "                      given \\p cipher_name."]
    #[doc = " \\return              \\c NULL if the associated cipher information is not found."]
    #[link_name = "\u{1}mbedtls_cipher_info_from_string"]
    pub fn cipher_info_from_string(
        cipher_name: *const crate::types::c_char,
    ) -> *const cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information"]
    #[doc = "                      structure associated with the given cipher type."]
    #[doc = ""]
    #[doc = " \\param cipher_type   Type of the cipher to search for."]
    #[doc = ""]
    #[doc = " \\return              The cipher information structure associated with the"]
    #[doc = "                      given \\p cipher_type."]
    #[doc = " \\return              \\c NULL if the associated cipher information is not found."]
    #[link_name = "\u{1}mbedtls_cipher_info_from_type"]
    pub fn cipher_info_from_type(cipher_type: cipher_type_t) -> *const cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information"]
    #[doc = "                      structure associated with the given cipher ID,"]
    #[doc = "                      key size and mode."]
    #[doc = ""]
    #[doc = " \\param cipher_id     The ID of the cipher to search for. For example,"]
    #[doc = "                      #MBEDTLS_CIPHER_ID_AES."]
    #[doc = " \\param key_bitlen    The length of the key in bits."]
    #[doc = " \\param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC."]
    #[doc = ""]
    #[doc = " \\return              The cipher information structure associated with the"]
    #[doc = "                      given \\p cipher_id."]
    #[doc = " \\return              \\c NULL if the associated cipher information is not found."]
    #[link_name = "\u{1}mbedtls_cipher_info_from_values"]
    pub fn cipher_info_from_values(
        cipher_id: cipher_id_t,
        key_bitlen: crate::types::c_int,
        mode: cipher_mode_t,
    ) -> *const cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function initializes a \\p cipher_context as NONE."]
    #[doc = ""]
    #[doc = " \\param ctx           The context to be initialized. This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_cipher_init"]
    pub fn cipher_init(ctx: *mut cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function frees and clears the cipher-specific"]
    #[doc = "                      context of \\p ctx. Freeing \\p ctx itself remains the"]
    #[doc = "                      responsibility of the caller."]
    #[doc = ""]
    #[doc = " \\param ctx           The context to be freed. If this is \\c NULL, the"]
    #[doc = "                      function has no effect, otherwise this must point to an"]
    #[doc = "                      initialized context."]
    #[link_name = "\u{1}mbedtls_cipher_free"]
    pub fn cipher_free(ctx: *mut cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function initializes a cipher context for"]
    #[doc = "                      use with the given cipher primitive."]
    #[doc = ""]
    #[doc = " \\param ctx           The context to initialize. This must be initialized."]
    #[doc = " \\param cipher_info   The cipher to use."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the"]
    #[doc = "                      cipher-specific context fails."]
    #[doc = ""]
    #[doc = " \\internal Currently, the function also clears the structure."]
    #[doc = " In future versions, the caller will be required to call"]
    #[doc = " mbedtls_cipher_init() on the structure first."]
    #[link_name = "\u{1}mbedtls_cipher_setup"]
    pub fn cipher_setup(
        ctx: *mut cipher_context_t,
        cipher_info: *const cipher_info_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the key to use with the given context."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a cipher information structure."]
    #[doc = " \\param key           The key to use. This must be a readable buffer of at"]
    #[doc = "                      least \\p key_bitlen Bits."]
    #[doc = " \\param key_bitlen    The key length to use, in Bits."]
    #[doc = " \\param operation     The operation that the key will be used for:"]
    #[doc = "                      #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_setkey"]
    pub fn cipher_setkey(
        ctx: *mut cipher_context_t,
        key: *const crate::types::c_uchar,
        key_bitlen: crate::types::c_int,
        operation: operation_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the padding mode, for cipher modes"]
    #[doc = "                      that use padding."]
    #[doc = ""]
    #[doc = "                      The default passing mode is PKCS7 padding."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a cipher information structure."]
    #[doc = " \\param mode          The padding mode."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE"]
    #[doc = "                      if the selected padding mode is not supported."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode"]
    #[doc = "                      does not support padding."]
    #[link_name = "\u{1}mbedtls_cipher_set_padding_mode"]
    pub fn cipher_set_padding_mode(
        ctx: *mut cipher_context_t,
        mode: cipher_padding_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the initialization vector (IV)"]
    #[doc = "                  or nonce."]
    #[doc = ""]
    #[doc = " \\note            Some ciphers do not use IVs nor nonce. For these"]
    #[doc = "                  ciphers, this function has no effect."]
    #[doc = ""]
    #[doc = " \\param ctx       The generic cipher context. This must be initialized and"]
    #[doc = "                  bound to a cipher information structure."]
    #[doc = " \\param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers. This"]
    #[doc = "                  must be a readable buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The IV length for ciphers with variable-size IV."]
    #[doc = "                  This parameter is discarded by ciphers with fixed-size IV."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                  parameter-verification failure."]
    #[link_name = "\u{1}mbedtls_cipher_set_iv"]
    pub fn cipher_set_iv(
        ctx: *mut cipher_context_t,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief         This function resets the cipher state."]
    #[doc = ""]
    #[doc = " \\param ctx     The generic cipher context. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return        \\c 0 on success."]
    #[doc = " \\return        #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                parameter-verification failure."]
    #[link_name = "\u{1}mbedtls_cipher_reset"]
    pub fn cipher_reset(ctx: *mut cipher_context_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function adds additional data for AEAD ciphers."]
    #[doc = "                      Currently supported with GCM and ChaCha20+Poly1305."]
    #[doc = "                      This must be called exactly once, after"]
    #[doc = "                      mbedtls_cipher_reset()."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized."]
    #[doc = " \\param ad            The additional data to use. This must be a readable"]
    #[doc = "                      buffer of at least \\p ad_len Bytes."]
    #[doc = " \\param ad_len        The length of \\p ad in Bytes."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_update_ad"]
    pub fn cipher_update_ad(
        ctx: *mut cipher_context_t,
        ad: *const crate::types::c_uchar,
        ad_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher update function. It encrypts or"]
    #[doc = "                      decrypts using the given cipher context. Writes as"]
    #[doc = "                      many block-sized blocks of data as possible to output."]
    #[doc = "                      Any data that cannot be written immediately is either"]
    #[doc = "                      added to the next block, or flushed when"]
    #[doc = "                      mbedtls_cipher_finish() is called."]
    #[doc = "                      Exception: For MBEDTLS_MODE_ECB, expects a single block"]
    #[doc = "                      in size. For example, 16 Bytes for AES."]
    #[doc = ""]
    #[doc = " \\note                If the underlying cipher is used in GCM mode, all calls"]
    #[doc = "                      to this function, except for the last one before"]
    #[doc = "                      mbedtls_cipher_finish(), must have \\p ilen as a"]
    #[doc = "                      multiple of the block size of the cipher."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a key."]
    #[doc = " \\param input         The buffer holding the input data. This must be a"]
    #[doc = "                      readable buffer of at least \\p ilen Bytes."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the output data. This must be able to"]
    #[doc = "                      hold at least `ilen + block_size`. This must not be the"]
    #[doc = "                      same buffer as \\p input."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an"]
    #[doc = "                      unsupported mode for a cipher."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_update"]
    pub fn cipher_update(
        ctx: *mut cipher_context_t,
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher finalization function. If data still"]
    #[doc = "                      needs to be flushed from an incomplete block, the data"]
    #[doc = "                      contained in it is padded to the size of"]
    #[doc = "                      the last block, and written to the \\p output buffer."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a key."]
    #[doc = " \\param output        The buffer to write data to. This needs to be a writable"]
    #[doc = "                      buffer of at least \\p block_size Bytes."]
    #[doc = " \\param olen          The length of the data written to the \\p output buffer."]
    #[doc = "                      This may not be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption"]
    #[doc = "                      expecting a full block but not receiving one."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding"]
    #[doc = "                      while decrypting."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_finish"]
    pub fn cipher_finish(
        ctx: *mut cipher_context_t,
        output: *mut crate::types::c_uchar,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function writes a tag for AEAD ciphers."]
    #[doc = "                      Currently supported with GCM and ChaCha20+Poly1305."]
    #[doc = "                      This must be called after mbedtls_cipher_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized,"]
    #[doc = "                      bound to a key, and have just completed a cipher"]
    #[doc = "                      operation through mbedtls_cipher_finish() the tag for"]
    #[doc = "                      which should be written."]
    #[doc = " \\param tag           The buffer to write the tag to. This must be a writable"]
    #[doc = "                      buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len       The length of the tag to write."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_write_tag"]
    pub fn cipher_write_tag(
        ctx: *mut cipher_context_t,
        tag: *mut crate::types::c_uchar,
        tag_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function checks the tag for AEAD ciphers."]
    #[doc = "                      Currently supported with GCM and ChaCha20+Poly1305."]
    #[doc = "                      This must be called after mbedtls_cipher_finish()."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized."]
    #[doc = " \\param tag           The buffer holding the tag. This must be a readable"]
    #[doc = "                      buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len       The length of the tag to check."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_check_tag"]
    pub fn cipher_check_tag(
        ctx: *mut cipher_context_t,
        tag: *const crate::types::c_uchar,
        tag_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic all-in-one encryption/decryption function,"]
    #[doc = "                      for all ciphers except AEAD constructs."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized."]
    #[doc = " \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers."]
    #[doc = "                      This must be a readable buffer of at least \\p iv_len"]
    #[doc = "                      Bytes."]
    #[doc = " \\param iv_len        The IV length for ciphers with variable-size IV."]
    #[doc = "                      This parameter is discarded by ciphers with fixed-size"]
    #[doc = "                      IV."]
    #[doc = " \\param input         The buffer holding the input data. This must be a"]
    #[doc = "                      readable buffer of at least \\p ilen Bytes."]
    #[doc = " \\param ilen          The length of the input data in Bytes."]
    #[doc = " \\param output        The buffer for the output data. This must be able to"]
    #[doc = "                      hold at least `ilen + block_size`. This must not be the"]
    #[doc = "                      same buffer as \\p input."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = ""]
    #[doc = " \\note                Some ciphers do not use IVs nor nonce. For these"]
    #[doc = "                      ciphers, use \\p iv = NULL and \\p iv_len = 0."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption"]
    #[doc = "                      expecting a full block but not receiving one."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding"]
    #[doc = "                      while decrypting."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_crypt"]
    pub fn cipher_crypt(
        ctx: *mut cipher_context_t,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic autenticated encryption (AEAD) function."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      bound to a key."]
    #[doc = " \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers."]
    #[doc = "                      This must be a readable buffer of at least \\p iv_len"]
    #[doc = "                      Bytes."]
    #[doc = " \\param iv_len        The IV length for ciphers with variable-size IV."]
    #[doc = "                      This parameter is discarded by ciphers with fixed-size IV."]
    #[doc = " \\param ad            The additional data to authenticate. This must be a"]
    #[doc = "                      readable buffer of at least \\p ad_len Bytes."]
    #[doc = " \\param ad_len        The length of \\p ad."]
    #[doc = " \\param input         The buffer holding the input data. This must be a"]
    #[doc = "                      readable buffer of at least \\p ilen Bytes."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the output data. This must be able to"]
    #[doc = "                      hold at least \\p ilen Bytes."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = " \\param tag           The buffer for the authentication tag. This must be a"]
    #[doc = "                      writable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len       The desired length of the authentication tag."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_auth_encrypt"]
    pub fn cipher_auth_encrypt(
        ctx: *mut cipher_context_t,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        ad: *const crate::types::c_uchar,
        ad_len: usize,
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        olen: *mut usize,
        tag: *mut crate::types::c_uchar,
        tag_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic autenticated decryption (AEAD) function."]
    #[doc = ""]
    #[doc = " \\note                If the data is not authentic, then the output buffer"]
    #[doc = "                      is zeroed out to prevent the unauthentic plaintext being"]
    #[doc = "                      used, making this interface safer."]
    #[doc = ""]
    #[doc = " \\param ctx           The generic cipher context. This must be initialized and"]
    #[doc = "                      and bound to a key."]
    #[doc = " \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers."]
    #[doc = "                      This must be a readable buffer of at least \\p iv_len"]
    #[doc = "                      Bytes."]
    #[doc = " \\param iv_len        The IV length for ciphers with variable-size IV."]
    #[doc = "                      This parameter is discarded by ciphers with fixed-size IV."]
    #[doc = " \\param ad            The additional data to be authenticated. This must be a"]
    #[doc = "                      readable buffer of at least \\p ad_len Bytes."]
    #[doc = " \\param ad_len        The length of \\p ad."]
    #[doc = " \\param input         The buffer holding the input data. This must be a"]
    #[doc = "                      readable buffer of at least \\p ilen Bytes."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the output data."]
    #[doc = "                      This must be able to hold at least \\p ilen Bytes."]
    #[doc = " \\param olen          The length of the output data, to be updated with the"]
    #[doc = "                      actual number of Bytes written. This must not be"]
    #[doc = "                      \\c NULL."]
    #[doc = " \\param tag           The buffer holding the authentication tag. This must be"]
    #[doc = "                      a readable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len       The length of the authentication tag."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on"]
    #[doc = "                      parameter-verification failure."]
    #[doc = " \\return              #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_auth_decrypt"]
    pub fn cipher_auth_decrypt(
        ctx: *mut cipher_context_t,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        ad: *const crate::types::c_uchar,
        ad_len: usize,
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        olen: *mut usize,
        tag: *const crate::types::c_uchar,
        tag_len: usize,
    ) -> crate::types::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum key_exchange_type_t {
    KEY_EXCHANGE_NONE = 0,
    KEY_EXCHANGE_RSA = 1,
    KEY_EXCHANGE_DHE_RSA = 2,
    KEY_EXCHANGE_ECDHE_RSA = 3,
    KEY_EXCHANGE_ECDHE_ECDSA = 4,
    KEY_EXCHANGE_PSK = 5,
    KEY_EXCHANGE_DHE_PSK = 6,
    KEY_EXCHANGE_RSA_PSK = 7,
    KEY_EXCHANGE_ECDHE_PSK = 8,
    KEY_EXCHANGE_ECDH_RSA = 9,
    KEY_EXCHANGE_ECDH_ECDSA = 10,
    KEY_EXCHANGE_ECJPAKE = 11,
}
#[doc = " \\brief   This structure is used for storing ciphersuite information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ciphersuite_t {
    pub id: crate::types::c_int,
    pub name: *const crate::types::c_char,
    pub cipher: cipher_type_t,
    pub mac: md_type_t,
    pub key_exchange: key_exchange_type_t,
    pub min_major_ver: crate::types::c_int,
    pub min_minor_ver: crate::types::c_int,
    pub max_major_ver: crate::types::c_int,
    pub max_minor_ver: crate::types::c_int,
    pub flags: crate::types::c_uchar,
}
#[test]
fn bindgen_test_layout_ssl_ciphersuite_t() {
    assert_eq!(
        ::core::mem::size_of::<ssl_ciphersuite_t>(),
        40usize,
        concat!("Size of: ", stringify!(ssl_ciphersuite_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_ciphersuite_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_ciphersuite_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).cipher as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).mac as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).key_exchange as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(key_exchange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ciphersuite_t>())).min_major_ver as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(min_major_ver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ciphersuite_t>())).min_minor_ver as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(min_minor_ver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ciphersuite_t>())).max_major_ver as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(max_major_ver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ciphersuite_t>())).max_minor_ver as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(max_minor_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ssl_ciphersuite_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_list_ciphersuites"]
    pub fn ssl_list_ciphersuites() -> *const crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ciphersuite_from_string"]
    pub fn ssl_ciphersuite_from_string(
        ciphersuite_name: *const crate::types::c_char,
    ) -> *const ssl_ciphersuite_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ciphersuite_from_id"]
    pub fn ssl_ciphersuite_from_id(ciphersuite_id: crate::types::c_int)
        -> *const ssl_ciphersuite_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite_sig_pk_alg"]
    pub fn ssl_get_ciphersuite_sig_pk_alg(info: *const ssl_ciphersuite_t) -> pk_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite_sig_alg"]
    pub fn ssl_get_ciphersuite_sig_alg(info: *const ssl_ciphersuite_t) -> pk_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ciphersuite_uses_ec"]
    pub fn ssl_ciphersuite_uses_ec(info: *const ssl_ciphersuite_t) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_ciphersuite_uses_psk"]
    pub fn ssl_ciphersuite_uses_psk(info: *const ssl_ciphersuite_t) -> crate::types::c_int;
}
#[doc = " Certificate revocation list entry."]
#[doc = " Contains the CA-specific serial numbers and revocation dates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_crl_entry {
    pub raw: x509_buf,
    pub serial: x509_buf,
    pub revocation_date: x509_time,
    pub entry_ext: x509_buf,
    pub next: *mut x509_crl_entry,
}
#[test]
fn bindgen_test_layout_x509_crl_entry() {
    assert_eq!(
        ::core::mem::size_of::<x509_crl_entry>(),
        64usize,
        concat!("Size of: ", stringify!(x509_crl_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crl_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_crl_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).serial as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).revocation_date as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(revocation_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).entry_ext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(entry_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).next as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(next)
        )
    );
}
impl Default for x509_crl_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Certificate revocation list structure."]
#[doc = " Every CRL may have multiple entries."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_crl {
    #[doc = "< The raw certificate data (DER)."]
    pub raw: x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: x509_buf,
    #[doc = "< CRL version (1=v1, 2=v2)"]
    pub version: crate::types::c_int,
    #[doc = "< CRL signature type identifier"]
    pub sig_oid: x509_buf,
    #[doc = "< The raw issuer data (DER)."]
    pub issuer_raw: x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: x509_name,
    pub this_update: x509_time,
    pub next_update: x509_time,
    #[doc = "< The CRL entries containing the certificate revocation times for this CA."]
    pub entry: x509_crl_entry,
    pub crl_ext: x509_buf,
    pub sig_oid2: x509_buf,
    pub sig: x509_buf,
    #[doc = "< Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256"]
    pub sig_md: md_type_t,
    #[doc = "< Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA"]
    pub sig_pk: pk_type_t,
    #[doc = "< Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS"]
    pub sig_opts: *mut crate::types::c_void,
    pub next: *mut x509_crl,
}
#[test]
fn bindgen_test_layout_x509_crl() {
    assert_eq!(
        ::core::mem::size_of::<x509_crl>(),
        248usize,
        concat!("Size of: ", stringify!(x509_crl))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crl>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_crl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).tbs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(tbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_oid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).issuer_raw as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(issuer_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).issuer as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).this_update as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(this_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).next_update as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(next_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).entry as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).crl_ext as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(crl_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_oid2 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_oid2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_md as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_md)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_pk as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_opts as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).next as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(next)
        )
    );
}
impl Default for x509_crl {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Parse a DER-encoded CRL and append it to the chained list"]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param buf      buffer holding the CRL data in DER format"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = "                 (including the terminating null byte for PEM data)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 or PEM error code"]
    #[link_name = "\u{1}mbedtls_x509_crl_parse_der"]
    pub fn x509_crl_parse_der(
        chain: *mut x509_crl,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one or more CRLs and append them to the chained list"]
    #[doc = ""]
    #[doc = " \\note           Multiple CRLs are accepted only if using PEM format"]
    #[doc = ""]
    #[doc = " \\param chain    points to the start of the chain"]
    #[doc = " \\param buf      buffer holding the CRL data in PEM or DER format"]
    #[doc = " \\param buflen   size of the buffer"]
    #[doc = "                 (including the terminating null byte for PEM data)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or a specific X509 or PEM error code"]
    #[link_name = "\u{1}mbedtls_x509_crl_parse"]
    pub fn x509_crl_parse(
        chain: *mut x509_crl,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the CRL."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param crl      The X509 CRL to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    #[link_name = "\u{1}mbedtls_x509_crl_info"]
    pub fn x509_crl_info(
        buf: *mut crate::types::c_char,
        size: usize,
        prefix: *const crate::types::c_char,
        crl: *const x509_crl,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a CRL (chain)"]
    #[doc = ""]
    #[doc = " \\param crl      CRL chain to initialize"]
    #[link_name = "\u{1}mbedtls_x509_crl_init"]
    pub fn x509_crl_init(crl: *mut x509_crl);
}
extern "C" {
    #[doc = " \\brief          Unallocate all CRL data"]
    #[doc = ""]
    #[doc = " \\param crl      CRL chain to free"]
    #[link_name = "\u{1}mbedtls_x509_crl_free"]
    pub fn x509_crl_free(crl: *mut x509_crl);
}
#[doc = " Container for an X.509 certificate. The certificate may be chained."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_crt {
    #[doc = "< Indicates if \\c raw is owned"]
    #[doc = "   by the structure or not."]
    pub own_buffer: crate::types::c_int,
    #[doc = "< The raw certificate data (DER)."]
    pub raw: x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: x509_buf,
    #[doc = "< The X.509 version. (1=v1, 2=v2, 3=v3)"]
    pub version: crate::types::c_int,
    #[doc = "< Unique id for certificate issued by a specific CA."]
    pub serial: x509_buf,
    #[doc = "< Signature algorithm, e.g. sha1RSA"]
    pub sig_oid: x509_buf,
    #[doc = "< The raw issuer data (DER). Used for quick comparison."]
    pub issuer_raw: x509_buf,
    #[doc = "< The raw subject data (DER). Used for quick comparison."]
    pub subject_raw: x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: x509_name,
    #[doc = "< The parsed subject data (named information object)."]
    pub subject: x509_name,
    #[doc = "< Start time of certificate validity."]
    pub valid_from: x509_time,
    #[doc = "< End time of certificate validity."]
    pub valid_to: x509_time,
    pub pk_raw: x509_buf,
    #[doc = "< Container for the public key context."]
    pub pk: pk_context,
    #[doc = "< Optional X.509 v2/v3 issuer unique identifier."]
    pub issuer_id: x509_buf,
    #[doc = "< Optional X.509 v2/v3 subject unique identifier."]
    pub subject_id: x509_buf,
    #[doc = "< Optional X.509 v3 extensions."]
    pub v3_ext: x509_buf,
    #[doc = "< Optional list of raw entries of Subject Alternative Names extension (currently only dNSName and OtherName are listed)."]
    pub subject_alt_names: x509_sequence,
    #[doc = "< Optional list of certificate policies (Only anyPolicy is printed and enforced, however the rest of the policies are still listed)."]
    pub certificate_policies: x509_sequence,
    #[doc = "< Bit string containing detected and parsed extensions"]
    pub ext_types: crate::types::c_int,
    #[doc = "< Optional Basic Constraint extension value: 1 if this certificate belongs to a CA, 0 otherwise."]
    pub ca_istrue: crate::types::c_int,
    #[doc = "< Optional Basic Constraint extension value: The maximum path length to the root certificate. Path length is 1 higher than RFC 5280 'meaning', so 1+"]
    pub max_pathlen: crate::types::c_int,
    #[doc = "< Optional key usage extension value: See the values in x509.h"]
    pub key_usage: crate::types::c_uint,
    #[doc = "< Optional list of extended key usage OIDs."]
    pub ext_key_usage: x509_sequence,
    #[doc = "< Optional Netscape certificate type extension value: See the values in x509.h"]
    pub ns_cert_type: crate::types::c_uchar,
    #[doc = "< Signature: hash of the tbs part signed with the private key."]
    pub sig: x509_buf,
    #[doc = "< Internal representation of the MD algorithm of the signature algorithm, e.g. MBEDTLS_MD_SHA256"]
    pub sig_md: md_type_t,
    #[doc = "< Internal representation of the Public Key algorithm of the signature algorithm, e.g. MBEDTLS_PK_RSA"]
    pub sig_pk: pk_type_t,
    #[doc = "< Signature options to be passed to mbedtls_pk_verify_ext(), e.g. for RSASSA-PSS"]
    pub sig_opts: *mut crate::types::c_void,
    #[doc = "< Next certificate in the CA-chain."]
    pub next: *mut x509_crt,
}
#[test]
fn bindgen_test_layout_x509_crt() {
    assert_eq!(
        ::core::mem::size_of::<x509_crt>(),
        344usize,
        concat!("Size of: ", stringify!(x509_crt))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_crt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).own_buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(own_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).raw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).tbs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(tbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).version as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).serial as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig_oid as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).issuer_raw as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(issuer_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).subject_raw as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).issuer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).subject as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).valid_from as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(valid_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).valid_to as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(valid_to)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).pk_raw as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(pk_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).pk as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).issuer_id as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(issuer_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).subject_id as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).v3_ext as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(v3_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).subject_alt_names as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject_alt_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).certificate_policies as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(certificate_policies)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).ext_types as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ext_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).ca_istrue as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ca_istrue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).max_pathlen as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(max_pathlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).key_usage as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(key_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).ext_key_usage as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ext_key_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).ns_cert_type as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ns_cert_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig_md as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_md)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig_pk as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig_opts as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).next as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(next)
        )
    );
}
impl Default for x509_crt {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " From RFC 5280 section 4.2.1.6:"]
#[doc = " OtherName ::= SEQUENCE {"]
#[doc = "      type-id    OBJECT IDENTIFIER,"]
#[doc = "      value      [0] EXPLICIT ANY DEFINED BY type-id }"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_san_other_name {
    #[doc = "< The type id."]
    pub type_id: x509_buf,
    pub value: x509_san_other_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union x509_san_other_name__bindgen_ty_1 {
    pub hardware_module_name: x509_san_other_name__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 6usize],
}
#[doc = " From RFC 4108 section 5:"]
#[doc = " HardwareModuleName ::= SEQUENCE {"]
#[doc = "                         hwType OBJECT IDENTIFIER,"]
#[doc = "                         hwSerialNum OCTET STRING }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The object identifier."]
    pub oid: x509_buf,
    #[doc = "< The named value."]
    pub val: x509_buf,
}
#[test]
fn bindgen_test_layout_x509_san_other_name__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<x509_san_other_name__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(x509_san_other_name__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<x509_san_other_name__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(x509_san_other_name__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_san_other_name__bindgen_ty_1__bindgen_ty_1>())).oid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_san_other_name__bindgen_ty_1__bindgen_ty_1>())).val
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
impl Default for x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_x509_san_other_name__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<x509_san_other_name__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(x509_san_other_name__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_san_other_name__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(x509_san_other_name__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_san_other_name__bindgen_ty_1>())).hardware_module_name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name__bindgen_ty_1),
            "::",
            stringify!(hardware_module_name)
        )
    );
}
impl Default for x509_san_other_name__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_x509_san_other_name() {
    assert_eq!(
        ::core::mem::size_of::<x509_san_other_name>(),
        36usize,
        concat!("Size of: ", stringify!(x509_san_other_name))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_san_other_name>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_san_other_name))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_san_other_name>())).type_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_san_other_name>())).value as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_san_other_name),
            "::",
            stringify!(value)
        )
    );
}
impl Default for x509_san_other_name {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " A structure for holding the parsed Subject Alternative Name, according to type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_subject_alternative_name {
    #[doc = "< The SAN type, value of MBEDTLS_X509_SAN_XXX."]
    pub type_: crate::types::c_int,
    #[doc = "< A union of the supported SAN types"]
    pub san: x509_subject_alternative_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union x509_subject_alternative_name__bindgen_ty_1 {
    #[doc = "< The otherName supported type."]
    pub other_name: x509_san_other_name,
    #[doc = "< The buffer for the un constructed types. Only dnsName currently supported"]
    pub unstructured_name: x509_buf,
    _bindgen_union_align: [u32; 9usize],
}
#[test]
fn bindgen_test_layout_x509_subject_alternative_name__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<x509_subject_alternative_name__bindgen_ty_1>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(x509_subject_alternative_name__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<x509_subject_alternative_name__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(x509_subject_alternative_name__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_subject_alternative_name__bindgen_ty_1>())).other_name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_subject_alternative_name__bindgen_ty_1),
            "::",
            stringify!(other_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_subject_alternative_name__bindgen_ty_1>()))
                .unstructured_name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_subject_alternative_name__bindgen_ty_1),
            "::",
            stringify!(unstructured_name)
        )
    );
}
impl Default for x509_subject_alternative_name__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_x509_subject_alternative_name() {
    assert_eq!(
        ::core::mem::size_of::<x509_subject_alternative_name>(),
        40usize,
        concat!("Size of: ", stringify!(x509_subject_alternative_name))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_subject_alternative_name>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_subject_alternative_name))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_subject_alternative_name>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_subject_alternative_name),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_subject_alternative_name>())).san as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_subject_alternative_name),
            "::",
            stringify!(san)
        )
    );
}
impl Default for x509_subject_alternative_name {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Security profile for certificate verification."]
#[doc = ""]
#[doc = " All lists are bitfields, built by ORing flags from MBEDTLS_X509_ID_FLAG()."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct x509_crt_profile {
    #[doc = "< MDs for signatures"]
    pub allowed_mds: u32,
    #[doc = "< PK algs for signatures"]
    pub allowed_pks: u32,
    #[doc = "< Elliptic curves for ECDSA"]
    pub allowed_curves: u32,
    #[doc = "< Minimum size for RSA keys"]
    pub rsa_min_bitlen: u32,
}
#[test]
fn bindgen_test_layout_x509_crt_profile() {
    assert_eq!(
        ::core::mem::size_of::<x509_crt_profile>(),
        16usize,
        concat!("Size of: ", stringify!(x509_crt_profile))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt_profile>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_crt_profile))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_profile>())).allowed_mds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(allowed_mds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_profile>())).allowed_pks as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(allowed_pks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_crt_profile>())).allowed_curves as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(allowed_curves)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_crt_profile>())).rsa_min_bitlen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(rsa_min_bitlen)
        )
    );
}
#[doc = " Container for writing a certificate (CRT)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509write_cert {
    pub version: crate::types::c_int,
    pub serial: mpi,
    pub subject_key: *mut pk_context,
    pub issuer_key: *mut pk_context,
    pub subject: *mut asn1_named_data,
    pub issuer: *mut asn1_named_data,
    pub md_alg: md_type_t,
    pub not_before: [crate::types::c_char; 16usize],
    pub not_after: [crate::types::c_char; 16usize],
    pub extensions: *mut asn1_named_data,
}
#[test]
fn bindgen_test_layout_x509write_cert() {
    assert_eq!(
        ::core::mem::size_of::<x509write_cert>(),
        72usize,
        concat!("Size of: ", stringify!(x509write_cert))
    );
    assert_eq!(
        ::core::mem::align_of::<x509write_cert>(),
        4usize,
        concat!("Alignment of ", stringify!(x509write_cert))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).serial as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).subject_key as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(subject_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).issuer_key as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(issuer_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).subject as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).issuer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).md_alg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(md_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).not_before as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(not_before)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).not_after as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(not_after)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).extensions as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(extensions)
        )
    );
}
impl Default for x509write_cert {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Item in a verification chain: cert and flags for it"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_crt_verify_chain_item {
    pub crt: *mut x509_crt,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_x509_crt_verify_chain_item() {
    assert_eq!(
        ::core::mem::size_of::<x509_crt_verify_chain_item>(),
        8usize,
        concat!("Size of: ", stringify!(x509_crt_verify_chain_item))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt_verify_chain_item>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_crt_verify_chain_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_verify_chain_item>())).crt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain_item),
            "::",
            stringify!(crt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_crt_verify_chain_item>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain_item),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for x509_crt_verify_chain_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Verification chain as built by \\c mbedtls_crt_verify_chain()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_crt_verify_chain {
    pub items: [x509_crt_verify_chain_item; 10usize],
    pub len: crate::types::c_uint,
    pub trust_ca_cb_result: *mut x509_crt,
}
#[test]
fn bindgen_test_layout_x509_crt_verify_chain() {
    assert_eq!(
        ::core::mem::size_of::<x509_crt_verify_chain>(),
        88usize,
        concat!("Size of: ", stringify!(x509_crt_verify_chain))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt_verify_chain>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_crt_verify_chain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_verify_chain>())).items as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_verify_chain>())).len as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_crt_verify_chain>())).trust_ca_cb_result as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain),
            "::",
            stringify!(trust_ca_cb_result)
        )
    );
}
impl Default for x509_crt_verify_chain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type x509_crt_restart_ctx = crate::types::c_void;
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_profile_default"]
    pub static x509_crt_profile_default: x509_crt_profile;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_profile_next"]
    pub static x509_crt_profile_next: x509_crt_profile;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_x509_crt_profile_suiteb"]
    pub static x509_crt_profile_suiteb: x509_crt_profile;
}
extern "C" {
    #[doc = " \\brief          Parse a single DER formatted certificate and add it"]
    #[doc = "                 to the end of the provided chained list."]
    #[doc = ""]
    #[doc = " \\param chain    The pointer to the start of the CRT chain to attach to."]
    #[doc = "                 When parsing the first CRT in a chain, this should point"]
    #[doc = "                 to an instance of ::mbedtls_x509_crt initialized through"]
    #[doc = "                 mbedtls_x509_crt_init()."]
    #[doc = " \\param buf      The buffer holding the DER encoded certificate."]
    #[doc = " \\param buflen   The size in Bytes of \\p buf."]
    #[doc = ""]
    #[doc = " \\note           This function makes an internal copy of the CRT buffer"]
    #[doc = "                 \\p buf. In particular, \\p buf may be destroyed or reused"]
    #[doc = "                 after this call returns. To avoid duplicating the CRT"]
    #[doc = "                 buffer (at the cost of stricter lifetime constraints),"]
    #[doc = "                 use mbedtls_x509_crt_parse_der_nocopy() instead."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_x509_crt_parse_der"]
    pub fn x509_crt_parse_der(
        chain: *mut x509_crt,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
#[doc = " \\brief          The type of certificate extension callbacks."]
#[doc = ""]
#[doc = "                 Callbacks of this type are passed to and used by the"]
#[doc = "                 mbedtls_x509_crt_parse_der_with_ext_cb() routine when"]
#[doc = "                 it encounters either an unsupported extension or a"]
#[doc = "                 \"certificate policies\" extension containing any"]
#[doc = "                 unsupported certificate policies."]
#[doc = "                 Future versions of the library may invoke the callback"]
#[doc = "                 in other cases, if and when the need arises."]
#[doc = ""]
#[doc = " \\param p_ctx    An opaque context passed to the callback."]
#[doc = " \\param crt      The certificate being parsed."]
#[doc = " \\param oid      The OID of the extension."]
#[doc = " \\param critical Whether the extension is critical."]
#[doc = " \\param p        Pointer to the start of the extension value"]
#[doc = "                 (the content of the OCTET STRING)."]
#[doc = " \\param end      End of extension value."]
#[doc = ""]
#[doc = " \\note           The callback must fail and return a negative error code"]
#[doc = "                 if it can not parse or does not support the extension."]
#[doc = "                 When the callback fails to parse a critical extension"]
#[doc = "                 mbedtls_x509_crt_parse_der_with_ext_cb() also fails."]
#[doc = "                 When the callback fails to parse a non critical extension"]
#[doc = "                 mbedtls_x509_crt_parse_der_with_ext_cb() simply skips"]
#[doc = "                 the extension and continues parsing."]
#[doc = ""]
#[doc = " \\return         \\c 0 on success."]
#[doc = " \\return         A negative error code on failure."]
pub type x509_crt_ext_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut crate::types::c_void,
        crt: *const x509_crt,
        oid: *const x509_buf,
        critical: crate::types::c_int,
        p: *const crate::types::c_uchar,
        end: *const crate::types::c_uchar,
    ) -> crate::types::c_int,
>;
extern "C" {
    #[doc = " \\brief            Parse a single DER formatted certificate and add it"]
    #[doc = "                   to the end of the provided chained list."]
    #[doc = ""]
    #[doc = " \\param chain      The pointer to the start of the CRT chain to attach to."]
    #[doc = "                   When parsing the first CRT in a chain, this should point"]
    #[doc = "                   to an instance of ::mbedtls_x509_crt initialized through"]
    #[doc = "                   mbedtls_x509_crt_init()."]
    #[doc = " \\param buf        The buffer holding the DER encoded certificate."]
    #[doc = " \\param buflen     The size in Bytes of \\p buf."]
    #[doc = " \\param make_copy  When not zero this function makes an internal copy of the"]
    #[doc = "                   CRT buffer \\p buf. In particular, \\p buf may be destroyed"]
    #[doc = "                   or reused after this call returns."]
    #[doc = "                   When zero this function avoids duplicating the CRT buffer"]
    #[doc = "                   by taking temporary ownership thereof until the CRT"]
    #[doc = "                   is destroyed (like mbedtls_x509_crt_parse_der_nocopy())"]
    #[doc = " \\param cb         A callback invoked for every unsupported certificate"]
    #[doc = "                   extension."]
    #[doc = " \\param p_ctx      An opaque context passed to the callback."]
    #[doc = ""]
    #[doc = " \\note             This call is functionally equivalent to"]
    #[doc = "                   mbedtls_x509_crt_parse_der(), and/or"]
    #[doc = "                   mbedtls_x509_crt_parse_der_nocopy()"]
    #[doc = "                   but it calls the callback with every unsupported"]
    #[doc = "                   certificate extension and additionally the"]
    #[doc = "                   \"certificate policies\" extension if it contains any"]
    #[doc = "                   unsupported certificate policies."]
    #[doc = "                   The callback must return a negative error code if it"]
    #[doc = "                   does not know how to handle such an extension."]
    #[doc = "                   When the callback fails to parse a critical extension"]
    #[doc = "                   mbedtls_x509_crt_parse_der_with_ext_cb() also fails."]
    #[doc = "                   When the callback fails to parse a non critical extension"]
    #[doc = "                   mbedtls_x509_crt_parse_der_with_ext_cb() simply skips"]
    #[doc = "                   the extension and continues parsing."]
    #[doc = "                   Future versions of the library may invoke the callback"]
    #[doc = "                   in other cases, if and when the need arises."]
    #[doc = ""]
    #[doc = " \\return           \\c 0 if successful."]
    #[doc = " \\return           A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_x509_crt_parse_der_with_ext_cb"]
    pub fn x509_crt_parse_der_with_ext_cb(
        chain: *mut x509_crt,
        buf: *const crate::types::c_uchar,
        buflen: usize,
        make_copy: crate::types::c_int,
        cb: x509_crt_ext_cb_t,
        p_ctx: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse a single DER formatted certificate and add it"]
    #[doc = "                 to the end of the provided chained list. This is a"]
    #[doc = "                 variant of mbedtls_x509_crt_parse_der() which takes"]
    #[doc = "                 temporary ownership of the CRT buffer until the CRT"]
    #[doc = "                 is destroyed."]
    #[doc = ""]
    #[doc = " \\param chain    The pointer to the start of the CRT chain to attach to."]
    #[doc = "                 When parsing the first CRT in a chain, this should point"]
    #[doc = "                 to an instance of ::mbedtls_x509_crt initialized through"]
    #[doc = "                 mbedtls_x509_crt_init()."]
    #[doc = " \\param buf      The address of the readable buffer holding the DER encoded"]
    #[doc = "                 certificate to use. On success, this buffer must be"]
    #[doc = "                 retained and not be changed for the liftetime of the"]
    #[doc = "                 CRT chain \\p chain, that is, until \\p chain is destroyed"]
    #[doc = "                 through a call to mbedtls_x509_crt_free()."]
    #[doc = " \\param buflen   The size in Bytes of \\p buf."]
    #[doc = ""]
    #[doc = " \\note           This call is functionally equivalent to"]
    #[doc = "                 mbedtls_x509_crt_parse_der(), but it avoids creating a"]
    #[doc = "                 copy of the input buffer at the cost of stronger lifetime"]
    #[doc = "                 constraints. This is useful in constrained environments"]
    #[doc = "                 where duplication of the CRT cannot be tolerated."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_x509_crt_parse_der_nocopy"]
    pub fn x509_crt_parse_der_nocopy(
        chain: *mut x509_crt,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one DER-encoded or one or more concatenated PEM-encoded"]
    #[doc = "                 certificates and add them to the chained list."]
    #[doc = ""]
    #[doc = "                 For CRTs in PEM encoding, the function parses permissively:"]
    #[doc = "                 if at least one certificate can be parsed, the function"]
    #[doc = "                 returns the number of certificates for which parsing failed"]
    #[doc = "                 (hence \\c 0 if all certificates were parsed successfully)."]
    #[doc = "                 If no certificate could be parsed, the function returns"]
    #[doc = "                 the first (negative) error encountered during parsing."]
    #[doc = ""]
    #[doc = "                 PEM encoded certificates may be interleaved by other data"]
    #[doc = "                 such as human readable descriptions of their content, as"]
    #[doc = "                 long as the certificates are enclosed in the PEM specific"]
    #[doc = "                 '-----{BEGIN/END} CERTIFICATE-----' delimiters."]
    #[doc = ""]
    #[doc = " \\param chain    The chain to which to add the parsed certificates."]
    #[doc = " \\param buf      The buffer holding the certificate data in PEM or DER format."]
    #[doc = "                 For certificates in PEM encoding, this may be a concatenation"]
    #[doc = "                 of multiple certificates; for DER encoding, the buffer must"]
    #[doc = "                 comprise exactly one certificate."]
    #[doc = " \\param buflen   The size of \\p buf, including the terminating \\c NULL byte"]
    #[doc = "                 in case of PEM encoded data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if all certificates were parsed successfully."]
    #[doc = " \\return         The (positive) number of certificates that couldn't"]
    #[doc = "                 be parsed if parsing was partly successful (see above)."]
    #[doc = " \\return         A negative X509 or PEM error code otherwise."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_x509_crt_parse"]
    pub fn x509_crt_parse(
        chain: *mut x509_crt,
        buf: *const crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function parses an item in the SubjectAlternativeNames"]
    #[doc = "                 extension."]
    #[doc = ""]
    #[doc = " \\param san_buf  The buffer holding the raw data item of the subject"]
    #[doc = "                 alternative name."]
    #[doc = " \\param san      The target structure to populate with the parsed presentation"]
    #[doc = "                 of the subject alternative name encoded in \\p san_raw."]
    #[doc = ""]
    #[doc = " \\note           Only \"dnsName\" and \"otherName\" of type hardware_module_name"]
    #[doc = "                 as defined in RFC 4180 is supported."]
    #[doc = ""]
    #[doc = " \\note           This function should be called on a single raw data of"]
    #[doc = "                 subject alternative name. For example, after successful"]
    #[doc = "                 certificate parsing, one must iterate on every item in the"]
    #[doc = "                 \\p crt->subject_alt_names sequence, and pass it to"]
    #[doc = "                 this function."]
    #[doc = ""]
    #[doc = " \\warning        The target structure contains pointers to the raw data of the"]
    #[doc = "                 parsed certificate, and its lifetime is restricted by the"]
    #[doc = "                 lifetime of the certificate."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success"]
    #[doc = " \\return         #MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE for an unsupported"]
    #[doc = "                 SAN type."]
    #[doc = " \\return         Another negative value for any other failure."]
    #[link_name = "\u{1}mbedtls_x509_parse_subject_alt_name"]
    pub fn x509_parse_subject_alt_name(
        san_buf: *const x509_buf,
        san: *mut x509_subject_alternative_name,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the"]
    #[doc = "                 certificate."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param crt      The X509 certificate to represent"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    #[link_name = "\u{1}mbedtls_x509_crt_info"]
    pub fn x509_crt_info(
        buf: *mut crate::types::c_char,
        size: usize,
        prefix: *const crate::types::c_char,
        crt: *const x509_crt,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the"]
    #[doc = "                 verification status of a certificate."]
    #[doc = ""]
    #[doc = " \\param buf      Buffer to write to"]
    #[doc = " \\param size     Maximum size of buffer"]
    #[doc = " \\param prefix   A line prefix"]
    #[doc = " \\param flags    Verification flags created by mbedtls_x509_crt_verify()"]
    #[doc = ""]
    #[doc = " \\return         The length of the string written (not including the"]
    #[doc = "                 terminated nul byte), or a negative error code."]
    #[link_name = "\u{1}mbedtls_x509_crt_verify_info"]
    pub fn x509_crt_verify_info(
        buf: *mut crate::types::c_char,
        size: usize,
        prefix: *const crate::types::c_char,
        flags: u32,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify a chain of certificates."]
    #[doc = ""]
    #[doc = "                 The verify callback is a user-supplied callback that"]
    #[doc = "                 can clear / modify / add flags for a certificate. If set,"]
    #[doc = "                 the verification callback is called for each"]
    #[doc = "                 certificate in the chain (from the trust-ca down to the"]
    #[doc = "                 presented crt). The parameters for the callback are:"]
    #[doc = "                 (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,"]
    #[doc = "                 int *flags). With the flags representing current flags for"]
    #[doc = "                 that specific certificate and the certificate depth from"]
    #[doc = "                 the bottom (Peer cert depth = 0)."]
    #[doc = ""]
    #[doc = "                 All flags left after returning from the callback"]
    #[doc = "                 are also returned to the application. The function should"]
    #[doc = "                 return 0 for anything (including invalid certificates)"]
    #[doc = "                 other than fatal error, as a non-zero return code"]
    #[doc = "                 immediately aborts the verification process. For fatal"]
    #[doc = "                 errors, a specific error code should be used (different"]
    #[doc = "                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not"]
    #[doc = "                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR"]
    #[doc = "                 can be used if no better code is available."]
    #[doc = ""]
    #[doc = " \\note           In case verification failed, the results can be displayed"]
    #[doc = "                 using \\c mbedtls_x509_crt_verify_info()"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_x509_crt_verify_with_profile() with the"]
    #[doc = "                 default security profile."]
    #[doc = ""]
    #[doc = " \\note           It is your responsibility to provide up-to-date CRLs for"]
    #[doc = "                 all trusted CAs. If no CRL is provided for the CA that was"]
    #[doc = "                 used to sign the certificate, CRL verification is skipped"]
    #[doc = "                 silently, that is *without* setting any flag."]
    #[doc = ""]
    #[doc = " \\note           The \\c trust_ca list can contain two types of certificates:"]
    #[doc = "                 (1) those of trusted root CAs, so that certificates"]
    #[doc = "                 chaining up to those CAs will be trusted, and (2)"]
    #[doc = "                 self-signed end-entity certificates to be trusted (for"]
    #[doc = "                 specific peers you know) - in that case, the self-signed"]
    #[doc = "                 certificate doesn't need to have the CA bit set."]
    #[doc = ""]
    #[doc = " \\param crt      The certificate chain to be verified."]
    #[doc = " \\param trust_ca The list of trusted CAs."]
    #[doc = " \\param ca_crl   The list of CRLs for trusted CAs."]
    #[doc = " \\param cn       The expected Common Name. This will be checked to be"]
    #[doc = "                 present in the certificate's subjectAltNames extension or,"]
    #[doc = "                 if this extension is absent, as a CN component in its"]
    #[doc = "                 Subject name. Currently only DNS names are supported. This"]
    #[doc = "                 may be \\c NULL if the CN need not be verified."]
    #[doc = " \\param flags    The address at which to store the result of the verification."]
    #[doc = "                 If the verification couldn't be completed, the flag value is"]
    #[doc = "                 set to (uint32_t) -1."]
    #[doc = " \\param f_vrfy   The verification callback to use. See the documentation"]
    #[doc = "                 of mbedtls_x509_crt_verify() for more information."]
    #[doc = " \\param p_vrfy   The context to be passed to \\p f_vrfy."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the chain is valid with respect to the"]
    #[doc = "                 passed CN, CAs, CRLs and security profile."]
    #[doc = " \\return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the"]
    #[doc = "                 certificate chain verification failed. In this case,"]
    #[doc = "                 \\c *flags will have one or more"]
    #[doc = "                 \\c MBEDTLS_X509_BADCERT_XXX or \\c MBEDTLS_X509_BADCRL_XXX"]
    #[doc = "                 flags set."]
    #[doc = " \\return         Another negative error code in case of a fatal error"]
    #[doc = "                 encountered during the verification process."]
    #[link_name = "\u{1}mbedtls_x509_crt_verify"]
    pub fn x509_crt_verify(
        crt: *mut x509_crt,
        trust_ca: *mut x509_crt,
        ca_crl: *mut x509_crl,
        cn: *const crate::types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut x509_crt,
                arg3: crate::types::c_int,
                arg4: *mut u32,
            ) -> crate::types::c_int,
        >,
        p_vrfy: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify a chain of certificates with respect to"]
    #[doc = "                 a configurable security profile."]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_x509_crt_verify(), but with explicit"]
    #[doc = "                 security profile."]
    #[doc = ""]
    #[doc = " \\note           The restrictions on keys (RSA minimum size, allowed curves"]
    #[doc = "                 for ECDSA) apply to all certificates: trusted root,"]
    #[doc = "                 intermediate CAs if any, and end entity certificate."]
    #[doc = ""]
    #[doc = " \\param crt      The certificate chain to be verified."]
    #[doc = " \\param trust_ca The list of trusted CAs."]
    #[doc = " \\param ca_crl   The list of CRLs for trusted CAs."]
    #[doc = " \\param profile  The security profile to use for the verification."]
    #[doc = " \\param cn       The expected Common Name. This may be \\c NULL if the"]
    #[doc = "                 CN need not be verified."]
    #[doc = " \\param flags    The address at which to store the result of the verification."]
    #[doc = "                 If the verification couldn't be completed, the flag value is"]
    #[doc = "                 set to (uint32_t) -1."]
    #[doc = " \\param f_vrfy   The verification callback to use. See the documentation"]
    #[doc = "                 of mbedtls_x509_crt_verify() for more information."]
    #[doc = " \\param p_vrfy   The context to be passed to \\p f_vrfy."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the chain is valid with respect to the"]
    #[doc = "                 passed CN, CAs, CRLs and security profile."]
    #[doc = " \\return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the"]
    #[doc = "                 certificate chain verification failed. In this case,"]
    #[doc = "                 \\c *flags will have one or more"]
    #[doc = "                 \\c MBEDTLS_X509_BADCERT_XXX or \\c MBEDTLS_X509_BADCRL_XXX"]
    #[doc = "                 flags set."]
    #[doc = " \\return         Another negative error code in case of a fatal error"]
    #[doc = "                 encountered during the verification process."]
    #[link_name = "\u{1}mbedtls_x509_crt_verify_with_profile"]
    pub fn x509_crt_verify_with_profile(
        crt: *mut x509_crt,
        trust_ca: *mut x509_crt,
        ca_crl: *mut x509_crl,
        profile: *const x509_crt_profile,
        cn: *const crate::types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut x509_crt,
                arg3: crate::types::c_int,
                arg4: *mut u32,
            ) -> crate::types::c_int,
        >,
        p_vrfy: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Restartable version of \\c mbedtls_crt_verify_with_profile()"]
    #[doc = ""]
    #[doc = " \\note           Performs the same job as \\c mbedtls_crt_verify_with_profile()"]
    #[doc = "                 but can return early and restart according to the limit"]
    #[doc = "                 set with \\c mbedtls_ecp_set_max_ops() to reduce blocking."]
    #[doc = ""]
    #[doc = " \\param crt      The certificate chain to be verified."]
    #[doc = " \\param trust_ca The list of trusted CAs."]
    #[doc = " \\param ca_crl   The list of CRLs for trusted CAs."]
    #[doc = " \\param profile  The security profile to use for the verification."]
    #[doc = " \\param cn       The expected Common Name. This may be \\c NULL if the"]
    #[doc = "                 CN need not be verified."]
    #[doc = " \\param flags    The address at which to store the result of the verification."]
    #[doc = "                 If the verification couldn't be completed, the flag value is"]
    #[doc = "                 set to (uint32_t) -1."]
    #[doc = " \\param f_vrfy   The verification callback to use. See the documentation"]
    #[doc = "                 of mbedtls_x509_crt_verify() for more information."]
    #[doc = " \\param p_vrfy   The context to be passed to \\p f_vrfy."]
    #[doc = " \\param rs_ctx   The restart context to use. This may be set to \\c NULL"]
    #[doc = "                 to disable restartable ECC."]
    #[doc = ""]
    #[doc = " \\return         See \\c mbedtls_crt_verify_with_profile(), or"]
    #[doc = " \\return         #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of"]
    #[doc = "                 operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    #[link_name = "\u{1}mbedtls_x509_crt_verify_restartable"]
    pub fn x509_crt_verify_restartable(
        crt: *mut x509_crt,
        trust_ca: *mut x509_crt,
        ca_crl: *mut x509_crl,
        profile: *const x509_crt_profile,
        cn: *const crate::types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut x509_crt,
                arg3: crate::types::c_int,
                arg4: *mut u32,
            ) -> crate::types::c_int,
        >,
        p_vrfy: *mut crate::types::c_void,
        rs_ctx: *mut x509_crt_restart_ctx,
    ) -> crate::types::c_int;
}
#[doc = " \\brief               The type of trusted certificate callbacks."]
#[doc = ""]
#[doc = "                      Callbacks of this type are passed to and used by the CRT"]
#[doc = "                      verification routine mbedtls_x509_crt_verify_with_ca_cb()"]
#[doc = "                      when looking for trusted signers of a given certificate."]
#[doc = ""]
#[doc = "                      On success, the callback returns a list of trusted"]
#[doc = "                      certificates to be considered as potential signers"]
#[doc = "                      for the input certificate."]
#[doc = ""]
#[doc = " \\param p_ctx         An opaque context passed to the callback."]
#[doc = " \\param child         The certificate for which to search a potential signer."]
#[doc = "                      This will point to a readable certificate."]
#[doc = " \\param candidate_cas The address at which to store the address of the first"]
#[doc = "                      entry in the generated linked list of candidate signers."]
#[doc = "                      This will not be \\c NULL."]
#[doc = ""]
#[doc = " \\note                The callback must only return a non-zero value on a"]
#[doc = "                      fatal error. If, in contrast, the search for a potential"]
#[doc = "                      signer completes without a single candidate, the"]
#[doc = "                      callback must return \\c 0 and set \\c *candidate_cas"]
#[doc = "                      to \\c NULL."]
#[doc = ""]
#[doc = " \\return              \\c 0 on success. In this case, \\c *candidate_cas points"]
#[doc = "                      to a heap-allocated linked list of instances of"]
#[doc = "                      ::mbedtls_x509_crt, and ownership of this list is passed"]
#[doc = "                      to the caller."]
#[doc = " \\return              A negative error code on failure."]
pub type x509_crt_ca_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut crate::types::c_void,
        child: *const x509_crt,
        candidate_cas: *mut *mut x509_crt,
    ) -> crate::types::c_int,
>;
extern "C" {
    #[doc = " \\brief          Version of \\c mbedtls_x509_crt_verify_with_profile() which"]
    #[doc = "                 uses a callback to acquire the list of trusted CA"]
    #[doc = "                 certificates."]
    #[doc = ""]
    #[doc = " \\param crt      The certificate chain to be verified."]
    #[doc = " \\param f_ca_cb  The callback to be used to query for potential signers"]
    #[doc = "                 of a given child certificate. See the documentation of"]
    #[doc = "                 ::mbedtls_x509_crt_ca_cb_t for more information."]
    #[doc = " \\param p_ca_cb  The opaque context to be passed to \\p f_ca_cb."]
    #[doc = " \\param profile  The security profile for the verification."]
    #[doc = " \\param cn       The expected Common Name. This may be \\c NULL if the"]
    #[doc = "                 CN need not be verified."]
    #[doc = " \\param flags    The address at which to store the result of the verification."]
    #[doc = "                 If the verification couldn't be completed, the flag value is"]
    #[doc = "                 set to (uint32_t) -1."]
    #[doc = " \\param f_vrfy   The verification callback to use. See the documentation"]
    #[doc = "                 of mbedtls_x509_crt_verify() for more information."]
    #[doc = " \\param p_vrfy   The context to be passed to \\p f_vrfy."]
    #[doc = ""]
    #[doc = " \\return         See \\c mbedtls_crt_verify_with_profile()."]
    #[link_name = "\u{1}mbedtls_x509_crt_verify_with_ca_cb"]
    pub fn x509_crt_verify_with_ca_cb(
        crt: *mut x509_crt,
        f_ca_cb: x509_crt_ca_cb_t,
        p_ca_cb: *mut crate::types::c_void,
        profile: *const x509_crt_profile,
        cn: *const crate::types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut x509_crt,
                arg3: crate::types::c_int,
                arg4: *mut u32,
            ) -> crate::types::c_int,
        >,
        p_vrfy: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check usage of certificate against keyUsage extension."]
    #[doc = ""]
    #[doc = " \\param crt      Leaf certificate used."]
    #[doc = " \\param usage    Intended usage(s) (eg MBEDTLS_X509_KU_KEY_ENCIPHERMENT"]
    #[doc = "                 before using the certificate to perform an RSA key"]
    #[doc = "                 exchange)."]
    #[doc = ""]
    #[doc = " \\note           Except for decipherOnly and encipherOnly, a bit set in the"]
    #[doc = "                 usage argument means this bit MUST be set in the"]
    #[doc = "                 certificate. For decipherOnly and encipherOnly, it means"]
    #[doc = "                 that bit MAY be set."]
    #[doc = ""]
    #[doc = " \\return         0 is these uses of the certificate are allowed,"]
    #[doc = "                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if the keyUsage extension"]
    #[doc = "                 is present but does not match the usage argument."]
    #[doc = ""]
    #[doc = " \\note           You should only call this function on leaf certificates, on"]
    #[doc = "                 (intermediate) CAs the keyUsage extension is automatically"]
    #[doc = "                 checked by \\c mbedtls_x509_crt_verify()."]
    #[link_name = "\u{1}mbedtls_x509_crt_check_key_usage"]
    pub fn x509_crt_check_key_usage(
        crt: *const x509_crt,
        usage: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Check usage of certificate against extendedKeyUsage."]
    #[doc = ""]
    #[doc = " \\param crt       Leaf certificate used."]
    #[doc = " \\param usage_oid Intended usage (eg MBEDTLS_OID_SERVER_AUTH or"]
    #[doc = "                  MBEDTLS_OID_CLIENT_AUTH)."]
    #[doc = " \\param usage_len Length of usage_oid (eg given by MBEDTLS_OID_SIZE())."]
    #[doc = ""]
    #[doc = " \\return          0 if this use of the certificate is allowed,"]
    #[doc = "                  MBEDTLS_ERR_X509_BAD_INPUT_DATA if not."]
    #[doc = ""]
    #[doc = " \\note            Usually only makes sense on leaf certificates."]
    #[link_name = "\u{1}mbedtls_x509_crt_check_extended_key_usage"]
    pub fn x509_crt_check_extended_key_usage(
        crt: *const x509_crt,
        usage_oid: *const crate::types::c_char,
        usage_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify the certificate revocation status"]
    #[doc = ""]
    #[doc = " \\param crt      a certificate to be verified"]
    #[doc = " \\param crl      the CRL to verify against"]
    #[doc = ""]
    #[doc = " \\return         1 if the certificate is revoked, 0 otherwise"]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_x509_crt_is_revoked"]
    pub fn x509_crt_is_revoked(crt: *const x509_crt, crl: *const x509_crl) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a certificate (chain)"]
    #[doc = ""]
    #[doc = " \\param crt      Certificate chain to initialize"]
    #[link_name = "\u{1}mbedtls_x509_crt_init"]
    pub fn x509_crt_init(crt: *mut x509_crt);
}
extern "C" {
    #[doc = " \\brief          Unallocate all certificate data"]
    #[doc = ""]
    #[doc = " \\param crt      Certificate chain to free"]
    #[link_name = "\u{1}mbedtls_x509_crt_free"]
    pub fn x509_crt_free(crt: *mut x509_crt);
}
extern "C" {
    #[doc = " \\brief           Initialize a CRT writing context"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to initialize"]
    #[link_name = "\u{1}mbedtls_x509write_crt_init"]
    pub fn x509write_crt_init(ctx: *mut x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Set the verion for a Certificate"]
    #[doc = "                  Default: MBEDTLS_X509_CRT_VERSION_3"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param version   version to set (MBEDTLS_X509_CRT_VERSION_1, MBEDTLS_X509_CRT_VERSION_2 or"]
    #[doc = "                                  MBEDTLS_X509_CRT_VERSION_3)"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_version"]
    pub fn x509write_crt_set_version(ctx: *mut x509write_cert, version: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief           Set the serial number for a Certificate."]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param serial    serial number to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_serial"]
    pub fn x509write_crt_set_serial(
        ctx: *mut x509write_cert,
        serial: *const mpi,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the validity period for a Certificate"]
    #[doc = "                  Timestamps should be in string format for UTC timezone"]
    #[doc = "                  i.e. \"YYYYMMDDhhmmss\""]
    #[doc = "                  e.g. \"20131231235959\" for December 31st 2013"]
    #[doc = "                       at 23:59:59"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param not_before    not_before timestamp"]
    #[doc = " \\param not_after     not_after timestamp"]
    #[doc = ""]
    #[doc = " \\return          0 if timestamp was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_validity"]
    pub fn x509write_crt_set_validity(
        ctx: *mut x509write_cert,
        not_before: *const crate::types::c_char,
        not_after: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the issuer name for a Certificate"]
    #[doc = "                  Issuer names should contain a comma-separated list"]
    #[doc = "                  of OID types and values:"]
    #[doc = "                  e.g. \"C=UK,O=ARM,CN=mbed TLS CA\""]
    #[doc = ""]
    #[doc = " \\param ctx           CRT context to use"]
    #[doc = " \\param issuer_name   issuer name to set"]
    #[doc = ""]
    #[doc = " \\return          0 if issuer name was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_issuer_name"]
    pub fn x509write_crt_set_issuer_name(
        ctx: *mut x509write_cert,
        issuer_name: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject name for a Certificate"]
    #[doc = "                  Subject names should contain a comma-separated list"]
    #[doc = "                  of OID types and values:"]
    #[doc = "                  e.g. \"C=UK,O=ARM,CN=mbed TLS Server 1\""]
    #[doc = ""]
    #[doc = " \\param ctx           CRT context to use"]
    #[doc = " \\param subject_name  subject name to set"]
    #[doc = ""]
    #[doc = " \\return          0 if subject name was parsed successfully, or"]
    #[doc = "                  a specific error code"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_subject_name"]
    pub fn x509write_crt_set_subject_name(
        ctx: *mut x509write_cert,
        subject_name: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject public key for the certificate"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param key       public key to include"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_subject_key"]
    pub fn x509write_crt_set_subject_key(ctx: *mut x509write_cert, key: *mut pk_context);
}
extern "C" {
    #[doc = " \\brief           Set the issuer key used for signing the certificate"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param key       private key to sign with"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_issuer_key"]
    pub fn x509write_crt_set_issuer_key(ctx: *mut x509write_cert, key: *mut pk_context);
}
extern "C" {
    #[doc = " \\brief           Set the MD algorithm to use for the signature"]
    #[doc = "                  (e.g. MBEDTLS_MD_SHA1)"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param md_alg    MD algorithm to use"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_md_alg"]
    pub fn x509write_crt_set_md_alg(ctx: *mut x509write_cert, md_alg: md_type_t);
}
extern "C" {
    #[doc = " \\brief           Generic function to add to or replace an extension in the"]
    #[doc = "                  CRT"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param oid       OID of the extension"]
    #[doc = " \\param oid_len   length of the OID"]
    #[doc = " \\param critical  if the extension is critical (per the RFC's definition)"]
    #[doc = " \\param val       value of the extension OCTET STRING"]
    #[doc = " \\param val_len   length of the value data"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_extension"]
    pub fn x509write_crt_set_extension(
        ctx: *mut x509write_cert,
        oid: *const crate::types::c_char,
        oid_len: usize,
        critical: crate::types::c_int,
        val: *const crate::types::c_uchar,
        val_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the basicConstraints extension for a CRT"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param is_ca     is this a CA certificate"]
    #[doc = " \\param max_pathlen   maximum length of certificate chains below this"]
    #[doc = "                      certificate (only for CA certificates, -1 is"]
    #[doc = "                      inlimited)"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_basic_constraints"]
    pub fn x509write_crt_set_basic_constraints(
        ctx: *mut x509write_cert,
        is_ca: crate::types::c_int,
        max_pathlen: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subjectKeyIdentifier extension for a CRT"]
    #[doc = "                  Requires that mbedtls_x509write_crt_set_subject_key() has been"]
    #[doc = "                  called before"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_subject_key_identifier"]
    pub fn x509write_crt_set_subject_key_identifier(
        ctx: *mut x509write_cert,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the authorityKeyIdentifier extension for a CRT"]
    #[doc = "                  Requires that mbedtls_x509write_crt_set_issuer_key() has been"]
    #[doc = "                  called before"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_authority_key_identifier"]
    pub fn x509write_crt_set_authority_key_identifier(
        ctx: *mut x509write_cert,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Key Usage Extension flags"]
    #[doc = "                  (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to use"]
    #[doc = " \\param key_usage key usage flags to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_key_usage"]
    pub fn x509write_crt_set_key_usage(
        ctx: *mut x509write_cert,
        key_usage: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Netscape Cert Type flags"]
    #[doc = "                  (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)"]
    #[doc = ""]
    #[doc = " \\param ctx           CRT context to use"]
    #[doc = " \\param ns_cert_type  Netscape Cert Type flags to set"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_x509write_crt_set_ns_cert_type"]
    pub fn x509write_crt_set_ns_cert_type(
        ctx: *mut x509write_cert,
        ns_cert_type: crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Free the contents of a CRT write context"]
    #[doc = ""]
    #[doc = " \\param ctx       CRT context to free"]
    #[link_name = "\u{1}mbedtls_x509write_crt_free"]
    pub fn x509write_crt_free(ctx: *mut x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 DER structure"]
    #[doc = "                  Note: data is written at the end of the buffer! Use the"]
    #[doc = "                        return value to determine where you should start"]
    #[doc = "                        using the buffer"]
    #[doc = ""]
    #[doc = " \\param ctx       certificate to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = " \\param f_rng     RNG function (for signature, see note)"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          length of data written if successful, or a specific"]
    #[doc = "                  error code"]
    #[doc = ""]
    #[doc = " \\note            f_rng may be NULL if RSA is used for signature and the"]
    #[doc = "                  signature is made offline (otherwise f_rng is desirable"]
    #[doc = "                  for countermeasures against timing attacks)."]
    #[doc = "                  ECDSA signatures always require a non-NULL f_rng."]
    #[link_name = "\u{1}mbedtls_x509write_crt_der"]
    pub fn x509write_crt_der(
        ctx: *mut x509write_cert,
        buf: *mut crate::types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 PEM string"]
    #[doc = ""]
    #[doc = " \\param ctx       certificate to write away"]
    #[doc = " \\param buf       buffer to write to"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = " \\param f_rng     RNG function (for signature, see note)"]
    #[doc = " \\param p_rng     RNG parameter"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific error code"]
    #[doc = ""]
    #[doc = " \\note            f_rng may be NULL if RSA is used for signature and the"]
    #[doc = "                  signature is made offline (otherwise f_rng is desirable"]
    #[doc = "                  for countermeasures against timing attacks)."]
    #[doc = "                  ECDSA signatures always require a non-NULL f_rng."]
    #[link_name = "\u{1}mbedtls_x509write_crt_pem"]
    pub fn x509write_crt_pem(
        ctx: *mut x509write_cert,
        buf: *mut crate::types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
#[doc = " \\brief          The DHM context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dhm_context {
    #[doc = "<  The size of \\p P in Bytes."]
    pub len: usize,
    #[doc = "<  The prime modulus."]
    pub P: mpi,
    #[doc = "<  The generator."]
    pub G: mpi,
    #[doc = "<  Our secret value."]
    pub X: mpi,
    #[doc = "<  Our public key = \\c G^X mod \\c P."]
    pub GX: mpi,
    #[doc = "<  The public key of the peer = \\c G^Y mod \\c P."]
    pub GY: mpi,
    #[doc = "<  The shared secret = \\c G^(XY) mod \\c P."]
    pub K: mpi,
    #[doc = "<  The cached value = \\c R^2 mod \\c P."]
    pub RP: mpi,
    #[doc = "<  The blinding value."]
    pub Vi: mpi,
    #[doc = "<  The unblinding value."]
    pub Vf: mpi,
    #[doc = "<  The previous \\c X."]
    pub pX: mpi,
}
#[test]
fn bindgen_test_layout_dhm_context() {
    assert_eq!(
        ::core::mem::size_of::<dhm_context>(),
        124usize,
        concat!("Size of: ", stringify!(dhm_context))
    );
    assert_eq!(
        ::core::mem::align_of::<dhm_context>(),
        4usize,
        concat!("Alignment of ", stringify!(dhm_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).P as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).G as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).X as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).GX as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(GX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).GY as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(GY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).K as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(K)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).RP as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(RP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).Vi as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(Vi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).Vf as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(Vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).pX as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(pX)
        )
    );
}
impl Default for dhm_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes the DHM context."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to initialize."]
    #[link_name = "\u{1}mbedtls_dhm_init"]
    pub fn dhm_init(ctx: *mut dhm_context);
}
extern "C" {
    #[doc = " \\brief          This function parses the DHM parameters in a"]
    #[doc = "                 TLS ServerKeyExchange handshake message"]
    #[doc = "                 (DHM modulus, generator, and public key)."]
    #[doc = ""]
    #[doc = " \\note           In a TLS handshake, this is the how the client"]
    #[doc = "                 sets up its DHM context from the server's public"]
    #[doc = "                 DHM key material."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to use. This must be initialized."]
    #[doc = " \\param p        On input, *p must be the start of the input buffer."]
    #[doc = "                 On output, *p is updated to point to the end of the data"]
    #[doc = "                 that has been read. On success, this is the first byte"]
    #[doc = "                 past the end of the ServerKeyExchange parameters."]
    #[doc = "                 On error, this is the point at which an error has been"]
    #[doc = "                 detected, which is usually not useful except to debug"]
    #[doc = "                 failures."]
    #[doc = " \\param end      The end of the input buffer."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_dhm_read_params"]
    pub fn dhm_read_params(
        ctx: *mut dhm_context,
        p: *mut *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function generates a DHM key pair and exports its"]
    #[doc = "                 public part together with the DHM parameters in the format"]
    #[doc = "                 used in a TLS ServerKeyExchange handshake message."]
    #[doc = ""]
    #[doc = " \\note           This function assumes that the DHM parameters \\c ctx->P"]
    #[doc = "                 and \\c ctx->G have already been properly set. For that, use"]
    #[doc = "                 mbedtls_dhm_set_group() below in conjunction with"]
    #[doc = "                 mbedtls_mpi_read_binary() and mbedtls_mpi_read_string()."]
    #[doc = ""]
    #[doc = " \\note           In a TLS handshake, this is the how the server generates"]
    #[doc = "                 and exports its DHM key material."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to use. This must be initialized"]
    #[doc = "                 and have the DHM parameters set. It may or may not"]
    #[doc = "                 already have imported the peer's public key."]
    #[doc = " \\param x_size   The private key size in Bytes."]
    #[doc = " \\param olen     The address at which to store the number of Bytes"]
    #[doc = "                 written on success. This must not be \\c NULL."]
    #[doc = " \\param output   The destination buffer. This must be a writable buffer of"]
    #[doc = "                 sufficient size to hold the reduced binary presentation of"]
    #[doc = "                 the modulus, the generator and the public key, each wrapped"]
    #[doc = "                 with a 2-byte length field. It is the responsibility of the"]
    #[doc = "                 caller to ensure that enough space is available. Refer to"]
    #[doc = "                 mbedtls_mpi_size() to computing the byte-size of an MPI."]
    #[doc = " \\param f_rng    The RNG function. Must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be"]
    #[doc = "                 \\c NULL if \\p f_rng doesn't need a context parameter."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_dhm_make_params"]
    pub fn dhm_make_params(
        ctx: *mut dhm_context,
        x_size: crate::types::c_int,
        output: *mut crate::types::c_uchar,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets the prime modulus and generator."]
    #[doc = ""]
    #[doc = " \\note           This function can be used to set \\c ctx->P, \\c ctx->G"]
    #[doc = "                 in preparation for mbedtls_dhm_make_params()."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to configure. This must be initialized."]
    #[doc = " \\param P        The MPI holding the DHM prime modulus. This must be"]
    #[doc = "                 an initialized MPI."]
    #[doc = " \\param G        The MPI holding the DHM generator. This must be an"]
    #[doc = "                 initialized MPI."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_dhm_set_group"]
    pub fn dhm_set_group(
        ctx: *mut dhm_context,
        P: *const mpi,
        G: *const mpi,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports the raw public value of the peer."]
    #[doc = ""]
    #[doc = " \\note           In a TLS handshake, this is the how the server imports"]
    #[doc = "                 the Client's public DHM key."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to use. This must be initialized and have"]
    #[doc = "                 its DHM parameters set, e.g. via mbedtls_dhm_set_group()."]
    #[doc = "                 It may or may not already have generated its own private key."]
    #[doc = " \\param input    The input buffer containing the \\c G^Y value of the peer."]
    #[doc = "                 This must be a readable buffer of size \\p ilen Bytes."]
    #[doc = " \\param ilen     The size of the input buffer \\p input in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_dhm_read_public"]
    pub fn dhm_read_public(
        ctx: *mut dhm_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function creates a DHM key pair and exports"]
    #[doc = "                 the raw public key in big-endian format."]
    #[doc = ""]
    #[doc = " \\note           The destination buffer is always fully written"]
    #[doc = "                 so as to contain a big-endian representation of G^X mod P."]
    #[doc = "                 If it is larger than \\c ctx->len, it is padded accordingly"]
    #[doc = "                 with zero-bytes at the beginning."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to use. This must be initialized and"]
    #[doc = "                 have the DHM parameters set. It may or may not already"]
    #[doc = "                 have imported the peer's public key."]
    #[doc = " \\param x_size   The private key size in Bytes."]
    #[doc = " \\param output   The destination buffer. This must be a writable buffer of"]
    #[doc = "                 size \\p olen Bytes."]
    #[doc = " \\param olen     The length of the destination buffer. This must be at least"]
    #[doc = "                 equal to `ctx->len` (the size of \\c P)."]
    #[doc = " \\param f_rng    The RNG function. This must not be \\c NULL."]
    #[doc = " \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL"]
    #[doc = "                 if \\p f_rng doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_dhm_make_public"]
    pub fn dhm_make_public(
        ctx: *mut dhm_context,
        x_size: crate::types::c_int,
        output: *mut crate::types::c_uchar,
        olen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function derives and exports the shared secret"]
    #[doc = "                 \\c (G^Y)^X mod \\c P."]
    #[doc = ""]
    #[doc = " \\note           If \\p f_rng is not \\c NULL, it is used to blind the input as"]
    #[doc = "                 a countermeasure against timing attacks. Blinding is used"]
    #[doc = "                 only if our private key \\c X is re-used, and not used"]
    #[doc = "                 otherwise. We recommend always passing a non-NULL"]
    #[doc = "                 \\p f_rng argument."]
    #[doc = ""]
    #[doc = " \\param ctx           The DHM context to use. This must be initialized"]
    #[doc = "                      and have its own private key generated and the peer's"]
    #[doc = "                      public key imported."]
    #[doc = " \\param output        The buffer to write the generated shared key to. This"]
    #[doc = "                      must be a writable buffer of size \\p output_size Bytes."]
    #[doc = " \\param output_size   The size of the destination buffer. This must be at"]
    #[doc = "                      least the size of \\c ctx->len (the size of \\c P)."]
    #[doc = " \\param olen          On exit, holds the actual number of Bytes written."]
    #[doc = " \\param f_rng         The RNG function, for blinding purposes. This may"]
    #[doc = "                      b \\c NULL if blinding isn't needed."]
    #[doc = " \\param p_rng         The RNG context. This may be \\c NULL if \\p f_rng"]
    #[doc = "                      doesn't need a context argument."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_dhm_calc_secret"]
    pub fn dhm_calc_secret(
        ctx: *mut dhm_context,
        output: *mut crate::types::c_uchar,
        output_size: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function frees and clears the components"]
    #[doc = "                 of a DHM context."]
    #[doc = ""]
    #[doc = " \\param ctx      The DHM context to free and clear. This may be \\c NULL,"]
    #[doc = "                 in which case this function is a no-op. If it is not \\c NULL,"]
    #[doc = "                 it must point to an initialized DHM context."]
    #[link_name = "\u{1}mbedtls_dhm_free"]
    pub fn dhm_free(ctx: *mut dhm_context);
}
extern "C" {
    #[doc = " \\brief             This function parses DHM parameters in PEM or DER format."]
    #[doc = ""]
    #[doc = " \\param dhm         The DHM context to import the DHM parameters into."]
    #[doc = "                    This must be initialized."]
    #[doc = " \\param dhmin       The input buffer. This must be a readable buffer of"]
    #[doc = "                    length \\p dhminlen Bytes."]
    #[doc = " \\param dhminlen    The size of the input buffer \\p dhmin, including the"]
    #[doc = "                    terminating \\c NULL Byte for PEM data."]
    #[doc = ""]
    #[doc = " \\return            \\c 0 on success."]
    #[doc = " \\return            An \\c MBEDTLS_ERR_DHM_XXX or \\c MBEDTLS_ERR_PEM_XXX error"]
    #[doc = "                    code on failure."]
    #[link_name = "\u{1}mbedtls_dhm_parse_dhm"]
    pub fn dhm_parse_dhm(
        dhm: *mut dhm_context,
        dhmin: *const crate::types::c_uchar,
        dhminlen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          The DMH checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_dhm_self_test"]
    pub fn dhm_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ssl_premaster_secret {
    pub _pms_rsa: [crate::types::c_uchar; 48usize],
    pub _pms_dhm: [crate::types::c_uchar; 256usize],
    pub _pms_ecdh: [crate::types::c_uchar; 66usize],
    pub _pms_psk: [crate::types::c_uchar; 68usize],
    pub _pms_dhe_psk: [crate::types::c_uchar; 292usize],
    pub _pms_rsa_psk: [crate::types::c_uchar; 84usize],
    pub _pms_ecdhe_psk: [crate::types::c_uchar; 102usize],
    _bindgen_union_align: [u8; 292usize],
}
#[test]
fn bindgen_test_layout_ssl_premaster_secret() {
    assert_eq!(
        ::core::mem::size_of::<ssl_premaster_secret>(),
        292usize,
        concat!("Size of: ", stringify!(ssl_premaster_secret))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_premaster_secret>(),
        1usize,
        concat!("Alignment of ", stringify!(ssl_premaster_secret))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_dhm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_dhm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_ecdh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_ecdh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_psk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_psk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_dhe_psk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_dhe_psk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_rsa_psk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_rsa_psk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_ecdhe_psk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_ecdhe_psk)
        )
    );
}
impl Default for ssl_premaster_secret {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ssl_states {
    SSL_HELLO_REQUEST = 0,
    SSL_CLIENT_HELLO = 1,
    SSL_SERVER_HELLO = 2,
    SSL_SERVER_CERTIFICATE = 3,
    SSL_SERVER_KEY_EXCHANGE = 4,
    SSL_CERTIFICATE_REQUEST = 5,
    SSL_SERVER_HELLO_DONE = 6,
    SSL_CLIENT_CERTIFICATE = 7,
    SSL_CLIENT_KEY_EXCHANGE = 8,
    SSL_CERTIFICATE_VERIFY = 9,
    SSL_CLIENT_CHANGE_CIPHER_SPEC = 10,
    SSL_CLIENT_FINISHED = 11,
    SSL_SERVER_CHANGE_CIPHER_SPEC = 12,
    SSL_SERVER_FINISHED = 13,
    SSL_FLUSH_BUFFERS = 14,
    SSL_HANDSHAKE_WRAPUP = 15,
    SSL_HANDSHAKE_OVER = 16,
    SSL_SERVER_NEW_SESSION_TICKET = 17,
    SSL_SERVER_HELLO_VERIFY_REQUEST_SENT = 18,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum tls_prf_types {
    SSL_TLS_PRF_NONE = 0,
    SSL_TLS_PRF_SSL3 = 1,
    SSL_TLS_PRF_TLS1 = 2,
    SSL_TLS_PRF_SHA384 = 3,
    SSL_TLS_PRF_SHA256 = 4,
}
#[doc = " \\brief          Callback type: send data on the network."]
#[doc = ""]
#[doc = " \\note           That callback may be either blocking or non-blocking."]
#[doc = ""]
#[doc = " \\param ctx      Context for the send callback (typically a file descriptor)"]
#[doc = " \\param buf      Buffer holding the data to send"]
#[doc = " \\param len      Length of the data to send"]
#[doc = ""]
#[doc = " \\return         The callback must return the number of bytes sent if any,"]
#[doc = "                 or a non-zero error code."]
#[doc = "                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_WRITE"]
#[doc = "                 must be returned when the operation would block."]
#[doc = ""]
#[doc = " \\note           The callback is allowed to send fewer bytes than requested."]
#[doc = "                 It must always return the number of bytes actually sent."]
pub type ssl_send_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::types::c_void,
        buf: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network."]
#[doc = ""]
#[doc = " \\note           That callback may be either blocking or non-blocking."]
#[doc = ""]
#[doc = " \\param ctx      Context for the receive callback (typically a file"]
#[doc = "                 descriptor)"]
#[doc = " \\param buf      Buffer to write the received data to"]
#[doc = " \\param len      Length of the receive buffer"]
#[doc = ""]
#[doc = " \\return         The callback must return the number of bytes received,"]
#[doc = "                 or a non-zero error code."]
#[doc = "                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_READ"]
#[doc = "                 must be returned when the operation would block."]
#[doc = ""]
#[doc = " \\note           The callback may receive fewer bytes than the length of the"]
#[doc = "                 buffer. It must always return the number of bytes actually"]
#[doc = "                 received and written to the buffer."]
pub type ssl_recv_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::types::c_void,
        buf: *mut crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network, with timeout"]
#[doc = ""]
#[doc = " \\note           That callback must block until data is received, or the"]
#[doc = "                 timeout delay expires, or the operation is interrupted by a"]
#[doc = "                 signal."]
#[doc = ""]
#[doc = " \\param ctx      Context for the receive callback (typically a file descriptor)"]
#[doc = " \\param buf      Buffer to write the received data to"]
#[doc = " \\param len      Length of the receive buffer"]
#[doc = " \\param timeout  Maximum nomber of millisecondes to wait for data"]
#[doc = "                 0 means no timeout (potentially waiting forever)"]
#[doc = ""]
#[doc = " \\return         The callback must return the number of bytes received,"]
#[doc = "                 or a non-zero error code:"]
#[doc = "                 \\c MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,"]
#[doc = "                 \\c MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal."]
#[doc = ""]
#[doc = " \\note           The callback may receive fewer bytes than the length of the"]
#[doc = "                 buffer. It must always return the number of bytes actually"]
#[doc = "                 received and written to the buffer."]
pub type ssl_recv_timeout_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::types::c_void,
        buf: *mut crate::types::c_uchar,
        len: usize,
        timeout: u32,
    ) -> crate::types::c_int,
>;
#[doc = " \\brief          Callback type: set a pair of timers/delays to watch"]
#[doc = ""]
#[doc = " \\param ctx      Context pointer"]
#[doc = " \\param int_ms   Intermediate delay in milliseconds"]
#[doc = " \\param fin_ms   Final delay in milliseconds"]
#[doc = "                 0 cancels the current timer."]
#[doc = ""]
#[doc = " \\note           This callback must at least store the necessary information"]
#[doc = "                 for the associated \\c mbedtls_ssl_get_timer_t callback to"]
#[doc = "                 return correct information."]
#[doc = ""]
#[doc = " \\note           If using a event-driven style of programming, an event must"]
#[doc = "                 be generated when the final delay is passed. The event must"]
#[doc = "                 cause a call to \\c mbedtls_ssl_handshake() with the proper"]
#[doc = "                 SSL context to be scheduled. Care must be taken to ensure"]
#[doc = "                 that at most one such call happens at a time."]
#[doc = ""]
#[doc = " \\note           Only one timer at a time must be running. Calling this"]
#[doc = "                 function while a timer is running must cancel it. Cancelled"]
#[doc = "                 timers must not generate any event."]
pub type ssl_set_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::types::c_void, int_ms: u32, fin_ms: u32),
>;
#[doc = " \\brief          Callback type: get status of timers/delays"]
#[doc = ""]
#[doc = " \\param ctx      Context pointer"]
#[doc = ""]
#[doc = " \\return         This callback must return:"]
#[doc = "                 -1 if cancelled (fin_ms == 0),"]
#[doc = "                  0 if none of the delays have passed,"]
#[doc = "                  1 if only the intermediate delay has passed,"]
#[doc = "                  2 if the final delay has passed."]
pub type ssl_get_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::types::c_void) -> crate::types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_session {
    #[doc = "< chosen ciphersuite"]
    pub ciphersuite: crate::types::c_int,
    #[doc = "< chosen compression"]
    pub compression: crate::types::c_int,
    #[doc = "< session id length"]
    pub id_len: usize,
    #[doc = "< session identifier"]
    pub id: [crate::types::c_uchar; 32usize],
    #[doc = "< the master secret"]
    pub master: [crate::types::c_uchar; 48usize],
    #[doc = "< peer X.509 cert chain"]
    pub peer_cert: *mut x509_crt,
    #[doc = "<  verification result"]
    pub verify_result: u32,
    #[doc = "< RFC 5077 session ticket"]
    pub ticket: *mut crate::types::c_uchar,
    #[doc = "< session ticket length"]
    pub ticket_len: usize,
    #[doc = "< ticket lifetime hint"]
    pub ticket_lifetime: u32,
    #[doc = "< MaxFragmentLength negotiated by peer"]
    pub mfl_code: crate::types::c_uchar,
    #[doc = "< flag for truncated hmac activation"]
    pub trunc_hmac: crate::types::c_int,
    #[doc = "< flag for EtM activation"]
    pub encrypt_then_mac: crate::types::c_int,
}
#[test]
fn bindgen_test_layout_ssl_session() {
    assert_eq!(
        ::core::mem::size_of::<ssl_session>(),
        124usize,
        concat!("Size of: ", stringify!(ssl_session))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_session>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_session))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).ciphersuite as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ciphersuite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).compression as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(compression)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).id_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(id_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).master as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(master)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).peer_cert as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(peer_cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).verify_result as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(verify_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).ticket as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ticket)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).ticket_len as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ticket_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).ticket_lifetime as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ticket_lifetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).mfl_code as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(mfl_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).trunc_hmac as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(trunc_hmac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).encrypt_then_mac as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(encrypt_then_mac)
        )
    );
}
impl Default for ssl_session {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " SSL/TLS configuration to be shared between mbedtls_ssl_context structures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_config {
    #[doc = "< allowed ciphersuites per version"]
    pub ciphersuite_list: [*const crate::types::c_int; 4usize],
    #[doc = " Callback for printing debug output"]
    pub f_dbg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: crate::types::c_int,
            arg3: *const crate::types::c_char,
            arg4: crate::types::c_int,
            arg5: *const crate::types::c_char,
        ),
    >,
    #[doc = "< context for the debug function"]
    pub p_dbg: *mut crate::types::c_void,
    #[doc = " Callback for getting (pseudo-)random numbers"]
    pub f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut crate::types::c_uchar,
            arg3: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for the RNG function"]
    pub p_rng: *mut crate::types::c_void,
    #[doc = " Callback to retrieve a session from the cache"]
    pub f_get_cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut ssl_session,
        ) -> crate::types::c_int,
    >,
    #[doc = " Callback to store a session into the cache"]
    pub f_set_cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *const ssl_session,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for cache callbacks"]
    pub p_cache: *mut crate::types::c_void,
    #[doc = " Callback for setting cert according to SNI extension"]
    pub f_sni: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut ssl_context,
            arg3: *const crate::types::c_uchar,
            arg4: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for SNI callback"]
    pub p_sni: *mut crate::types::c_void,
    #[doc = " Callback to customize X.509 certificate chain verification"]
    pub f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut x509_crt,
            arg3: crate::types::c_int,
            arg4: *mut u32,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for X.509 verify calllback"]
    pub p_vrfy: *mut crate::types::c_void,
    #[doc = " Callback to retrieve PSK key from identity"]
    pub f_psk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut ssl_context,
            arg3: *const crate::types::c_uchar,
            arg4: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for PSK callback"]
    pub p_psk: *mut crate::types::c_void,
    #[doc = " Callback to create & write a cookie for ClientHello veirifcation"]
    pub f_cookie_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut *mut crate::types::c_uchar,
            arg3: *mut crate::types::c_uchar,
            arg4: *const crate::types::c_uchar,
            arg5: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = " Callback to verify validity of a ClientHello cookie"]
    pub f_cookie_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *const crate::types::c_uchar,
            arg3: usize,
            arg4: *const crate::types::c_uchar,
            arg5: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for the cookie callbacks"]
    pub p_cookie: *mut crate::types::c_void,
    #[doc = " Callback to create & write a session ticket"]
    pub f_ticket_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *const ssl_session,
            arg3: *mut crate::types::c_uchar,
            arg4: *const crate::types::c_uchar,
            arg5: *mut usize,
            arg6: *mut u32,
        ) -> crate::types::c_int,
    >,
    #[doc = " Callback to parse a session ticket into a session structure"]
    pub f_ticket_parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut ssl_session,
            arg3: *mut crate::types::c_uchar,
            arg4: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for the ticket callbacks"]
    pub p_ticket: *mut crate::types::c_void,
    #[doc = " Callback to export key block and master secret"]
    pub f_export_keys: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *const crate::types::c_uchar,
            arg3: *const crate::types::c_uchar,
            arg4: usize,
            arg5: usize,
            arg6: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = " Callback to export key block, master secret,"]
    #[doc = "  tls_prf and random bytes. Should replace f_export_keys"]
    pub f_export_keys_ext: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *const crate::types::c_uchar,
            arg3: *const crate::types::c_uchar,
            arg4: usize,
            arg5: usize,
            arg6: usize,
            arg7: *const crate::types::c_uchar,
            arg8: *const crate::types::c_uchar,
            arg9: tls_prf_types,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for key export callback"]
    pub p_export_keys: *mut crate::types::c_void,
    #[doc = "< verification profile"]
    pub cert_profile: *const x509_crt_profile,
    #[doc = "< own certificate/key pair(s)"]
    pub key_cert: *mut ssl_key_cert,
    #[doc = "< trusted CAs"]
    pub ca_chain: *mut x509_crt,
    #[doc = "< trusted CAs CRLs"]
    pub ca_crl: *mut x509_crl,
    pub f_ca_cb: x509_crt_ca_cb_t,
    pub p_ca_cb: *mut crate::types::c_void,
    #[doc = "< allowed signature hashes"]
    pub sig_hashes: *const crate::types::c_int,
    #[doc = "< allowed curves"]
    pub curve_list: *const ecp_group_id,
    #[doc = "< prime modulus for DHM"]
    pub dhm_P: mpi,
    #[doc = "< generator for DHM"]
    pub dhm_G: mpi,
    #[doc = "< The raw pre-shared key. This field should"]
    #[doc = "   only be set via mbedtls_ssl_conf_psk()."]
    #[doc = "   If either no PSK or an opaque PSK"]
    #[doc = "   have been configured, this has value NULL."]
    pub psk: *mut crate::types::c_uchar,
    #[doc = "< The length of the raw pre-shared key."]
    #[doc = "   This field should only be set via"]
    #[doc = "   mbedtls_ssl_conf_psk()."]
    #[doc = "   Its value is non-zero if and only if"]
    #[doc = "   \\c psk is not \\c NULL."]
    pub psk_len: usize,
    #[doc = "< The PSK identity for PSK negotiation."]
    #[doc = "   This field should only be set via"]
    #[doc = "   mbedtls_ssl_conf_psk()."]
    #[doc = "   This is set if and only if either"]
    #[doc = "   \\c psk or \\c psk_opaque are set."]
    pub psk_identity: *mut crate::types::c_uchar,
    #[doc = "< The length of PSK identity."]
    #[doc = "   This field should only be set via"]
    #[doc = "   mbedtls_ssl_conf_psk()."]
    #[doc = "   Its value is non-zero if and only if"]
    #[doc = "   \\c psk is not \\c NULL or \\c psk_opaque"]
    #[doc = "   is not \\c 0."]
    pub psk_identity_len: usize,
    #[doc = "< ordered list of protocols"]
    pub alpn_list: *mut *const crate::types::c_char,
    #[doc = "< timeout for mbedtls_ssl_read (ms)"]
    pub read_timeout: u32,
    #[doc = "< initial value of the handshake"]
    #[doc = "retransmission timeout (ms)"]
    pub hs_timeout_min: u32,
    #[doc = "< maximum value of the handshake"]
    #[doc = "retransmission timeout (ms)"]
    pub hs_timeout_max: u32,
    #[doc = "< grace period for renegotiation"]
    pub renego_max_records: crate::types::c_int,
    #[doc = "< value of the record counters"]
    #[doc = "that triggers renegotiation"]
    pub renego_period: [crate::types::c_uchar; 8usize],
    #[doc = "< limit of records with a bad MAC"]
    pub badmac_limit: crate::types::c_uint,
    #[doc = "< min. bit length of the DHM prime"]
    pub dhm_min_bitlen: crate::types::c_uint,
    #[doc = "< max. major version used"]
    pub max_major_ver: crate::types::c_uchar,
    #[doc = "< max. minor version used"]
    pub max_minor_ver: crate::types::c_uchar,
    #[doc = "< min. major version used"]
    pub min_major_ver: crate::types::c_uchar,
    #[doc = "< min. minor version used"]
    pub min_minor_ver: crate::types::c_uchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_ssl_config() {
    assert_eq!(
        ::core::mem::size_of::<ssl_config>(),
        220usize,
        concat!("Size of: ", stringify!(ssl_config))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_config>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_config))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).ciphersuite_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(ciphersuite_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_dbg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_dbg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_dbg as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_dbg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_rng as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_rng)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_rng as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_rng)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_get_cache as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_get_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_set_cache as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_set_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_cache as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_sni as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_sni)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_sni as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_sni)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_vrfy as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_vrfy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_vrfy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_vrfy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_psk as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_psk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_psk as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_psk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_cookie_write as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_cookie_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_cookie_check as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_cookie_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_cookie as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_ticket_write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_ticket_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_ticket_parse as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_ticket_parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_ticket as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_ticket)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_export_keys as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_export_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_export_keys_ext as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_export_keys_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_export_keys as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_export_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).cert_profile as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(cert_profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).key_cert as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(key_cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).ca_chain as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(ca_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).ca_crl as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(ca_crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_ca_cb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_ca_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_ca_cb as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_ca_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).sig_hashes as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(sig_hashes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).curve_list as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(curve_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).dhm_P as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(dhm_P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).dhm_G as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(dhm_G)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).psk as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).psk_len as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).psk_identity as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk_identity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).psk_identity_len as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk_identity_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).alpn_list as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(alpn_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).read_timeout as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(read_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).hs_timeout_min as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(hs_timeout_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).hs_timeout_max as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(hs_timeout_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).renego_max_records as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(renego_max_records)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).renego_period as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(renego_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).badmac_limit as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(badmac_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).dhm_min_bitlen as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(dhm_min_bitlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).max_major_ver as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(max_major_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).max_minor_ver as *const _ as usize },
        213usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(max_minor_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).min_major_ver as *const _ as usize },
        214usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(min_major_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).min_minor_ver as *const _ as usize },
        215usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(min_minor_ver)
        )
    );
}
impl Default for ssl_config {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ssl_config {
    #[inline]
    pub fn endpoint(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_endpoint(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transport(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transport(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authmode(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_authmode(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_legacy_renegotiation(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_allow_legacy_renegotiation(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn arc4_disabled(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arc4_disabled(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mfl_code(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mfl_code(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn encrypt_then_mac(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encrypt_then_mac(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_ms(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_extended_ms(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn anti_replay(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_anti_replay(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cbc_record_splitting(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cbc_record_splitting(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_renegotiation(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_renegotiation(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trunc_hmac(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trunc_hmac(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn session_tickets(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_session_tickets(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fallback(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fallback(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cert_req_ca_list(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cert_req_ca_list(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        endpoint: crate::types::c_uint,
        transport: crate::types::c_uint,
        authmode: crate::types::c_uint,
        allow_legacy_renegotiation: crate::types::c_uint,
        arc4_disabled: crate::types::c_uint,
        mfl_code: crate::types::c_uint,
        encrypt_then_mac: crate::types::c_uint,
        extended_ms: crate::types::c_uint,
        anti_replay: crate::types::c_uint,
        cbc_record_splitting: crate::types::c_uint,
        disable_renegotiation: crate::types::c_uint,
        trunc_hmac: crate::types::c_uint,
        session_tickets: crate::types::c_uint,
        fallback: crate::types::c_uint,
        cert_req_ca_list: crate::types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let endpoint: u32 = unsafe { ::core::mem::transmute(endpoint) };
            endpoint as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transport: u32 = unsafe { ::core::mem::transmute(transport) };
            transport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let authmode: u32 = unsafe { ::core::mem::transmute(authmode) };
            authmode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let allow_legacy_renegotiation: u32 =
                unsafe { ::core::mem::transmute(allow_legacy_renegotiation) };
            allow_legacy_renegotiation as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let arc4_disabled: u32 = unsafe { ::core::mem::transmute(arc4_disabled) };
            arc4_disabled as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let mfl_code: u32 = unsafe { ::core::mem::transmute(mfl_code) };
            mfl_code as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let encrypt_then_mac: u32 = unsafe { ::core::mem::transmute(encrypt_then_mac) };
            encrypt_then_mac as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let extended_ms: u32 = unsafe { ::core::mem::transmute(extended_ms) };
            extended_ms as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let anti_replay: u32 = unsafe { ::core::mem::transmute(anti_replay) };
            anti_replay as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let cbc_record_splitting: u32 = unsafe { ::core::mem::transmute(cbc_record_splitting) };
            cbc_record_splitting as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let disable_renegotiation: u32 =
                unsafe { ::core::mem::transmute(disable_renegotiation) };
            disable_renegotiation as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trunc_hmac: u32 = unsafe { ::core::mem::transmute(trunc_hmac) };
            trunc_hmac as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let session_tickets: u32 = unsafe { ::core::mem::transmute(session_tickets) };
            session_tickets as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let fallback: u32 = unsafe { ::core::mem::transmute(fallback) };
            fallback as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let cert_req_ca_list: u32 = unsafe { ::core::mem::transmute(cert_req_ca_list) };
            cert_req_ca_list as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_context {
    #[doc = "< configuration information"]
    pub conf: *const ssl_config,
    #[doc = "< SSL handshake: current state"]
    pub state: crate::types::c_int,
    #[doc = "< Initial, in progress, pending?"]
    pub renego_status: crate::types::c_int,
    #[doc = "< Records since renego request, or with DTLS,"]
    #[doc = "number of retransmissions of request if"]
    #[doc = "renego_max_records is < 0"]
    pub renego_records_seen: crate::types::c_int,
    #[doc = "< equal to  MBEDTLS_SSL_MAJOR_VERSION_3"]
    pub major_ver: crate::types::c_int,
    #[doc = "< either 0 (SSL3) or 1 (TLS1.0)"]
    pub minor_ver: crate::types::c_int,
    #[doc = "< records with a bad MAC received"]
    pub badmac_seen: crate::types::c_uint,
    #[doc = " Callback to customize X.509 certificate chain verification"]
    pub f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut x509_crt,
            arg3: crate::types::c_int,
            arg4: *mut u32,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for X.509 verify callback"]
    pub p_vrfy: *mut crate::types::c_void,
    #[doc = "< Callback for network send"]
    pub f_send: ssl_send_t,
    #[doc = "< Callback for network receive"]
    pub f_recv: ssl_recv_t,
    pub f_recv_timeout: ssl_recv_timeout_t,
    #[doc = "< context for I/O operations"]
    pub p_bio: *mut crate::types::c_void,
    #[doc = "<  current session data (in)"]
    pub session_in: *mut ssl_session,
    #[doc = "<  current session data (out)"]
    pub session_out: *mut ssl_session,
    #[doc = "<  negotiated session data"]
    pub session: *mut ssl_session,
    #[doc = "<  session data in negotiation"]
    pub session_negotiate: *mut ssl_session,
    #[doc = "<  params required only during"]
    #[doc = "the handshake process"]
    pub handshake: *mut ssl_handshake_params,
    #[doc = "<  current transform params (in)"]
    pub transform_in: *mut ssl_transform,
    #[doc = "<  current transform params (in)"]
    pub transform_out: *mut ssl_transform,
    #[doc = "<  negotiated transform params"]
    pub transform: *mut ssl_transform,
    #[doc = "<  transform params in negotiation"]
    pub transform_negotiate: *mut ssl_transform,
    #[doc = "< context for the timer callbacks"]
    pub p_timer: *mut crate::types::c_void,
    #[doc = "< set timer callback"]
    pub f_set_timer: ssl_set_timer_t,
    #[doc = "< get timer callback"]
    pub f_get_timer: ssl_get_timer_t,
    #[doc = "< input buffer"]
    pub in_buf: *mut crate::types::c_uchar,
    #[doc = "< 64-bit incoming message counter"]
    #[doc = "TLS: maintained by us"]
    #[doc = "DTLS: read from peer"]
    pub in_ctr: *mut crate::types::c_uchar,
    #[doc = "< start of record header"]
    pub in_hdr: *mut crate::types::c_uchar,
    #[doc = "< two-bytes message length field"]
    pub in_len: *mut crate::types::c_uchar,
    #[doc = "< ivlen-byte IV"]
    pub in_iv: *mut crate::types::c_uchar,
    #[doc = "< message contents (in_iv+ivlen)"]
    pub in_msg: *mut crate::types::c_uchar,
    #[doc = "< read offset in application data"]
    pub in_offt: *mut crate::types::c_uchar,
    #[doc = "< record header: message type"]
    pub in_msgtype: crate::types::c_int,
    #[doc = "< record header: message length"]
    pub in_msglen: usize,
    #[doc = "< amount of data read so far"]
    pub in_left: usize,
    #[doc = "< DTLS epoch for incoming records"]
    pub in_epoch: u16,
    #[doc = "< offset of the next record in datagram"]
    #[doc = "(equal to in_left if none)"]
    pub next_record_offset: usize,
    #[doc = "< last validated record seq_num"]
    pub in_window_top: u64,
    #[doc = "< bitmask for replay detection"]
    pub in_window: u64,
    #[doc = "< current handshake message length,"]
    #[doc = "including the handshake header"]
    pub in_hslen: usize,
    #[doc = "< # of 0-length encrypted messages"]
    pub nb_zero: crate::types::c_int,
    #[doc = "< drop or reuse current message"]
    #[doc = "on next call to record layer?"]
    pub keep_current_message: crate::types::c_int,
    #[doc = "< Disable packing multiple records"]
    #[doc = "   within a single datagram."]
    pub disable_datagram_packing: u8,
    #[doc = "< output buffer"]
    pub out_buf: *mut crate::types::c_uchar,
    #[doc = "< 64-bit outgoing message counter"]
    pub out_ctr: *mut crate::types::c_uchar,
    #[doc = "< start of record header"]
    pub out_hdr: *mut crate::types::c_uchar,
    #[doc = "< two-bytes message length field"]
    pub out_len: *mut crate::types::c_uchar,
    #[doc = "< ivlen-byte IV"]
    pub out_iv: *mut crate::types::c_uchar,
    #[doc = "< message contents (out_iv+ivlen)"]
    pub out_msg: *mut crate::types::c_uchar,
    #[doc = "< record header: message type"]
    pub out_msgtype: crate::types::c_int,
    #[doc = "< record header: message length"]
    pub out_msglen: usize,
    #[doc = "< amount of data not yet written"]
    pub out_left: usize,
    #[doc = "<  Outgoing record sequence  number."]
    pub cur_out_ctr: [crate::types::c_uchar; 8usize],
    #[doc = "< path mtu, used to fragment outgoing messages"]
    pub mtu: u16,
    #[doc = "< current record already splitted?"]
    pub split_done: crate::types::c_schar,
    #[doc = "<  flag for client auth."]
    pub client_auth: crate::types::c_int,
    #[doc = "< expected peer CN for verification"]
    #[doc = "(and SNI if available)"]
    pub hostname: *mut crate::types::c_char,
    #[doc = "<  negotiated protocol"]
    pub alpn_chosen: *const crate::types::c_char,
    #[doc = "<  transport-level ID of the client"]
    pub cli_id: *mut crate::types::c_uchar,
    #[doc = "<  length of cli_id"]
    pub cli_id_len: usize,
    #[doc = "<  does peer support legacy or"]
    #[doc = "secure renegotiation"]
    pub secure_renegotiation: crate::types::c_int,
    #[doc = "<  length of verify data stored"]
    pub verify_data_len: usize,
    #[doc = "<  previous handshake verify data"]
    pub own_verify_data: [crate::types::c_char; 12usize],
    #[doc = "<  previous handshake verify data"]
    pub peer_verify_data: [crate::types::c_char; 12usize],
}
#[test]
fn bindgen_test_layout_ssl_context() {
    assert_eq!(
        ::core::mem::size_of::<ssl_context>(),
        288usize,
        concat!("Size of: ", stringify!(ssl_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).renego_status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(renego_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).renego_records_seen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(renego_records_seen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).major_ver as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(major_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).minor_ver as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(minor_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).badmac_seen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(badmac_seen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_vrfy as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_vrfy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).p_vrfy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(p_vrfy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_send as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_send)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_recv as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_recv_timeout as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_recv_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).p_bio as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(p_bio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).session_in as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).session_out as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).session as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).session_negotiate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session_negotiate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).handshake as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(handshake)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).transform_in as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).transform_out as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).transform as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).transform_negotiate as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform_negotiate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).p_timer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(p_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_set_timer as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_set_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_get_timer as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_get_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_buf as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_ctr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_hdr as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_len as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_iv as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_msg as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_offt as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_offt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_msgtype as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_msgtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_msglen as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_msglen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_left as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_epoch as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_epoch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).next_record_offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(next_record_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_window_top as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_window_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_window as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_hslen as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_hslen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).nb_zero as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(nb_zero)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).keep_current_message as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(keep_current_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).disable_datagram_packing as *const _ as usize
        },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(disable_datagram_packing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_buf as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_ctr as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_hdr as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_len as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_iv as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_msg as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_msgtype as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_msgtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_msglen as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_msglen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_left as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).cur_out_ctr as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(cur_out_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).mtu as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).split_done as *const _ as usize },
        230usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(split_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).client_auth as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(client_auth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).hostname as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).alpn_chosen as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(alpn_chosen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).cli_id as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(cli_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).cli_id_len as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(cli_id_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).secure_renegotiation as *const _ as usize
        },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(secure_renegotiation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).verify_data_len as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(verify_data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).own_verify_data as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(own_verify_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).peer_verify_data as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(peer_verify_data)
        )
    );
}
impl Default for ssl_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief               Return the name of the ciphersuite associated with the"]
    #[doc = "                      given ID"]
    #[doc = ""]
    #[doc = " \\param ciphersuite_id SSL ciphersuite ID"]
    #[doc = ""]
    #[doc = " \\return              a string containing the ciphersuite name"]
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite_name"]
    pub fn ssl_get_ciphersuite_name(
        ciphersuite_id: crate::types::c_int,
    ) -> *const crate::types::c_char;
}
extern "C" {
    #[doc = " \\brief               Return the ID of the ciphersuite associated with the"]
    #[doc = "                      given name"]
    #[doc = ""]
    #[doc = " \\param ciphersuite_name SSL ciphersuite name"]
    #[doc = ""]
    #[doc = " \\return              the ID with the ciphersuite or 0 if not found"]
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite_id"]
    pub fn ssl_get_ciphersuite_id(
        ciphersuite_name: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL context"]
    #[doc = "                 Just makes the context ready for mbedtls_ssl_setup() or"]
    #[doc = "                 mbedtls_ssl_free()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[link_name = "\u{1}mbedtls_ssl_init"]
    pub fn ssl_init(ssl: *mut ssl_context);
}
extern "C" {
    #[doc = " \\brief          Set up an SSL context for use"]
    #[doc = ""]
    #[doc = " \\note           No copy of the configuration context is made, it can be"]
    #[doc = "                 shared by many mbedtls_ssl_context structures."]
    #[doc = ""]
    #[doc = " \\warning        The conf structure will be accessed during the session."]
    #[doc = "                 It must not be modified or freed as long as the session"]
    #[doc = "                 is active."]
    #[doc = ""]
    #[doc = " \\warning        This function must be called exactly once per context."]
    #[doc = "                 Calling mbedtls_ssl_setup again is not supported, even"]
    #[doc = "                 if no session is active."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param conf     SSL configuration to use"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if"]
    #[doc = "                 memory allocation failed"]
    #[link_name = "\u{1}mbedtls_ssl_setup"]
    pub fn ssl_setup(ssl: *mut ssl_context, conf: *const ssl_config) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Reset an already initialized SSL context for re-use"]
    #[doc = "                 while retaining application-set variables, function"]
    #[doc = "                 pointers and data."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED,"]
    #[doc = "MBEDTLS_ERR_SSL_HW_ACCEL_FAILED or"]
    #[doc = "                 MBEDTLS_ERR_SSL_COMPRESSION_FAILED"]
    #[link_name = "\u{1}mbedtls_ssl_session_reset"]
    pub fn ssl_session_reset(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the current endpoint type"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param endpoint must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER"]
    #[link_name = "\u{1}mbedtls_ssl_conf_endpoint"]
    pub fn ssl_conf_endpoint(conf: *mut ssl_config, endpoint: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief           Set the transport type (TLS or DTLS)."]
    #[doc = "                  Default: TLS"]
    #[doc = ""]
    #[doc = " \\note            For DTLS, you must either provide a recv callback that"]
    #[doc = "                  doesn't block, or one that handles timeouts, see"]
    #[doc = "                  \\c mbedtls_ssl_set_bio(). You also need to provide timer"]
    #[doc = "                  callbacks with \\c mbedtls_ssl_set_timer_cb()."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration"]
    #[doc = " \\param transport transport type:"]
    #[doc = "                  MBEDTLS_SSL_TRANSPORT_STREAM for TLS,"]
    #[doc = "                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS."]
    #[link_name = "\u{1}mbedtls_ssl_conf_transport"]
    pub fn ssl_conf_transport(conf: *mut ssl_config, transport: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          Set the certificate verification mode"]
    #[doc = "                 Default: NONE on server, REQUIRED on client"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param authmode can be:"]
    #[doc = ""]
    #[doc = "  MBEDTLS_SSL_VERIFY_NONE:      peer certificate is not checked"]
    #[doc = "                        (default on server)"]
    #[doc = "                        (insecure on client)"]
    #[doc = ""]
    #[doc = "  MBEDTLS_SSL_VERIFY_OPTIONAL:  peer certificate is checked, however the"]
    #[doc = "                        handshake continues even if verification failed;"]
    #[doc = "                        mbedtls_ssl_get_verify_result() can be called after the"]
    #[doc = "                        handshake is complete."]
    #[doc = ""]
    #[doc = "  MBEDTLS_SSL_VERIFY_REQUIRED:  peer *must* present a valid certificate,"]
    #[doc = "                        handshake is aborted if verification failed."]
    #[doc = "                        (default on client)"]
    #[doc = ""]
    #[doc = " \\note On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode."]
    #[doc = " With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call mbedtls_ssl_get_verify_result() at"]
    #[doc = " the right time(s), which may not be obvious, while REQUIRED always perform"]
    #[doc = " the verification as soon as possible. For example, REQUIRED was protecting"]
    #[doc = " against the \"triple handshake\" attack even before it was found."]
    #[link_name = "\u{1}mbedtls_ssl_conf_authmode"]
    pub fn ssl_conf_authmode(conf: *mut ssl_config, authmode: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          Set the verification callback (Optional)."]
    #[doc = ""]
    #[doc = "                 If set, the provided verify callback is called for each"]
    #[doc = "                 certificate in the peer's CRT chain, including the trusted"]
    #[doc = "                 root. For more information, please see the documentation of"]
    #[doc = "                 \\c mbedtls_x509_crt_verify()."]
    #[doc = ""]
    #[doc = " \\note           For per context callbacks and contexts, please use"]
    #[doc = "                 mbedtls_ssl_set_verify() instead."]
    #[doc = ""]
    #[doc = " \\param conf     The SSL configuration to use."]
    #[doc = " \\param f_vrfy   The verification callback to use during CRT verification."]
    #[doc = " \\param p_vrfy   The opaque context to be passed to the callback."]
    #[link_name = "\u{1}mbedtls_ssl_conf_verify"]
    pub fn ssl_conf_verify(
        conf: *mut ssl_config,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut x509_crt,
                arg3: crate::types::c_int,
                arg4: *mut u32,
            ) -> crate::types::c_int,
        >,
        p_vrfy: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the random number generator callback"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_rng    RNG function"]
    #[doc = " \\param p_rng    RNG parameter"]
    #[link_name = "\u{1}mbedtls_ssl_conf_rng"]
    pub fn ssl_conf_rng(
        conf: *mut ssl_config,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the debug callback"]
    #[doc = ""]
    #[doc = "                 The callback has the following argument:"]
    #[doc = "                 void *           opaque context for the callback"]
    #[doc = "                 int              debug level"]
    #[doc = "                 const char *     file name"]
    #[doc = "                 int              line number"]
    #[doc = "                 const char *     message"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_dbg    debug function"]
    #[doc = " \\param p_dbg    debug parameter"]
    #[link_name = "\u{1}mbedtls_ssl_conf_dbg"]
    pub fn ssl_conf_dbg(
        conf: *mut ssl_config,
        f_dbg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: crate::types::c_int,
                arg3: *const crate::types::c_char,
                arg4: crate::types::c_int,
                arg5: *const crate::types::c_char,
            ),
        >,
        p_dbg: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the underlying BIO callbacks for write, read and"]
    #[doc = "                 read-with-timeout."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param p_bio    parameter (context) shared by BIO callbacks"]
    #[doc = " \\param f_send   write callback"]
    #[doc = " \\param f_recv   read callback"]
    #[doc = " \\param f_recv_timeout blocking read callback with timeout."]
    #[doc = ""]
    #[doc = " \\note           One of f_recv or f_recv_timeout can be NULL, in which case"]
    #[doc = "                 the other is used. If both are non-NULL, f_recv_timeout is"]
    #[doc = "                 used and f_recv is ignored (as if it were NULL)."]
    #[doc = ""]
    #[doc = " \\note           The two most common use cases are:"]
    #[doc = "                 - non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL"]
    #[doc = "                 - blocking I/O, f_recv == NULL, f_recv_timout != NULL"]
    #[doc = ""]
    #[doc = " \\note           For DTLS, you need to provide either a non-NULL"]
    #[doc = "                 f_recv_timeout callback, or a f_recv that doesn't block."]
    #[doc = ""]
    #[doc = " \\note           See the documentations of \\c mbedtls_ssl_sent_t,"]
    #[doc = "                 \\c mbedtls_ssl_recv_t and \\c mbedtls_ssl_recv_timeout_t for"]
    #[doc = "                 the conventions those callbacks must follow."]
    #[doc = ""]
    #[doc = " \\note           On some platforms, net_sockets.c provides"]
    #[doc = "                 \\c mbedtls_net_send(), \\c mbedtls_net_recv() and"]
    #[doc = "                 \\c mbedtls_net_recv_timeout() that are suitable to be used"]
    #[doc = "                 here."]
    #[link_name = "\u{1}mbedtls_ssl_set_bio"]
    pub fn ssl_set_bio(
        ssl: *mut ssl_context,
        p_bio: *mut crate::types::c_void,
        f_send: ssl_send_t,
        f_recv: ssl_recv_t,
        f_recv_timeout: ssl_recv_timeout_t,
    );
}
extern "C" {
    #[doc = " \\brief          Set the Maximum Tranport Unit (MTU)."]
    #[doc = "                 Special value: 0 means unset (no limit)."]
    #[doc = "                 This represents the maximum size of a datagram payload"]
    #[doc = "                 handled by the transport layer (usually UDP) as determined"]
    #[doc = "                 by the network link and stack. In practice, this controls"]
    #[doc = "                 the maximum size datagram the DTLS layer will pass to the"]
    #[doc = "                 \\c f_send() callback set using \\c mbedtls_ssl_set_bio()."]
    #[doc = ""]
    #[doc = " \\note           The limit on datagram size is converted to a limit on"]
    #[doc = "                 record payload by subtracting the current overhead of"]
    #[doc = "                 encapsulation and encryption/authentication if any."]
    #[doc = ""]
    #[doc = " \\note           This can be called at any point during the connection, for"]
    #[doc = "                 example when a Path Maximum Transfer Unit (PMTU)"]
    #[doc = "                 estimate becomes available from other sources,"]
    #[doc = "                 such as lower (or higher) protocol layers."]
    #[doc = ""]
    #[doc = " \\note           This setting only controls the size of the packets we send,"]
    #[doc = "                 and does not restrict the size of the datagrams we're"]
    #[doc = "                 willing to receive. Client-side, you can request the"]
    #[doc = "                 server to use smaller records with \\c"]
    #[doc = "                 mbedtls_ssl_conf_max_frag_len()."]
    #[doc = ""]
    #[doc = " \\note           If both a MTU and a maximum fragment length have been"]
    #[doc = "                 configured (or negotiated with the peer), the resulting"]
    #[doc = "                 lower limit on record payload (see first note) is used."]
    #[doc = ""]
    #[doc = " \\note           This can only be used to decrease the maximum size"]
    #[doc = "                 of datagrams (hence records, see first note) sent. It"]
    #[doc = "                 cannot be used to increase the maximum size of records over"]
    #[doc = "                 the limit set by #MBEDTLS_SSL_OUT_CONTENT_LEN."]
    #[doc = ""]
    #[doc = " \\note           Values lower than the current record layer expansion will"]
    #[doc = "                 result in an error when trying to send data."]
    #[doc = ""]
    #[doc = " \\note           Using record compression together with a non-zero MTU value"]
    #[doc = "                 will result in an error when trying to send data."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param mtu      Value of the path MTU in bytes"]
    #[link_name = "\u{1}mbedtls_ssl_set_mtu"]
    pub fn ssl_set_mtu(ssl: *mut ssl_context, mtu: u16);
}
extern "C" {
    #[doc = " \\brief          Set a connection-specific verification callback (optional)."]
    #[doc = ""]
    #[doc = "                 If set, the provided verify callback is called for each"]
    #[doc = "                 certificate in the peer's CRT chain, including the trusted"]
    #[doc = "                 root. For more information, please see the documentation of"]
    #[doc = "                 \\c mbedtls_x509_crt_verify()."]
    #[doc = ""]
    #[doc = " \\note           This call is analogous to mbedtls_ssl_conf_verify() but"]
    #[doc = "                 binds the verification callback and context to an SSL context"]
    #[doc = "                 as opposed to an SSL configuration."]
    #[doc = "                 If mbedtls_ssl_conf_verify() and mbedtls_ssl_set_verify()"]
    #[doc = "                 are both used, mbedtls_ssl_set_verify() takes precedence."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to use."]
    #[doc = " \\param f_vrfy   The verification callback to use during CRT verification."]
    #[doc = " \\param p_vrfy   The opaque context to be passed to the callback."]
    #[link_name = "\u{1}mbedtls_ssl_set_verify"]
    pub fn ssl_set_verify(
        ssl: *mut ssl_context,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut x509_crt,
                arg3: crate::types::c_int,
                arg4: *mut u32,
            ) -> crate::types::c_int,
        >,
        p_vrfy: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the timeout period for mbedtls_ssl_read()"]
    #[doc = "                 (Default: no timeout.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    #[doc = " \\param timeout  Timeout value in milliseconds."]
    #[doc = "                 Use 0 for no timeout (default)."]
    #[doc = ""]
    #[doc = " \\note           With blocking I/O, this will only work if a non-NULL"]
    #[doc = "                 \\c f_recv_timeout was set with \\c mbedtls_ssl_set_bio()."]
    #[doc = "                 With non-blocking I/O, this will only work if timer"]
    #[doc = "                 callbacks were set with \\c mbedtls_ssl_set_timer_cb()."]
    #[doc = ""]
    #[doc = " \\note           With non-blocking I/O, you may also skip this function"]
    #[doc = "                 altogether and handle timeouts at the application layer."]
    #[link_name = "\u{1}mbedtls_ssl_conf_read_timeout"]
    pub fn ssl_conf_read_timeout(conf: *mut ssl_config, timeout: u32);
}
extern "C" {
    #[doc = " \\brief          Check whether a buffer contains a valid and authentic record"]
    #[doc = "                 that has not been seen before. (DTLS only)."]
    #[doc = ""]
    #[doc = "                 This function does not change the user-visible state"]
    #[doc = "                 of the SSL context. Its sole purpose is to provide"]
    #[doc = "                 an indication of the legitimacy of an incoming record."]
    #[doc = ""]
    #[doc = "                 This can be useful e.g. in distributed server environments"]
    #[doc = "                 using the DTLS Connection ID feature, in which connections"]
    #[doc = "                 might need to be passed between service instances on a change"]
    #[doc = "                 of peer address, but where such disruptive operations should"]
    #[doc = "                 only happen after the validity of incoming records has been"]
    #[doc = "                 confirmed."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to use."]
    #[doc = " \\param buf      The address of the buffer holding the record to be checked."]
    #[doc = "                 This must be a read/write buffer of length \\p buflen Bytes."]
    #[doc = " \\param buflen   The length of \\p buf in Bytes."]
    #[doc = ""]
    #[doc = " \\note           This routine only checks whether the provided buffer begins"]
    #[doc = "                 with a valid and authentic record that has not been seen"]
    #[doc = "                 before, but does not check potential data following the"]
    #[doc = "                 initial record. In particular, it is possible to pass DTLS"]
    #[doc = "                 datagrams containing multiple records, in which case only"]
    #[doc = "                 the first record is checked."]
    #[doc = ""]
    #[doc = " \\note           This function modifies the input buffer \\p buf. If you need"]
    #[doc = "                 to preserve the original record, you have to maintain a copy."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the record is valid and authentic and has not been"]
    #[doc = "                 seen before."]
    #[doc = " \\return         MBEDTLS_ERR_SSL_INVALID_MAC if the check completed"]
    #[doc = "                 successfully but the record was found to be not authentic."]
    #[doc = " \\return         MBEDTLS_ERR_SSL_INVALID_RECORD if the check completed"]
    #[doc = "                 successfully but the record was found to be invalid for"]
    #[doc = "                 a reason different from authenticity checking."]
    #[doc = " \\return         MBEDTLS_ERR_SSL_UNEXPECTED_RECORD if the check completed"]
    #[doc = "                 successfully but the record was found to be unexpected"]
    #[doc = "                 in the state of the SSL context, including replayed records."]
    #[doc = " \\return         Another negative error code on different kinds of failure."]
    #[doc = "                 In this case, the SSL context becomes unusable and needs"]
    #[doc = "                 to be freed or reset before reuse."]
    #[link_name = "\u{1}mbedtls_ssl_check_record"]
    pub fn ssl_check_record(
        ssl: *const ssl_context,
        buf: *mut crate::types::c_uchar,
        buflen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the timer callbacks (Mandatory for DTLS.)"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param p_timer  parameter (context) shared by timer callbacks"]
    #[doc = " \\param f_set_timer   set timer callback"]
    #[doc = " \\param f_get_timer   get timer callback. Must return:"]
    #[doc = ""]
    #[doc = " \\note           See the documentation of \\c mbedtls_ssl_set_timer_t and"]
    #[doc = "                 \\c mbedtls_ssl_get_timer_t for the conventions this pair of"]
    #[doc = "                 callbacks must follow."]
    #[doc = ""]
    #[doc = " \\note           On some platforms, timing.c provides"]
    #[doc = "                 \\c mbedtls_timing_set_delay() and"]
    #[doc = "                 \\c mbedtls_timing_get_delay() that are suitable for using"]
    #[doc = "                 here, except if using an event-driven style."]
    #[doc = ""]
    #[doc = " \\note           See also the \"DTLS tutorial\" article in our knowledge base."]
    #[doc = "                 https://tls.mbed.org/kb/how-to/dtls-tutorial"]
    #[link_name = "\u{1}mbedtls_ssl_set_timer_cb"]
    pub fn ssl_set_timer_cb(
        ssl: *mut ssl_context,
        p_timer: *mut crate::types::c_void,
        f_set_timer: ssl_set_timer_t,
        f_get_timer: ssl_get_timer_t,
    );
}
#[doc = " \\brief           Callback type: generate and write session ticket"]
#[doc = ""]
#[doc = " \\note            This describes what a callback implementation should do."]
#[doc = "                  This callback should generate an encrypted and"]
#[doc = "                  authenticated ticket for the session and write it to the"]
#[doc = "                  output buffer. Here, ticket means the opaque ticket part"]
#[doc = "                  of the NewSessionTicket structure of RFC 5077."]
#[doc = ""]
#[doc = " \\param p_ticket  Context for the callback"]
#[doc = " \\param session   SSL session to be written in the ticket"]
#[doc = " \\param start     Start of the output buffer"]
#[doc = " \\param end       End of the output buffer"]
#[doc = " \\param tlen      On exit, holds the length written"]
#[doc = " \\param lifetime  On exit, holds the lifetime of the ticket in seconds"]
#[doc = ""]
#[doc = " \\return          0 if successful, or"]
#[doc = "                  a specific MBEDTLS_ERR_XXX code."]
pub type ssl_ticket_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut crate::types::c_void,
        session: *const ssl_session,
        start: *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> crate::types::c_int,
>;
#[doc = " \\brief           Callback type: Export key block and master secret"]
#[doc = ""]
#[doc = " \\note            This is required for certain uses of TLS, e.g. EAP-TLS"]
#[doc = "                  (RFC 5216) and Thread. The key pointers are ephemeral and"]
#[doc = "                  therefore must not be stored. The master secret and keys"]
#[doc = "                  should not be used directly except as an input to a key"]
#[doc = "                  derivation function."]
#[doc = ""]
#[doc = " \\param p_expkey  Context for the callback"]
#[doc = " \\param ms        Pointer to master secret (fixed length: 48 bytes)"]
#[doc = " \\param kb        Pointer to key block, see RFC 5246 section 6.3"]
#[doc = "                  (variable length: 2 * maclen + 2 * keylen + 2 * ivlen)."]
#[doc = " \\param maclen    MAC length"]
#[doc = " \\param keylen    Key length"]
#[doc = " \\param ivlen     IV length"]
#[doc = ""]
#[doc = " \\return          0 if successful, or"]
#[doc = "                  a specific MBEDTLS_ERR_XXX code."]
pub type ssl_export_keys_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut crate::types::c_void,
        ms: *const crate::types::c_uchar,
        kb: *const crate::types::c_uchar,
        maclen: usize,
        keylen: usize,
        ivlen: usize,
    ) -> crate::types::c_int,
>;
#[doc = " \\brief           Callback type: Export key block, master secret,"]
#[doc = "                                 handshake randbytes and the tls_prf function"]
#[doc = "                                 used to derive keys."]
#[doc = ""]
#[doc = " \\note            This is required for certain uses of TLS, e.g. EAP-TLS"]
#[doc = "                  (RFC 5216) and Thread. The key pointers are ephemeral and"]
#[doc = "                  therefore must not be stored. The master secret and keys"]
#[doc = "                  should not be used directly except as an input to a key"]
#[doc = "                  derivation function."]
#[doc = ""]
#[doc = " \\param p_expkey  Context for the callback."]
#[doc = " \\param ms        Pointer to master secret (fixed length: 48 bytes)."]
#[doc = " \\param kb            Pointer to key block, see RFC 5246 section 6.3."]
#[doc = "                      (variable length: 2 * maclen + 2 * keylen + 2 * ivlen)."]
#[doc = " \\param maclen        MAC length."]
#[doc = " \\param keylen        Key length."]
#[doc = " \\param ivlen         IV length."]
#[doc = " \\param client_random The client random bytes."]
#[doc = " \\param server_random The server random bytes."]
#[doc = " \\param tls_prf_type The tls_prf enum type."]
#[doc = ""]
#[doc = " \\return          0 if successful, or"]
#[doc = "                  a specific MBEDTLS_ERR_XXX code."]
pub type ssl_export_keys_ext_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut crate::types::c_void,
        ms: *const crate::types::c_uchar,
        kb: *const crate::types::c_uchar,
        maclen: usize,
        keylen: usize,
        ivlen: usize,
        client_random: *const crate::types::c_uchar,
        server_random: *const crate::types::c_uchar,
        tls_prf_type: tls_prf_types,
    ) -> crate::types::c_int,
>;
#[doc = " \\brief           Callback type: parse and load session ticket"]
#[doc = ""]
#[doc = " \\note            This describes what a callback implementation should do."]
#[doc = "                  This callback should parse a session ticket as generated"]
#[doc = "                  by the corresponding mbedtls_ssl_ticket_write_t function,"]
#[doc = "                  and, if the ticket is authentic and valid, load the"]
#[doc = "                  session."]
#[doc = ""]
#[doc = " \\note            The implementation is allowed to modify the first len"]
#[doc = "                  bytes of the input buffer, eg to use it as a temporary"]
#[doc = "                  area for the decrypted ticket contents."]
#[doc = ""]
#[doc = " \\param p_ticket  Context for the callback"]
#[doc = " \\param session   SSL session to be loaded"]
#[doc = " \\param buf       Start of the buffer containing the ticket"]
#[doc = " \\param len       Length of the ticket."]
#[doc = ""]
#[doc = " \\return          0 if successful, or"]
#[doc = "                  MBEDTLS_ERR_SSL_INVALID_MAC if not authentic, or"]
#[doc = "                  MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED if expired, or"]
#[doc = "                  any other non-zero code for other failures."]
pub type ssl_ticket_parse_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut crate::types::c_void,
        session: *mut ssl_session,
        buf: *mut crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int,
>;
extern "C" {
    #[doc = " \\brief           Configure SSL session ticket callbacks (server only)."]
    #[doc = "                  (Default: none.)"]
    #[doc = ""]
    #[doc = " \\note            On server, session tickets are enabled by providing"]
    #[doc = "                  non-NULL callbacks."]
    #[doc = ""]
    #[doc = " \\note            On client, use \\c mbedtls_ssl_conf_session_tickets()."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration context"]
    #[doc = " \\param f_ticket_write    Callback for writing a ticket"]
    #[doc = " \\param f_ticket_parse    Callback for parsing a ticket"]
    #[doc = " \\param p_ticket          Context shared by the two callbacks"]
    #[link_name = "\u{1}mbedtls_ssl_conf_session_tickets_cb"]
    pub fn ssl_conf_session_tickets_cb(
        conf: *mut ssl_config,
        f_ticket_write: ssl_ticket_write_t,
        f_ticket_parse: ssl_ticket_parse_t,
        p_ticket: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief           Configure key export callback."]
    #[doc = "                  (Default: none.)"]
    #[doc = ""]
    #[doc = " \\note            See \\c mbedtls_ssl_export_keys_t."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration context"]
    #[doc = " \\param f_export_keys     Callback for exporting keys"]
    #[doc = " \\param p_export_keys     Context for the callback"]
    #[link_name = "\u{1}mbedtls_ssl_conf_export_keys_cb"]
    pub fn ssl_conf_export_keys_cb(
        conf: *mut ssl_config,
        f_export_keys: ssl_export_keys_t,
        p_export_keys: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief           Configure extended key export callback."]
    #[doc = "                  (Default: none.)"]
    #[doc = ""]
    #[doc = " \\note            See \\c mbedtls_ssl_export_keys_ext_t."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration context"]
    #[doc = " \\param f_export_keys_ext Callback for exporting keys"]
    #[doc = " \\param p_export_keys     Context for the callback"]
    #[link_name = "\u{1}mbedtls_ssl_conf_export_keys_ext_cb"]
    pub fn ssl_conf_export_keys_ext_cb(
        conf: *mut ssl_config,
        f_export_keys_ext: ssl_export_keys_ext_t,
        p_export_keys: *mut crate::types::c_void,
    );
}
#[doc = " \\brief          Callback type: generate a cookie"]
#[doc = ""]
#[doc = " \\param ctx      Context for the callback"]
#[doc = " \\param p        Buffer to write to,"]
#[doc = "                 must be updated to point right after the cookie"]
#[doc = " \\param end      Pointer to one past the end of the output buffer"]
#[doc = " \\param info     Client ID info that was passed to"]
#[doc = "                 \\c mbedtls_ssl_set_client_transport_id()"]
#[doc = " \\param ilen     Length of info in bytes"]
#[doc = ""]
#[doc = " \\return         The callback must return 0 on success,"]
#[doc = "                 or a negative error code."]
pub type ssl_cookie_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::types::c_void,
        p: *mut *mut crate::types::c_uchar,
        end: *mut crate::types::c_uchar,
        info: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int,
>;
#[doc = " \\brief          Callback type: verify a cookie"]
#[doc = ""]
#[doc = " \\param ctx      Context for the callback"]
#[doc = " \\param cookie   Cookie to verify"]
#[doc = " \\param clen     Length of cookie"]
#[doc = " \\param info     Client ID info that was passed to"]
#[doc = "                 \\c mbedtls_ssl_set_client_transport_id()"]
#[doc = " \\param ilen     Length of info in bytes"]
#[doc = ""]
#[doc = " \\return         The callback must return 0 if cookie is valid,"]
#[doc = "                 or a negative error code."]
pub type ssl_cookie_check_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::types::c_void,
        cookie: *const crate::types::c_uchar,
        clen: usize,
        info: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int,
>;
extern "C" {
    #[doc = " \\brief           Register callbacks for DTLS cookies"]
    #[doc = "                  (Server only. DTLS only.)"]
    #[doc = ""]
    #[doc = "                  Default: dummy callbacks that fail, in order to force you to"]
    #[doc = "                  register working callbacks (and initialize their context)."]
    #[doc = ""]
    #[doc = "                  To disable HelloVerifyRequest, register NULL callbacks."]
    #[doc = ""]
    #[doc = " \\warning         Disabling hello verification allows your server to be used"]
    #[doc = "                  for amplification in DoS attacks against other hosts."]
    #[doc = "                  Only disable if you known this can't happen in your"]
    #[doc = "                  particular environment."]
    #[doc = ""]
    #[doc = " \\note            See comments on \\c mbedtls_ssl_handshake() about handling"]
    #[doc = "                  the MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED that is expected"]
    #[doc = "                  on the first handshake attempt when this is enabled."]
    #[doc = ""]
    #[doc = " \\note            This is also necessary to handle client reconnection from"]
    #[doc = "                  the same port as described in RFC 6347 section 4.2.8 (only"]
    #[doc = "                  the variant with cookies is supported currently). See"]
    #[doc = "                  comments on \\c mbedtls_ssl_read() for details."]
    #[doc = ""]
    #[doc = " \\param conf              SSL configuration"]
    #[doc = " \\param f_cookie_write    Cookie write callback"]
    #[doc = " \\param f_cookie_check    Cookie check callback"]
    #[doc = " \\param p_cookie          Context for both callbacks"]
    #[link_name = "\u{1}mbedtls_ssl_conf_dtls_cookies"]
    pub fn ssl_conf_dtls_cookies(
        conf: *mut ssl_config,
        f_cookie_write: ssl_cookie_write_t,
        f_cookie_check: ssl_cookie_check_t,
        p_cookie: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set client's transport-level identification info."]
    #[doc = "                 (Server only. DTLS only.)"]
    #[doc = ""]
    #[doc = "                 This is usually the IP address (and port), but could be"]
    #[doc = "                 anything identify the client depending on the underlying"]
    #[doc = "                 network stack. Used for HelloVerifyRequest with DTLS."]
    #[doc = "                 This is *not* used to route the actual packets."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param info     Transport-level info identifying the client (eg IP + port)"]
    #[doc = " \\param ilen     Length of info in bytes"]
    #[doc = ""]
    #[doc = " \\note           An internal copy is made, so the info buffer can be reused."]
    #[doc = ""]
    #[doc = " \\return         0 on success,"]
    #[doc = "                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used on client,"]
    #[doc = "                 MBEDTLS_ERR_SSL_ALLOC_FAILED if out of memory."]
    #[link_name = "\u{1}mbedtls_ssl_set_client_transport_id"]
    pub fn ssl_set_client_transport_id(
        ssl: *mut ssl_context,
        info: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Enable or disable anti-replay protection for DTLS."]
    #[doc = "                 (DTLS only, no effect on TLS.)"]
    #[doc = "                 Default: enabled."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param mode     MBEDTLS_SSL_ANTI_REPLAY_ENABLED or MBEDTLS_SSL_ANTI_REPLAY_DISABLED."]
    #[doc = ""]
    #[doc = " \\warning        Disabling this is a security risk unless the application"]
    #[doc = "                 protocol handles duplicated packets in a safe way. You"]
    #[doc = "                 should not disable this without careful consideration."]
    #[doc = "                 However, if your application already detects duplicated"]
    #[doc = "                 packets and needs information about them to adjust its"]
    #[doc = "                 transmission strategy, then you'll want to disable this."]
    #[link_name = "\u{1}mbedtls_ssl_conf_dtls_anti_replay"]
    pub fn ssl_conf_dtls_anti_replay(conf: *mut ssl_config, mode: crate::types::c_char);
}
extern "C" {
    #[doc = " \\brief          Set a limit on the number of records with a bad MAC"]
    #[doc = "                 before terminating the connection."]
    #[doc = "                 (DTLS only, no effect on TLS.)"]
    #[doc = "                 Default: 0 (disabled)."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param limit    Limit, or 0 to disable."]
    #[doc = ""]
    #[doc = " \\note           If the limit is N, then the connection is terminated when"]
    #[doc = "                 the Nth non-authentic record is seen."]
    #[doc = ""]
    #[doc = " \\note           Records with an invalid header are not counted, only the"]
    #[doc = "                 ones going through the authentication-decryption phase."]
    #[doc = ""]
    #[doc = " \\note           This is a security trade-off related to the fact that it's"]
    #[doc = "                 often relatively easy for an active attacker ot inject UDP"]
    #[doc = "                 datagrams. On one hand, setting a low limit here makes it"]
    #[doc = "                 easier for such an attacker to forcibly terminated a"]
    #[doc = "                 connection. On the other hand, a high limit or no limit"]
    #[doc = "                 might make us waste resources checking authentication on"]
    #[doc = "                 many bogus packets."]
    #[link_name = "\u{1}mbedtls_ssl_conf_dtls_badmac_limit"]
    pub fn ssl_conf_dtls_badmac_limit(conf: *mut ssl_config, limit: crate::types::c_uint);
}
extern "C" {
    #[doc = " \\brief          Allow or disallow packing of multiple handshake records"]
    #[doc = "                 within a single datagram."]
    #[doc = ""]
    #[doc = " \\param ssl           The SSL context to configure."]
    #[doc = " \\param allow_packing This determines whether datagram packing may"]
    #[doc = "                      be used or not. A value of \\c 0 means that every"]
    #[doc = "                      record will be sent in a separate datagram; a"]
    #[doc = "                      value of \\c 1 means that, if space permits,"]
    #[doc = "                      multiple handshake messages (including CCS) belonging to"]
    #[doc = "                      a single flight may be packed within a single datagram."]
    #[doc = ""]
    #[doc = " \\note           This is enabled by default and should only be disabled"]
    #[doc = "                 for test purposes, or if datagram packing causes"]
    #[doc = "                 interoperability issues with peers that don't support it."]
    #[doc = ""]
    #[doc = " \\note           Allowing datagram packing reduces the network load since"]
    #[doc = "                 there's less overhead if multiple messages share the same"]
    #[doc = "                 datagram. Also, it increases the handshake efficiency"]
    #[doc = "                 since messages belonging to a single datagram will not"]
    #[doc = "                 be reordered in transit, and so future message buffering"]
    #[doc = "                 or flight retransmission (if no buffering is used) as"]
    #[doc = "                 means to deal with reordering are needed less frequently."]
    #[doc = ""]
    #[doc = " \\note           Application records are not affected by this option and"]
    #[doc = "                 are currently always sent in separate datagrams."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_ssl_set_datagram_packing"]
    pub fn ssl_set_datagram_packing(ssl: *mut ssl_context, allow_packing: crate::types::c_uint);
}
extern "C" {
    #[doc = " \\brief          Set retransmit timeout values for the DTLS handshake."]
    #[doc = "                 (DTLS only, no effect on TLS.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param min      Initial timeout value in milliseconds."]
    #[doc = "                 Default: 1000 (1 second)."]
    #[doc = " \\param max      Maximum timeout value in milliseconds."]
    #[doc = "                 Default: 60000 (60 seconds)."]
    #[doc = ""]
    #[doc = " \\note           Default values are from RFC 6347 section 4.2.4.1."]
    #[doc = ""]
    #[doc = " \\note           The 'min' value should typically be slightly above the"]
    #[doc = "                 expected round-trip time to your peer, plus whatever time"]
    #[doc = "                 it takes for the peer to process the message. For example,"]
    #[doc = "                 if your RTT is about 600ms and you peer needs up to 1s to"]
    #[doc = "                 do the cryptographic operations in the handshake, then you"]
    #[doc = "                 should set 'min' slightly above 1600. Lower values of 'min'"]
    #[doc = "                 might cause spurious resends which waste network resources,"]
    #[doc = "                 while larger value of 'min' will increase overall latency"]
    #[doc = "                 on unreliable network links."]
    #[doc = ""]
    #[doc = " \\note           The more unreliable your network connection is, the larger"]
    #[doc = "                 your max / min ratio needs to be in order to achieve"]
    #[doc = "                 reliable handshakes."]
    #[doc = ""]
    #[doc = " \\note           Messages are retransmitted up to log2(ceil(max/min)) times."]
    #[doc = "                 For example, if min = 1s and max = 5s, the retransmit plan"]
    #[doc = "                 goes: send ... 1s -> resend ... 2s -> resend ... 4s ->"]
    #[doc = "                 resend ... 5s -> give up and return a timeout error."]
    #[link_name = "\u{1}mbedtls_ssl_conf_handshake_timeout"]
    pub fn ssl_conf_handshake_timeout(conf: *mut ssl_config, min: u32, max: u32);
}
extern "C" {
    #[doc = " \\brief          Set the session cache callbacks (server-side only)"]
    #[doc = "                 If not set, no session resuming is done (except if session"]
    #[doc = "                 tickets are enabled too)."]
    #[doc = ""]
    #[doc = "                 The session cache has the responsibility to check for stale"]
    #[doc = "                 entries based on timeout. See RFC 5246 for recommendations."]
    #[doc = ""]
    #[doc = "                 Warning: session.peer_cert is cleared by the SSL/TLS layer on"]
    #[doc = "                 connection shutdown, so do not cache the pointer! Either set"]
    #[doc = "                 it to NULL or make a full copy of the certificate."]
    #[doc = ""]
    #[doc = "                 The get callback is called once during the initial handshake"]
    #[doc = "                 to enable session resuming. The get function has the"]
    #[doc = "                 following parameters: (void *parameter, mbedtls_ssl_session *session)"]
    #[doc = "                 If a valid entry is found, it should fill the master of"]
    #[doc = "                 the session object with the cached values and return 0,"]
    #[doc = "                 return 1 otherwise. Optionally peer_cert can be set as well"]
    #[doc = "                 if it is properly present in cache entry."]
    #[doc = ""]
    #[doc = "                 The set callback is called once during the initial handshake"]
    #[doc = "                 to enable session resuming after the entire handshake has"]
    #[doc = "                 been finished. The set function has the following parameters:"]
    #[doc = "                 (void *parameter, const mbedtls_ssl_session *session). The function"]
    #[doc = "                 should create a cache entry for future retrieval based on"]
    #[doc = "                 the data in the session structure and should keep in mind"]
    #[doc = "                 that the mbedtls_ssl_session object presented (and all its referenced"]
    #[doc = "                 data) is cleared by the SSL/TLS layer when the connection is"]
    #[doc = "                 terminated. It is recommended to add metadata to determine if"]
    #[doc = "                 an entry is still valid in the future. Return 0 if"]
    #[doc = "                 successfully cached, return 1 otherwise."]
    #[doc = ""]
    #[doc = " \\param conf           SSL configuration"]
    #[doc = " \\param p_cache        parmater (context) for both callbacks"]
    #[doc = " \\param f_get_cache    session get callback"]
    #[doc = " \\param f_set_cache    session set callback"]
    #[link_name = "\u{1}mbedtls_ssl_conf_session_cache"]
    pub fn ssl_conf_session_cache(
        conf: *mut ssl_config,
        p_cache: *mut crate::types::c_void,
        f_get_cache: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut ssl_session,
            ) -> crate::types::c_int,
        >,
        f_set_cache: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *const ssl_session,
            ) -> crate::types::c_int,
        >,
    );
}
extern "C" {
    #[doc = " \\brief          Request resumption of session (client-side only)"]
    #[doc = "                 Session data is copied from presented session structure."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param session  session context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or"]
    #[doc = "                 arguments are otherwise invalid"]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_get_session()"]
    #[link_name = "\u{1}mbedtls_ssl_set_session"]
    pub fn ssl_set_session(
        ssl: *mut ssl_context,
        session: *const ssl_session,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Load serialized session data into a session structure."]
    #[doc = "                 On client, this can be used for loading saved sessions"]
    #[doc = "                 before resuming them with mbedstls_ssl_set_session()."]
    #[doc = "                 On server, this can be used for alternative implementations"]
    #[doc = "                 of session cache or session tickets."]
    #[doc = ""]
    #[doc = " \\warning        If a peer certificate chain is associated with the session,"]
    #[doc = "                 the serialized state will only contain the peer's"]
    #[doc = "                 end-entity certificate and the result of the chain"]
    #[doc = "                 verification (unless verification was disabled), but not"]
    #[doc = "                 the rest of the chain."]
    #[doc = ""]
    #[doc = " \\see            mbedtls_ssl_session_save()"]
    #[doc = " \\see            mbedtls_ssl_set_session()"]
    #[doc = ""]
    #[doc = " \\param session  The session structure to be populated. It must have been"]
    #[doc = "                 initialised with mbedtls_ssl_session_init() but not"]
    #[doc = "                 populated yet."]
    #[doc = " \\param buf      The buffer holding the serialized session data. It must be a"]
    #[doc = "                 readable buffer of at least \\p len bytes."]
    #[doc = " \\param len      The size of the serialized data in bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data"]
    #[doc = "                 was generated in a different version or configuration of"]
    #[doc = "                 Mbed TLS."]
    #[doc = " \\return         Another negative value for other kinds of errors (for"]
    #[doc = "                 example, unsupported features in the embedded certificate)."]
    #[link_name = "\u{1}mbedtls_ssl_session_load"]
    pub fn ssl_session_load(
        session: *mut ssl_session,
        buf: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Save session structure as serialized data in a buffer."]
    #[doc = "                 On client, this can be used for saving session data,"]
    #[doc = "                 potentially in non-volatile storage, for resuming later."]
    #[doc = "                 On server, this can be used for alternative implementations"]
    #[doc = "                 of session cache or session tickets."]
    #[doc = ""]
    #[doc = " \\see            mbedtls_ssl_session_load()"]
    #[doc = " \\see            mbedtls_ssl_get_session_pointer()"]
    #[doc = ""]
    #[doc = " \\param session  The session structure to be saved."]
    #[doc = " \\param buf      The buffer to write the serialized data to. It must be a"]
    #[doc = "                 writeable buffer of at least \\p len bytes, or may be \\c"]
    #[doc = "                 NULL if \\p len is \\c 0."]
    #[doc = " \\param buf_len  The number of bytes available for writing in \\p buf."]
    #[doc = " \\param olen     The size in bytes of the data that has been or would have"]
    #[doc = "                 been written. It must point to a valid \\c size_t."]
    #[doc = ""]
    #[doc = " \\note           \\p olen is updated to the correct value regardless of"]
    #[doc = "                 whether \\p buf_len was large enough. This makes it possible"]
    #[doc = "                 to determine the necessary size by calling this function"]
    #[doc = "                 with \\p buf set to \\c NULL and \\p buf_len to \\c 0."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \\p buf is too small."]
    #[link_name = "\u{1}mbedtls_ssl_session_save"]
    pub fn ssl_session_save(
        session: *const ssl_session,
        buf: *mut crate::types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Get a pointer to the current session structure, for example"]
    #[doc = "                 to serialize it."]
    #[doc = ""]
    #[doc = " \\warning        Ownership of the session remains with the SSL context, and"]
    #[doc = "                 the returned pointer is only guaranteed to be valid until"]
    #[doc = "                 the next API call operating on the same \\p ssl context."]
    #[doc = ""]
    #[doc = " \\see            mbedtls_ssl_session_save()"]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context."]
    #[doc = ""]
    #[doc = " \\return         A pointer to the current session if successful."]
    #[doc = " \\return         \\c NULL if no session is active."]
    #[link_name = "\u{1}mbedtls_ssl_get_session_pointer"]
    pub fn ssl_get_session_pointer(ssl: *const ssl_context) -> *const ssl_session;
}
extern "C" {
    #[doc = " \\brief               Set the list of allowed ciphersuites and the preference"]
    #[doc = "                      order. First in the list has the highest preference."]
    #[doc = "                      (Overrides all version-specific lists)"]
    #[doc = ""]
    #[doc = "                      The ciphersuites array is not copied, and must remain"]
    #[doc = "                      valid for the lifetime of the ssl_config."]
    #[doc = ""]
    #[doc = "                      Note: The server uses its own preferences"]
    #[doc = "                      over the preference of the client unless"]
    #[doc = "                      MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE is defined!"]
    #[doc = ""]
    #[doc = " \\param conf          SSL configuration"]
    #[doc = " \\param ciphersuites  0-terminated list of allowed ciphersuites"]
    #[link_name = "\u{1}mbedtls_ssl_conf_ciphersuites"]
    pub fn ssl_conf_ciphersuites(conf: *mut ssl_config, ciphersuites: *const crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief               Set the list of allowed ciphersuites and the"]
    #[doc = "                      preference order for a specific version of the protocol."]
    #[doc = "                      (Only useful on the server side)"]
    #[doc = ""]
    #[doc = "                      The ciphersuites array is not copied, and must remain"]
    #[doc = "                      valid for the lifetime of the ssl_config."]
    #[doc = ""]
    #[doc = " \\param conf          SSL configuration"]
    #[doc = " \\param ciphersuites  0-terminated list of allowed ciphersuites"]
    #[doc = " \\param major         Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3"]
    #[doc = "                      supported)"]
    #[doc = " \\param minor         Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,"]
    #[doc = "                      MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,"]
    #[doc = "                      MBEDTLS_SSL_MINOR_VERSION_3 supported)"]
    #[doc = ""]
    #[doc = " \\note                With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0"]
    #[doc = "                      and MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2"]
    #[link_name = "\u{1}mbedtls_ssl_conf_ciphersuites_for_version"]
    pub fn ssl_conf_ciphersuites_for_version(
        conf: *mut ssl_config,
        ciphersuites: *const crate::types::c_int,
        major: crate::types::c_int,
        minor: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the X.509 security profile used for verification"]
    #[doc = ""]
    #[doc = " \\note           The restrictions are enforced for all certificates in the"]
    #[doc = "                 chain. However, signatures in the handshake are not covered"]
    #[doc = "                 by this setting but by \\b mbedtls_ssl_conf_sig_hashes()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param profile  Profile to use"]
    #[link_name = "\u{1}mbedtls_ssl_conf_cert_profile"]
    pub fn ssl_conf_cert_profile(conf: *mut ssl_config, profile: *const x509_crt_profile);
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate"]
    #[doc = ""]
    #[doc = " \\note           See \\c mbedtls_x509_crt_verify() for notes regarding the"]
    #[doc = "                 parameters ca_chain (maps to trust_ca for that function)"]
    #[doc = "                 and ca_crl."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)"]
    #[doc = " \\param ca_crl   trusted CA CRLs"]
    #[link_name = "\u{1}mbedtls_ssl_conf_ca_chain"]
    pub fn ssl_conf_ca_chain(conf: *mut ssl_config, ca_chain: *mut x509_crt, ca_crl: *mut x509_crl);
}
extern "C" {
    #[doc = " \\brief          Set the trusted certificate callback."]
    #[doc = ""]
    #[doc = "                 This API allows to register the set of trusted certificates"]
    #[doc = "                 through a callback, instead of a linked list as configured"]
    #[doc = "                 by mbedtls_ssl_conf_ca_chain()."]
    #[doc = ""]
    #[doc = "                 This is useful for example in contexts where a large number"]
    #[doc = "                 of CAs are used, and the inefficiency of maintaining them"]
    #[doc = "                 in a linked list cannot be tolerated. It is also useful when"]
    #[doc = "                 the set of trusted CAs needs to be modified frequently."]
    #[doc = ""]
    #[doc = "                 See the documentation of `mbedtls_x509_crt_ca_cb_t` for"]
    #[doc = "                 more information."]
    #[doc = ""]
    #[doc = " \\param conf     The SSL configuration to register the callback with."]
    #[doc = " \\param f_ca_cb  The trusted certificate callback to use when verifying"]
    #[doc = "                 certificate chains."]
    #[doc = " \\param p_ca_cb  The context to be passed to \\p f_ca_cb (for example,"]
    #[doc = "                 a reference to a trusted CA database)."]
    #[doc = ""]
    #[doc = " \\note           This API is incompatible with mbedtls_ssl_conf_ca_chain():"]
    #[doc = "                 Any call to this function overwrites the values set through"]
    #[doc = "                 earlier calls to mbedtls_ssl_conf_ca_chain() or"]
    #[doc = "                 mbedtls_ssl_conf_ca_cb()."]
    #[doc = ""]
    #[doc = " \\note           This API is incompatible with CA indication in"]
    #[doc = "                 CertificateRequest messages: A server-side SSL context which"]
    #[doc = "                 is bound to an SSL configuration that uses a CA callback"]
    #[doc = "                 configured via mbedtls_ssl_conf_ca_cb(), and which requires"]
    #[doc = "                 client authentication, will send an empty CA list in the"]
    #[doc = "                 corresponding CertificateRequest message."]
    #[doc = ""]
    #[doc = " \\note           This API is incompatible with mbedtls_ssl_set_hs_ca_chain():"]
    #[doc = "                 If an SSL context is bound to an SSL configuration which uses"]
    #[doc = "                 CA callbacks configured via mbedtls_ssl_conf_ca_cb(), then"]
    #[doc = "                 calls to mbedtls_ssl_set_hs_ca_chain() have no effect."]
    #[doc = ""]
    #[doc = " \\note           The use of this API disables the use of restartable ECC"]
    #[doc = "                 during X.509 CRT signature verification (but doesn't affect"]
    #[doc = "                 other uses)."]
    #[doc = ""]
    #[doc = " \\warning        This API is incompatible with the use of CRLs. Any call to"]
    #[doc = "                 mbedtls_ssl_conf_ca_cb() unsets CRLs configured through"]
    #[doc = "                 earlier calls to mbedtls_ssl_conf_ca_chain()."]
    #[doc = ""]
    #[doc = " \\warning        In multi-threaded environments, the callback \\p f_ca_cb"]
    #[doc = "                 must be thread-safe, and it is the user's responsibility"]
    #[doc = "                 to guarantee this (for example through a mutex"]
    #[doc = "                 contained in the callback context pointed to by \\p p_ca_cb)."]
    #[link_name = "\u{1}mbedtls_ssl_conf_ca_cb"]
    pub fn ssl_conf_ca_cb(
        conf: *mut ssl_config,
        f_ca_cb: x509_crt_ca_cb_t,
        p_ca_cb: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set own certificate chain and private key"]
    #[doc = ""]
    #[doc = " \\note           own_cert should contain in order from the bottom up your"]
    #[doc = "                 certificate chain. The top certificate (self-signed)"]
    #[doc = "                 can be omitted."]
    #[doc = ""]
    #[doc = " \\note           On server, this function can be called multiple times to"]
    #[doc = "                 provision more than one cert/key pair (eg one ECDSA, one"]
    #[doc = "                 RSA with SHA-256, one RSA with SHA-1). An adequate"]
    #[doc = "                 certificate will be selected according to the client's"]
    #[doc = "                 advertised capabilities. In case multiple certificates are"]
    #[doc = "                 adequate, preference is given to the one set by the first"]
    #[doc = "                 call to this function, then second, etc."]
    #[doc = ""]
    #[doc = " \\note           On client, only the first call has any effect. That is,"]
    #[doc = "                 only one client certificate can be provisioned. The"]
    #[doc = "                 server's preferences in its CertficateRequest message will"]
    #[doc = "                 be ignored and our only cert will be sent regardless of"]
    #[doc = "                 whether it matches those preferences - the server can then"]
    #[doc = "                 decide what it wants to do with it."]
    #[doc = ""]
    #[doc = " \\note           The provided \\p pk_key needs to match the public key in the"]
    #[doc = "                 first certificate in \\p own_cert, or all handshakes using"]
    #[doc = "                 that certificate will fail. It is your responsibility"]
    #[doc = "                 to ensure that; this function will not perform any check."]
    #[doc = "                 You may use mbedtls_pk_check_pair() in order to perform"]
    #[doc = "                 this check yourself, but be aware that this function can"]
    #[doc = "                 be computationally expensive on some key types."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param own_cert own public certificate chain"]
    #[doc = " \\param pk_key   own private key"]
    #[doc = ""]
    #[doc = " \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_ssl_conf_own_cert"]
    pub fn ssl_conf_own_cert(
        conf: *mut ssl_config,
        own_cert: *mut x509_crt,
        pk_key: *mut pk_context,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Configure a pre-shared key (PSK) and identity"]
    #[doc = "                 to be used in PSK-based ciphersuites."]
    #[doc = ""]
    #[doc = " \\note           This is mainly useful for clients. Servers will usually"]
    #[doc = "                 want to use \\c mbedtls_ssl_conf_psk_cb() instead."]
    #[doc = ""]
    #[doc = " \\note           A PSK set by \\c mbedtls_ssl_set_hs_psk() in the PSK callback"]
    #[doc = "                 takes precedence over a PSK configured by this function."]
    #[doc = ""]
    #[doc = " \\warning        Currently, clients can only register a single pre-shared key."]
    #[doc = "                 Calling this function or mbedtls_ssl_conf_psk_opaque() more"]
    #[doc = "                 than once will overwrite values configured in previous calls."]
    #[doc = "                 Support for setting multiple PSKs on clients and selecting"]
    #[doc = "                 one based on the identity hint is not a planned feature,"]
    #[doc = "                 but feedback is welcomed."]
    #[doc = ""]
    #[doc = " \\param conf     The SSL configuration to register the PSK with."]
    #[doc = " \\param psk      The pointer to the pre-shared key to use."]
    #[doc = " \\param psk_len  The length of the pre-shared key in bytes."]
    #[doc = " \\param psk_identity      The pointer to the pre-shared key identity."]
    #[doc = " \\param psk_identity_len  The length of the pre-shared key identity"]
    #[doc = "                          in bytes."]
    #[doc = ""]
    #[doc = " \\note           The PSK and its identity are copied internally and"]
    #[doc = "                 hence need not be preserved by the caller for the lifetime"]
    #[doc = "                 of the SSL configuration."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_SSL_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ssl_conf_psk"]
    pub fn ssl_conf_psk(
        conf: *mut ssl_config,
        psk: *const crate::types::c_uchar,
        psk_len: usize,
        psk_identity: *const crate::types::c_uchar,
        psk_identity_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the pre-shared Key (PSK) for the current handshake."]
    #[doc = ""]
    #[doc = " \\note           This should only be called inside the PSK callback,"]
    #[doc = "                 i.e. the function passed to \\c mbedtls_ssl_conf_psk_cb()."]
    #[doc = ""]
    #[doc = " \\note           A PSK set by this function takes precedence over a PSK"]
    #[doc = "                 configured by \\c mbedtls_ssl_conf_psk()."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to configure a PSK for."]
    #[doc = " \\param psk      The pointer to the pre-shared key."]
    #[doc = " \\param psk_len  The length of the pre-shared key in bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         An \\c MBEDTLS_ERR_SSL_XXX error code on failure."]
    #[link_name = "\u{1}mbedtls_ssl_set_hs_psk"]
    pub fn ssl_set_hs_psk(
        ssl: *mut ssl_context,
        psk: *const crate::types::c_uchar,
        psk_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the PSK callback (server-side only)."]
    #[doc = ""]
    #[doc = "                 If set, the PSK callback is called for each"]
    #[doc = "                 handshake where a PSK-based ciphersuite was negotiated."]
    #[doc = "                 The caller provides the identity received and wants to"]
    #[doc = "                 receive the actual PSK data and length."]
    #[doc = ""]
    #[doc = "                 The callback has the following parameters:"]
    #[doc = "                 - \\c void*: The opaque pointer \\p p_psk."]
    #[doc = "                 - \\c mbedtls_ssl_context*: The SSL context to which"]
    #[doc = "                                            the operation applies."]
    #[doc = "                 - \\c const unsigned char*: The PSK identity"]
    #[doc = "                                            selected by the client."]
    #[doc = "                 - \\c size_t: The length of the PSK identity"]
    #[doc = "                              selected by the client."]
    #[doc = ""]
    #[doc = "                 If a valid PSK identity is found, the callback should use"]
    #[doc = "                 \\c mbedtls_ssl_set_hs_psk() or"]
    #[doc = "                 \\c mbedtls_ssl_set_hs_psk_opaque()"]
    #[doc = "                 on the SSL context to set the correct PSK and return \\c 0."]
    #[doc = "                 Any other return value will result in a denied PSK identity."]
    #[doc = ""]
    #[doc = " \\note           A dynamic PSK (i.e. set by the PSK callback) takes"]
    #[doc = "                 precedence over a static PSK (i.e. set by"]
    #[doc = "                 \\c mbedtls_ssl_conf_psk() or"]
    #[doc = "                 \\c mbedtls_ssl_conf_psk_opaque())."]
    #[doc = "                 This means that if you set a PSK callback using this"]
    #[doc = "                 function, you don't need to set a PSK using"]
    #[doc = "                 \\c mbedtls_ssl_conf_psk() or"]
    #[doc = "                 \\c mbedtls_ssl_conf_psk_opaque())."]
    #[doc = ""]
    #[doc = " \\param conf     The SSL configuration to register the callback with."]
    #[doc = " \\param f_psk    The callback for selecting and setting the PSK based"]
    #[doc = "                 in the PSK identity chosen by the client."]
    #[doc = " \\param p_psk    A pointer to an opaque structure to be passed to"]
    #[doc = "                 the callback, for example a PSK store."]
    #[link_name = "\u{1}mbedtls_ssl_conf_psk_cb"]
    pub fn ssl_conf_psk_cb(
        conf: *mut ssl_config,
        f_psk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut ssl_context,
                arg3: *const crate::types::c_uchar,
                arg4: usize,
            ) -> crate::types::c_int,
        >,
        p_psk: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values,"]
    #[doc = "                 read as hexadecimal strings (server-side only)"]
    #[doc = "                 (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG])"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param dhm_P    Diffie-Hellman-Merkle modulus"]
    #[doc = " \\param dhm_G    Diffie-Hellman-Merkle generator"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by \\c mbedtls_ssl_conf_dh_param_bin."]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_ssl_conf_dh_param"]
    pub fn ssl_conf_dh_param(
        conf: *mut ssl_config,
        dhm_P: *const crate::types::c_char,
        dhm_G: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values"]
    #[doc = "                 from big-endian binary presentations."]
    #[doc = "                 (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG]_BIN)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param dhm_P    Diffie-Hellman-Merkle modulus in big-endian binary form"]
    #[doc = " \\param P_len    Length of DHM modulus"]
    #[doc = " \\param dhm_G    Diffie-Hellman-Merkle generator in big-endian binary form"]
    #[doc = " \\param G_len    Length of DHM generator"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_ssl_conf_dh_param_bin"]
    pub fn ssl_conf_dh_param_bin(
        conf: *mut ssl_config,
        dhm_P: *const crate::types::c_uchar,
        P_len: usize,
        dhm_G: *const crate::types::c_uchar,
        G_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values,"]
    #[doc = "                 read from existing context (server-side only)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param dhm_ctx  Diffie-Hellman-Merkle context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_ssl_conf_dh_param_ctx"]
    pub fn ssl_conf_dh_param_ctx(
        conf: *mut ssl_config,
        dhm_ctx: *mut dhm_context,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the minimum length for Diffie-Hellman parameters."]
    #[doc = "                 (Client-side only.)"]
    #[doc = "                 (Default: 1024 bits.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param bitlen   Minimum bit length of the DHM prime"]
    #[link_name = "\u{1}mbedtls_ssl_conf_dhm_min_bitlen"]
    pub fn ssl_conf_dhm_min_bitlen(conf: *mut ssl_config, bitlen: crate::types::c_uint);
}
extern "C" {
    #[doc = " \\brief          Set the allowed curves in order of preference."]
    #[doc = "                 (Default: all defined curves.)"]
    #[doc = ""]
    #[doc = "                 On server: this only affects selection of the ECDHE curve;"]
    #[doc = "                 the curves used for ECDH and ECDSA are determined by the"]
    #[doc = "                 list of available certificates instead."]
    #[doc = ""]
    #[doc = "                 On client: this affects the list of curves offered for any"]
    #[doc = "                 use. The server can override our preference order."]
    #[doc = ""]
    #[doc = "                 Both sides: limits the set of curves accepted for use in"]
    #[doc = "                 ECDHE and in the peer's end-entity certificate."]
    #[doc = ""]
    #[doc = " \\note           This has no influence on which curves are allowed inside the"]
    #[doc = "                 certificate chains, see \\c mbedtls_ssl_conf_cert_profile()"]
    #[doc = "                 for that. For the end-entity certificate however, the key"]
    #[doc = "                 will be accepted only if it is allowed both by this list"]
    #[doc = "                 and by the cert profile."]
    #[doc = ""]
    #[doc = " \\note           This list should be ordered by decreasing preference"]
    #[doc = "                 (preferred curve first)."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param curves   Ordered list of allowed curves,"]
    #[doc = "                 terminated by MBEDTLS_ECP_DP_NONE."]
    #[link_name = "\u{1}mbedtls_ssl_conf_curves"]
    pub fn ssl_conf_curves(conf: *mut ssl_config, curves: *const ecp_group_id);
}
extern "C" {
    #[doc = " \\brief          Set the allowed hashes for signatures during the handshake."]
    #[doc = "                 (Default: all available hashes except MD5.)"]
    #[doc = ""]
    #[doc = " \\note           This only affects which hashes are offered and can be used"]
    #[doc = "                 for signatures during the handshake. Hashes for message"]
    #[doc = "                 authentication and the TLS PRF are controlled by the"]
    #[doc = "                 ciphersuite, see \\c mbedtls_ssl_conf_ciphersuites(). Hashes"]
    #[doc = "                 used for certificate signature are controlled by the"]
    #[doc = "                 verification profile, see \\c mbedtls_ssl_conf_cert_profile()."]
    #[doc = ""]
    #[doc = " \\note           This list should be ordered by decreasing preference"]
    #[doc = "                 (preferred hash first)."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param hashes   Ordered list of allowed signature hashes,"]
    #[doc = "                 terminated by \\c MBEDTLS_MD_NONE."]
    #[link_name = "\u{1}mbedtls_ssl_conf_sig_hashes"]
    pub fn ssl_conf_sig_hashes(conf: *mut ssl_config, hashes: *const crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          Set or reset the hostname to check against the received"]
    #[doc = "                 server certificate. It sets the ServerName TLS extension,"]
    #[doc = "                 too, if that extension is enabled. (client-side only)"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param hostname the server hostname, may be NULL to clear hostname"]
    #[doc = ""]
    #[doc = " \\note           Maximum hostname length MBEDTLS_SSL_MAX_HOST_NAME_LEN."]
    #[doc = ""]
    #[doc = " \\return         0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED on"]
    #[doc = "                 allocation failure, MBEDTLS_ERR_SSL_BAD_INPUT_DATA on"]
    #[doc = "                 too long input hostname."]
    #[doc = ""]
    #[doc = "                 Hostname set to the one provided on success (cleared"]
    #[doc = "                 when NULL). On allocation failure hostname is cleared."]
    #[doc = "                 On too long input failure, old hostname is unchanged."]
    #[link_name = "\u{1}mbedtls_ssl_set_hostname"]
    pub fn ssl_set_hostname(
        ssl: *mut ssl_context,
        hostname: *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set own certificate and key for the current handshake"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_own_cert() but for use within"]
    #[doc = "                 the SNI callback."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param own_cert own public certificate chain"]
    #[doc = " \\param pk_key   own private key"]
    #[doc = ""]
    #[doc = " \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    #[link_name = "\u{1}mbedtls_ssl_set_hs_own_cert"]
    pub fn ssl_set_hs_own_cert(
        ssl: *mut ssl_context,
        own_cert: *mut x509_crt,
        pk_key: *mut pk_context,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate for the"]
    #[doc = "                 current handshake"]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_ca_chain() but for use within"]
    #[doc = "                 the SNI callback."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)"]
    #[doc = " \\param ca_crl   trusted CA CRLs"]
    #[link_name = "\u{1}mbedtls_ssl_set_hs_ca_chain"]
    pub fn ssl_set_hs_ca_chain(
        ssl: *mut ssl_context,
        ca_chain: *mut x509_crt,
        ca_crl: *mut x509_crl,
    );
}
extern "C" {
    #[doc = " \\brief          Set authmode for the current handshake."]
    #[doc = ""]
    #[doc = " \\note           Same as \\c mbedtls_ssl_conf_authmode() but for use within"]
    #[doc = "                 the SNI callback."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param authmode MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or"]
    #[doc = "                 MBEDTLS_SSL_VERIFY_REQUIRED"]
    #[link_name = "\u{1}mbedtls_ssl_set_hs_authmode"]
    pub fn ssl_set_hs_authmode(ssl: *mut ssl_context, authmode: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          Set server side ServerName TLS extension callback"]
    #[doc = "                 (optional, server-side only)."]
    #[doc = ""]
    #[doc = "                 If set, the ServerName callback is called whenever the"]
    #[doc = "                 server receives a ServerName TLS extension from the client"]
    #[doc = "                 during a handshake. The ServerName callback has the"]
    #[doc = "                 following parameters: (void *parameter, mbedtls_ssl_context *ssl,"]
    #[doc = "                 const unsigned char *hostname, size_t len). If a suitable"]
    #[doc = "                 certificate is found, the callback must set the"]
    #[doc = "                 certificate(s) and key(s) to use with \\c"]
    #[doc = "                 mbedtls_ssl_set_hs_own_cert() (can be called repeatedly),"]
    #[doc = "                 and may optionally adjust the CA and associated CRL with \\c"]
    #[doc = "                 mbedtls_ssl_set_hs_ca_chain() as well as the client"]
    #[doc = "                 authentication mode with \\c mbedtls_ssl_set_hs_authmode(),"]
    #[doc = "                 then must return 0. If no matching name is found, the"]
    #[doc = "                 callback must either set a default cert, or"]
    #[doc = "                 return non-zero to abort the handshake at this point."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param f_sni    verification function"]
    #[doc = " \\param p_sni    verification parameter"]
    #[link_name = "\u{1}mbedtls_ssl_conf_sni"]
    pub fn ssl_conf_sni(
        conf: *mut ssl_config,
        f_sni: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut ssl_context,
                arg3: *const crate::types::c_uchar,
                arg4: usize,
            ) -> crate::types::c_int,
        >,
        p_sni: *mut crate::types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the supported Application Layer Protocols."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param protos   Pointer to a NULL-terminated list of supported protocols,"]
    #[doc = "                 in decreasing preference order. The pointer to the list is"]
    #[doc = "                 recorded by the library for later reference as required, so"]
    #[doc = "                 the lifetime of the table must be atleast as long as the"]
    #[doc = "                 lifetime of the SSL configuration structure."]
    #[doc = ""]
    #[doc = " \\return         0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA."]
    #[link_name = "\u{1}mbedtls_ssl_conf_alpn_protocols"]
    pub fn ssl_conf_alpn_protocols(
        conf: *mut ssl_config,
        protos: *mut *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Get the name of the negotiated Application Layer Protocol."]
    #[doc = "                 This function should be called after the handshake is"]
    #[doc = "                 completed."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Protcol name, or NULL if no protocol was negotiated."]
    #[link_name = "\u{1}mbedtls_ssl_get_alpn_protocol"]
    pub fn ssl_get_alpn_protocol(ssl: *const ssl_context) -> *const crate::types::c_char;
}
extern "C" {
    #[doc = " \\brief          Set the maximum supported version sent from the client side"]
    #[doc = "                 and/or accepted at the server side"]
    #[doc = "                 (Default: MBEDTLS_SSL_MAX_MAJOR_VERSION, MBEDTLS_SSL_MAX_MINOR_VERSION)"]
    #[doc = ""]
    #[doc = " \\note           This ignores ciphersuites from higher versions."]
    #[doc = ""]
    #[doc = " \\note           With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param major    Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported)"]
    #[doc = " \\param minor    Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_3 supported)"]
    #[link_name = "\u{1}mbedtls_ssl_conf_max_version"]
    pub fn ssl_conf_max_version(
        conf: *mut ssl_config,
        major: crate::types::c_int,
        minor: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the minimum accepted SSL/TLS protocol version"]
    #[doc = "                 (Default: TLS 1.0)"]
    #[doc = ""]
    #[doc = " \\note           Input outside of the SSL_MAX_XXXXX_VERSION and"]
    #[doc = "                 SSL_MIN_XXXXX_VERSION range is ignored."]
    #[doc = ""]
    #[doc = " \\note           MBEDTLS_SSL_MINOR_VERSION_0 (SSL v3) should be avoided."]
    #[doc = ""]
    #[doc = " \\note           With DTLS, use MBEDTLS_SSL_MINOR_VERSION_2 for DTLS 1.0 and"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_3 for DTLS 1.2"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param major    Major version number (only MBEDTLS_SSL_MAJOR_VERSION_3 supported)"]
    #[doc = " \\param minor    Minor version number (MBEDTLS_SSL_MINOR_VERSION_0,"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_1 and MBEDTLS_SSL_MINOR_VERSION_2,"]
    #[doc = "                 MBEDTLS_SSL_MINOR_VERSION_3 supported)"]
    #[link_name = "\u{1}mbedtls_ssl_conf_min_version"]
    pub fn ssl_conf_min_version(
        conf: *mut ssl_config,
        major: crate::types::c_int,
        minor: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the fallback flag (client-side only)."]
    #[doc = "                 (Default: MBEDTLS_SSL_IS_NOT_FALLBACK)."]
    #[doc = ""]
    #[doc = " \\note           Set to MBEDTLS_SSL_IS_FALLBACK when preparing a fallback"]
    #[doc = "                 connection, that is a connection with max_version set to a"]
    #[doc = "                 lower value than the value you're willing to use. Such"]
    #[doc = "                 fallback connections are not recommended but are sometimes"]
    #[doc = "                 necessary to interoperate with buggy (version-intolerant)"]
    #[doc = "                 servers."]
    #[doc = ""]
    #[doc = " \\warning        You should NOT set this to MBEDTLS_SSL_IS_FALLBACK for"]
    #[doc = "                 non-fallback connections! This would appear to work for a"]
    #[doc = "                 while, then cause failures when the server is upgraded to"]
    #[doc = "                 support a newer TLS version."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param fallback MBEDTLS_SSL_IS_NOT_FALLBACK or MBEDTLS_SSL_IS_FALLBACK"]
    #[link_name = "\u{1}mbedtls_ssl_conf_fallback"]
    pub fn ssl_conf_fallback(conf: *mut ssl_config, fallback: crate::types::c_char);
}
extern "C" {
    #[doc = " \\brief           Enable or disable Encrypt-then-MAC"]
    #[doc = "                  (Default: MBEDTLS_SSL_ETM_ENABLED)"]
    #[doc = ""]
    #[doc = " \\note            This should always be enabled, it is a security"]
    #[doc = "                  improvement, and should not cause any interoperability"]
    #[doc = "                  issue (used only if the peer supports it too)."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration"]
    #[doc = " \\param etm       MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED"]
    #[link_name = "\u{1}mbedtls_ssl_conf_encrypt_then_mac"]
    pub fn ssl_conf_encrypt_then_mac(conf: *mut ssl_config, etm: crate::types::c_char);
}
extern "C" {
    #[doc = " \\brief           Enable or disable Extended Master Secret negotiation."]
    #[doc = "                  (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)"]
    #[doc = ""]
    #[doc = " \\note            This should always be enabled, it is a security fix to the"]
    #[doc = "                  protocol, and should not cause any interoperability issue"]
    #[doc = "                  (used only if the peer supports it too)."]
    #[doc = ""]
    #[doc = " \\param conf      SSL configuration"]
    #[doc = " \\param ems       MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED"]
    #[link_name = "\u{1}mbedtls_ssl_conf_extended_master_secret"]
    pub fn ssl_conf_extended_master_secret(conf: *mut ssl_config, ems: crate::types::c_char);
}
extern "C" {
    #[doc = " \\brief          Disable or enable support for RC4"]
    #[doc = "                 (Default: MBEDTLS_SSL_ARC4_DISABLED)"]
    #[doc = ""]
    #[doc = " \\warning        Use of RC4 in DTLS/TLS has been prohibited by RFC 7465"]
    #[doc = "                 for security reasons. Use at your own risk."]
    #[doc = ""]
    #[doc = " \\note           This function is deprecated and will be removed in"]
    #[doc = "                 a future version of the library."]
    #[doc = "                 RC4 is disabled by default at compile time and needs to be"]
    #[doc = "                 actively enabled for use with legacy systems."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param arc4     MBEDTLS_SSL_ARC4_ENABLED or MBEDTLS_SSL_ARC4_DISABLED"]
    #[link_name = "\u{1}mbedtls_ssl_conf_arc4_support"]
    pub fn ssl_conf_arc4_support(conf: *mut ssl_config, arc4: crate::types::c_char);
}
extern "C" {
    #[doc = " \\brief          Whether to send a list of acceptable CAs in"]
    #[doc = "                 CertificateRequest messages."]
    #[doc = "                 (Default: do send)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param cert_req_ca_list   MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or"]
    #[doc = "                          MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED"]
    #[link_name = "\u{1}mbedtls_ssl_conf_cert_req_ca_list"]
    pub fn ssl_conf_cert_req_ca_list(conf: *mut ssl_config, cert_req_ca_list: crate::types::c_char);
}
extern "C" {
    #[doc = " \\brief          Set the maximum fragment length to emit and/or negotiate."]
    #[doc = "                 (Typical: the smaller of #MBEDTLS_SSL_IN_CONTENT_LEN and"]
    #[doc = "                 #MBEDTLS_SSL_OUT_CONTENT_LEN, usually `2^14` bytes)"]
    #[doc = "                 (Server: set maximum fragment length to emit,"]
    #[doc = "                 usually negotiated by the client during handshake)"]
    #[doc = "                 (Client: set maximum fragment length to emit *and*"]
    #[doc = "                 negotiate with the server during handshake)"]
    #[doc = "                 (Default: #MBEDTLS_SSL_MAX_FRAG_LEN_NONE)"]
    #[doc = ""]
    #[doc = " \\note           On the client side, the maximum fragment length extension"]
    #[doc = "                 *will not* be used, unless the maximum fragment length has"]
    #[doc = "                 been set via this function to a value different than"]
    #[doc = "                 #MBEDTLS_SSL_MAX_FRAG_LEN_NONE."]
    #[doc = ""]
    #[doc = " \\note           With TLS, this currently only affects ApplicationData (sent"]
    #[doc = "                 with \\c mbedtls_ssl_read()), not handshake messages."]
    #[doc = "                 With DTLS, this affects both ApplicationData and handshake."]
    #[doc = ""]
    #[doc = " \\note           This sets the maximum length for a record's payload,"]
    #[doc = "                 excluding record overhead that will be added to it, see"]
    #[doc = "                 \\c mbedtls_ssl_get_record_expansion()."]
    #[doc = ""]
    #[doc = " \\note           For DTLS, it is also possible to set a limit for the total"]
    #[doc = "                 size of daragrams passed to the transport layer, including"]
    #[doc = "                 record overhead, see \\c mbedtls_ssl_set_mtu()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param mfl_code Code for maximum fragment length (allowed values:"]
    #[doc = "                 MBEDTLS_SSL_MAX_FRAG_LEN_512,  MBEDTLS_SSL_MAX_FRAG_LEN_1024,"]
    #[doc = "                 MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)"]
    #[doc = ""]
    #[doc = " \\return         0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA"]
    #[link_name = "\u{1}mbedtls_ssl_conf_max_frag_len"]
    pub fn ssl_conf_max_frag_len(
        conf: *mut ssl_config,
        mfl_code: crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Activate negotiation of truncated HMAC"]
    #[doc = "                 (Default: MBEDTLS_SSL_TRUNC_HMAC_DISABLED)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param truncate Enable or disable (MBEDTLS_SSL_TRUNC_HMAC_ENABLED or"]
    #[doc = "                                    MBEDTLS_SSL_TRUNC_HMAC_DISABLED)"]
    #[link_name = "\u{1}mbedtls_ssl_conf_truncated_hmac"]
    pub fn ssl_conf_truncated_hmac(conf: *mut ssl_config, truncate: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          Enable / Disable 1/n-1 record splitting"]
    #[doc = "                 (Default: MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED)"]
    #[doc = ""]
    #[doc = " \\note           Only affects SSLv3 and TLS 1.0, not higher versions."]
    #[doc = "                 Does not affect non-CBC ciphersuites in any version."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param split    MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED or"]
    #[doc = "                 MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED"]
    #[link_name = "\u{1}mbedtls_ssl_conf_cbc_record_splitting"]
    pub fn ssl_conf_cbc_record_splitting(conf: *mut ssl_config, split: crate::types::c_char);
}
extern "C" {
    #[doc = " \\brief          Enable / Disable session tickets (client only)."]
    #[doc = "                 (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)"]
    #[doc = ""]
    #[doc = " \\note           On server, use \\c mbedtls_ssl_conf_session_tickets_cb()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param use_tickets   Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or"]
    #[doc = "                                         MBEDTLS_SSL_SESSION_TICKETS_DISABLED)"]
    #[link_name = "\u{1}mbedtls_ssl_conf_session_tickets"]
    pub fn ssl_conf_session_tickets(conf: *mut ssl_config, use_tickets: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          Enable / Disable renegotiation support for connection when"]
    #[doc = "                 initiated by peer"]
    #[doc = "                 (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)"]
    #[doc = ""]
    #[doc = " \\warning        It is recommended to always disable renegotation unless you"]
    #[doc = "                 know you need it and you know what you're doing. In the"]
    #[doc = "                 past, there have been several issues associated with"]
    #[doc = "                 renegotiation or a poor understanding of its properties."]
    #[doc = ""]
    #[doc = " \\note           Server-side, enabling renegotiation also makes the server"]
    #[doc = "                 susceptible to a resource DoS by a malicious client."]
    #[doc = ""]
    #[doc = " \\param conf    SSL configuration"]
    #[doc = " \\param renegotiation     Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or"]
    #[doc = "                                             MBEDTLS_SSL_RENEGOTIATION_DISABLED)"]
    #[link_name = "\u{1}mbedtls_ssl_conf_renegotiation"]
    pub fn ssl_conf_renegotiation(conf: *mut ssl_config, renegotiation: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          Prevent or allow legacy renegotiation."]
    #[doc = "                 (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)"]
    #[doc = ""]
    #[doc = "                 MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to"]
    #[doc = "                 be established even if the peer does not support"]
    #[doc = "                 secure renegotiation, but does not allow renegotiation"]
    #[doc = "                 to take place if not secure."]
    #[doc = "                 (Interoperable and secure option)"]
    #[doc = ""]
    #[doc = "                 MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations"]
    #[doc = "                 with non-upgraded peers. Allowing legacy renegotiation"]
    #[doc = "                 makes the connection vulnerable to specific man in the"]
    #[doc = "                 middle attacks. (See RFC 5746)"]
    #[doc = "                 (Most interoperable and least secure option)"]
    #[doc = ""]
    #[doc = "                 MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections"]
    #[doc = "                 if peer does not support secure renegotiation. Results"]
    #[doc = "                 in interoperability issues with non-upgraded peers"]
    #[doc = "                 that do not support renegotiation altogether."]
    #[doc = "                 (Most secure option, interoperability issues)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param allow_legacy  Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION,"]
    #[doc = "                                        SSL_ALLOW_LEGACY_RENEGOTIATION or"]
    #[doc = "                                        MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE)"]
    #[link_name = "\u{1}mbedtls_ssl_conf_legacy_renegotiation"]
    pub fn ssl_conf_legacy_renegotiation(conf: *mut ssl_config, allow_legacy: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          Enforce renegotiation requests."]
    #[doc = "                 (Default: enforced, max_records = 16)"]
    #[doc = ""]
    #[doc = "                 When we request a renegotiation, the peer can comply or"]
    #[doc = "                 ignore the request. This function allows us to decide"]
    #[doc = "                 whether to enforce our renegotiation requests by closing"]
    #[doc = "                 the connection if the peer doesn't comply."]
    #[doc = ""]
    #[doc = "                 However, records could already be in transit from the peer"]
    #[doc = "                 when the request is emitted. In order to increase"]
    #[doc = "                 reliability, we can accept a number of records before the"]
    #[doc = "                 expected handshake records."]
    #[doc = ""]
    #[doc = "                 The optimal value is highly dependent on the specific usage"]
    #[doc = "                 scenario."]
    #[doc = ""]
    #[doc = " \\note           With DTLS and server-initiated renegotiation, the"]
    #[doc = "                 HelloRequest is retransmited every time mbedtls_ssl_read() times"]
    #[doc = "                 out or receives Application Data, until:"]
    #[doc = "                 - max_records records have beens seen, if it is >= 0, or"]
    #[doc = "                 - the number of retransmits that would happen during an"]
    #[doc = "                 actual handshake has been reached."]
    #[doc = "                 Please remember the request might be lost a few times"]
    #[doc = "                 if you consider setting max_records to a really low value."]
    #[doc = ""]
    #[doc = " \\warning        On client, the grace period can only happen during"]
    #[doc = "                 mbedtls_ssl_read(), as opposed to mbedtls_ssl_write() and mbedtls_ssl_renegotiate()"]
    #[doc = "                 which always behave as if max_record was 0. The reason is,"]
    #[doc = "                 if we receive application data from the server, we need a"]
    #[doc = "                 place to write it, which only happens during mbedtls_ssl_read()."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param max_records Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to"]
    #[doc = "                 enforce renegotiation, or a non-negative value to enforce"]
    #[doc = "                 it but allow for a grace period of max_records records."]
    #[link_name = "\u{1}mbedtls_ssl_conf_renegotiation_enforced"]
    pub fn ssl_conf_renegotiation_enforced(conf: *mut ssl_config, max_records: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          Set record counter threshold for periodic renegotiation."]
    #[doc = "                 (Default: 2^48 - 1)"]
    #[doc = ""]
    #[doc = "                 Renegotiation is automatically triggered when a record"]
    #[doc = "                 counter (outgoing or incoming) crosses the defined"]
    #[doc = "                 threshold. The default value is meant to prevent the"]
    #[doc = "                 connection from being closed when the counter is about to"]
    #[doc = "                 reached its maximal value (it is not allowed to wrap)."]
    #[doc = ""]
    #[doc = "                 Lower values can be used to enforce policies such as \"keys"]
    #[doc = "                 must be refreshed every N packets with cipher X\"."]
    #[doc = ""]
    #[doc = "                 The renegotiation period can be disabled by setting"]
    #[doc = "                 conf->disable_renegotiation to"]
    #[doc = "                 MBEDTLS_SSL_RENEGOTIATION_DISABLED."]
    #[doc = ""]
    #[doc = " \\note           When the configured transport is"]
    #[doc = "                 MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation"]
    #[doc = "                 period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM,"]
    #[doc = "                 the maximum renegotiation period is 2^64 - 1."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration"]
    #[doc = " \\param period   The threshold value: a big-endian 64-bit number."]
    #[link_name = "\u{1}mbedtls_ssl_conf_renegotiation_period"]
    pub fn ssl_conf_renegotiation_period(
        conf: *mut ssl_config,
        period: *const crate::types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Check if there is data already read from the"]
    #[doc = "                 underlying transport but not yet processed."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         0 if nothing's pending, 1 otherwise."]
    #[doc = ""]
    #[doc = " \\note           This is different in purpose and behaviour from"]
    #[doc = "                 \\c mbedtls_ssl_get_bytes_avail in that it considers"]
    #[doc = "                 any kind of unprocessed data, not only unread"]
    #[doc = "                 application data. If \\c mbedtls_ssl_get_bytes"]
    #[doc = "                 returns a non-zero value, this function will"]
    #[doc = "                 also signal pending data, but the converse does"]
    #[doc = "                 not hold. For example, in DTLS there might be"]
    #[doc = "                 further records waiting to be processed from"]
    #[doc = "                 the current underlying transport's datagram."]
    #[doc = ""]
    #[doc = " \\note           If this function returns 1 (data pending), this"]
    #[doc = "                 does not imply that a subsequent call to"]
    #[doc = "                 \\c mbedtls_ssl_read will provide any data;"]
    #[doc = "                 e.g., the unprocessed data might turn out"]
    #[doc = "                 to be an alert or a handshake message."]
    #[doc = ""]
    #[doc = " \\note           This function is useful in the following situation:"]
    #[doc = "                 If the SSL/TLS module successfully returns from an"]
    #[doc = "                 operation - e.g. a handshake or an application record"]
    #[doc = "                 read - and you're awaiting incoming data next, you"]
    #[doc = "                 must not immediately idle on the underlying transport"]
    #[doc = "                 to have data ready, but you need to check the value"]
    #[doc = "                 of this function first. The reason is that the desired"]
    #[doc = "                 data might already be read but not yet processed."]
    #[doc = "                 If, in contrast, a previous call to the SSL/TLS module"]
    #[doc = "                 returned MBEDTLS_ERR_SSL_WANT_READ, it is not necessary"]
    #[doc = "                 to call this function, as the latter error code entails"]
    #[doc = "                 that all internal data has been processed."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_ssl_check_pending"]
    pub fn ssl_check_pending(ssl: *const ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of application data bytes"]
    #[doc = "                 remaining to be read from the current record."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         How many bytes are available in the application"]
    #[doc = "                 data record read buffer."]
    #[doc = ""]
    #[doc = " \\note           When working over a datagram transport, this is"]
    #[doc = "                 useful to detect the current datagram's boundary"]
    #[doc = "                 in case \\c mbedtls_ssl_read has written the maximal"]
    #[doc = "                 amount of data fitting into the input buffer."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_ssl_get_bytes_avail"]
    pub fn ssl_get_bytes_avail(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the result of the certificate verification"]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to use."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if the certificate verification was successful."]
    #[doc = " \\return         \\c -1u if the result is not available. This may happen"]
    #[doc = "                 e.g. if the handshake aborts early, or a verification"]
    #[doc = "                 callback returned a fatal error."]
    #[doc = " \\return         A bitwise combination of \\c MBEDTLS_X509_BADCERT_XXX"]
    #[doc = "                 and \\c MBEDTLS_X509_BADCRL_XXX failure flags; see x509.h."]
    #[link_name = "\u{1}mbedtls_ssl_get_verify_result"]
    pub fn ssl_get_verify_result(ssl: *const ssl_context) -> u32;
}
extern "C" {
    #[doc = " \\brief          Return the name of the current ciphersuite"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         a string containing the ciphersuite name"]
    #[link_name = "\u{1}mbedtls_ssl_get_ciphersuite"]
    pub fn ssl_get_ciphersuite(ssl: *const ssl_context) -> *const crate::types::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the current SSL version (SSLv3/TLSv1/etc)"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         a string containing the SSL version"]
    #[link_name = "\u{1}mbedtls_ssl_get_version"]
    pub fn ssl_get_version(ssl: *const ssl_context) -> *const crate::types::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the (maximum) number of bytes added by the record"]
    #[doc = "                 layer: header + encryption/MAC overhead (inc. padding)"]
    #[doc = ""]
    #[doc = " \\note           This function is not available (always returns an error)"]
    #[doc = "                 when record compression is enabled."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum record expansion in bytes, or"]
    #[doc = "                 MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if compression is"]
    #[doc = "                 enabled, which makes expansion much less predictable"]
    #[link_name = "\u{1}mbedtls_ssl_get_record_expansion"]
    pub fn ssl_get_record_expansion(ssl: *const ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the maximum fragment length (payload, in bytes) for"]
    #[doc = "                 the output buffer. For the client, this is the configured"]
    #[doc = "                 value. For the server, it is the minimum of two - the"]
    #[doc = "                 configured value and the negotiated one."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_conf_max_frag_len()"]
    #[doc = " \\sa             mbedtls_ssl_get_max_record_payload()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum fragment length for the output buffer."]
    #[link_name = "\u{1}mbedtls_ssl_get_output_max_frag_len"]
    pub fn ssl_get_output_max_frag_len(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the maximum fragment length (payload, in bytes) for"]
    #[doc = "                 the input buffer. This is the negotiated maximum fragment"]
    #[doc = "                 length, or, if there is none, MBEDTLS_SSL_MAX_CONTENT_LEN."]
    #[doc = "                 If it is not defined either, the value is 2^14. This function"]
    #[doc = "                 works as its predecessor, \\c mbedtls_ssl_get_max_frag_len()."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_conf_max_frag_len()"]
    #[doc = " \\sa             mbedtls_ssl_get_max_record_payload()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum fragment length for the output buffer."]
    #[link_name = "\u{1}mbedtls_ssl_get_input_max_frag_len"]
    pub fn ssl_get_input_max_frag_len(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          This function is a deprecated approach to getting the max"]
    #[doc = "                 fragment length. Its an alias for"]
    #[doc = "                 \\c mbedtls_ssl_get_output_max_frag_len(), as the behaviour"]
    #[doc = "                 is the same. See \\c mbedtls_ssl_get_output_max_frag_len() for"]
    #[doc = "                 more detail."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_get_input_max_frag_len()"]
    #[doc = " \\sa             mbedtls_ssl_get_output_max_frag_len()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum fragment length for the output buffer."]
    #[link_name = "\u{1}mbedtls_ssl_get_max_frag_len"]
    pub fn ssl_get_max_frag_len(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the current maximum outgoing record payload in bytes."]
    #[doc = "                 This takes into account the config.h setting \\c"]
    #[doc = "                 MBEDTLS_SSL_OUT_CONTENT_LEN, the configured and negotiated"]
    #[doc = "                 max fragment length extension if used, and for DTLS the"]
    #[doc = "                 path MTU as configured and current record expansion."]
    #[doc = ""]
    #[doc = " \\note           With DTLS, \\c mbedtls_ssl_write() will return an error if"]
    #[doc = "                 called with a larger length value."]
    #[doc = "                 With TLS, \\c mbedtls_ssl_write() will fragment the input if"]
    #[doc = "                 necessary and return the number of bytes written; it is up"]
    #[doc = "                 to the caller to call \\c mbedtls_ssl_write() again in"]
    #[doc = "                 order to send the remaining bytes if any."]
    #[doc = ""]
    #[doc = " \\note           This function is not available (always returns an error)"]
    #[doc = "                 when record compression is enabled."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_set_mtu()"]
    #[doc = " \\sa             mbedtls_ssl_get_output_max_frag_len()"]
    #[doc = " \\sa             mbedtls_ssl_get_input_max_frag_len()"]
    #[doc = " \\sa             mbedtls_ssl_get_record_expansion()"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         Current maximum payload for an outgoing record,"]
    #[doc = "                 or a negative error code."]
    #[link_name = "\u{1}mbedtls_ssl_get_max_out_record_payload"]
    pub fn ssl_get_max_out_record_payload(ssl: *const ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the peer certificate from the current connection."]
    #[doc = ""]
    #[doc = " \\param  ssl     The SSL context to use. This must be initialized and setup."]
    #[doc = ""]
    #[doc = " \\return         The current peer certificate, if available."]
    #[doc = "                 The returned certificate is owned by the SSL context and"]
    #[doc = "                 is valid only until the next call to the SSL API."]
    #[doc = " \\return         \\c NULL if no peer certificate is available. This might"]
    #[doc = "                 be because the chosen ciphersuite doesn't use CRTs"]
    #[doc = "                 (PSK-based ciphersuites, for example), or because"]
    #[doc = "                 #MBEDTLS_SSL_KEEP_PEER_CERTIFICATE has been disabled,"]
    #[doc = "                 allowing the stack to free the peer's CRT to save memory."]
    #[doc = ""]
    #[doc = " \\note           For one-time inspection of the peer's certificate during"]
    #[doc = "                 the handshake, consider registering an X.509 CRT verification"]
    #[doc = "                 callback through mbedtls_ssl_conf_verify() instead of calling"]
    #[doc = "                 this function. Using mbedtls_ssl_conf_verify() also comes at"]
    #[doc = "                 the benefit of allowing you to influence the verification"]
    #[doc = "                 process, for example by masking expected and tolerated"]
    #[doc = "                 verification failures."]
    #[doc = ""]
    #[doc = " \\warning        You must not use the pointer returned by this function"]
    #[doc = "                 after any further call to the SSL API, including"]
    #[doc = "                 mbedtls_ssl_read() and mbedtls_ssl_write(); this is"]
    #[doc = "                 because the pointer might change during renegotiation,"]
    #[doc = "                 which happens transparently to the user."]
    #[doc = "                 If you want to use the certificate across API calls,"]
    #[doc = "                 you must make a copy."]
    #[link_name = "\u{1}mbedtls_ssl_get_peer_cert"]
    pub fn ssl_get_peer_cert(ssl: *const ssl_context) -> *const x509_crt;
}
extern "C" {
    #[doc = " \\brief          Save session in order to resume it later (client-side only)"]
    #[doc = "                 Session data is copied to presented session structure."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param session  session context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed,"]
    #[doc = "                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used server-side or"]
    #[doc = "                 arguments are otherwise invalid."]
    #[doc = ""]
    #[doc = " \\note           Only the server certificate is copied, and not the full chain,"]
    #[doc = "                 so you should not attempt to validate the certificate again"]
    #[doc = "                 by calling \\c mbedtls_x509_crt_verify() on it."]
    #[doc = "                 Instead, you should use the results from the verification"]
    #[doc = "                 in the original handshake by calling \\c mbedtls_ssl_get_verify_result()"]
    #[doc = "                 after loading the session again into a new SSL context"]
    #[doc = "                 using \\c mbedtls_ssl_set_session()."]
    #[doc = ""]
    #[doc = " \\note           Once the session object is not needed anymore, you should"]
    #[doc = "                 free it by calling \\c mbedtls_ssl_session_free()."]
    #[doc = ""]
    #[doc = " \\sa             mbedtls_ssl_set_session()"]
    #[link_name = "\u{1}mbedtls_ssl_get_session"]
    pub fn ssl_get_session(
        ssl: *const ssl_context,
        session: *mut ssl_session,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform the SSL handshake"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE"]
    #[doc = "                 if the handshake is incomplete and waiting for data to"]
    #[doc = "                 be available for reading from or writing to the underlying"]
    #[doc = "                 transport - in this case you must call this function again"]
    #[doc = "                 when the underlying transport is ready for the operation."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous"]
    #[doc = "                 operation is in progress (see"]
    #[doc = "                 mbedtls_ssl_conf_async_private_cb()) - in this case you"]
    #[doc = "                 must call this function again when the operation is ready."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic"]
    #[doc = "                 operation is in progress (see mbedtls_ecp_set_max_ops()) -"]
    #[doc = "                 in this case you must call this function again to complete"]
    #[doc = "                 the handshake when you're done attending other tasks."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED if DTLS is in use"]
    #[doc = "                 and the client did not demonstrate reachability yet - in"]
    #[doc = "                 this case you must stop using the context (see below)."]
    #[doc = " \\return         Another SSL error code - in this case you must stop using"]
    #[doc = "                 the context (see below)."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than"]
    #[doc = "                 \\c 0,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,"]
    #[doc = "                 you must stop using the SSL context for reading or writing,"]
    #[doc = "                 and either free it or call \\c mbedtls_ssl_session_reset()"]
    #[doc = "                 on it before re-using it for a new connection; the current"]
    #[doc = "                 connection must be closed."]
    #[doc = ""]
    #[doc = " \\note           If DTLS is in use, then you may choose to handle"]
    #[doc = "                 #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging"]
    #[doc = "                 purposes, as it is an expected return value rather than an"]
    #[doc = "                 actual error, but you still need to reset/free the context."]
    #[doc = ""]
    #[doc = " \\note           Remarks regarding event-driven DTLS:"]
    #[doc = "                 If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram"]
    #[doc = "                 from the underlying transport layer is currently being processed,"]
    #[doc = "                 and it is safe to idle until the timer or the underlying transport"]
    #[doc = "                 signal a new event. This is not true for a successful handshake,"]
    #[doc = "                 in which case the datagram of the underlying transport that is"]
    #[doc = "                 currently being processed might or might not contain further"]
    #[doc = "                 DTLS records."]
    #[link_name = "\u{1}mbedtls_ssl_handshake"]
    pub fn ssl_handshake(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a single step of the SSL handshake"]
    #[doc = ""]
    #[doc = " \\note           The state of the context (ssl->state) will be at"]
    #[doc = "                 the next state after this function returns \\c 0. Do not"]
    #[doc = "                 call this function if state is MBEDTLS_SSL_HANDSHAKE_OVER."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         See mbedtls_ssl_handshake()."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than \\c 0,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it"]
    #[doc = "                 or call \\c mbedtls_ssl_session_reset() on it before"]
    #[doc = "                 re-using it for a new connection; the current connection"]
    #[doc = "                 must be closed."]
    #[link_name = "\u{1}mbedtls_ssl_handshake_step"]
    pub fn ssl_handshake_step(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initiate an SSL renegotiation on the running connection."]
    #[doc = "                 Client: perform the renegotiation right now."]
    #[doc = "                 Server: request renegotiation, which will be performed"]
    #[doc = "                 during the next call to mbedtls_ssl_read() if honored by"]
    #[doc = "                 client."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or any mbedtls_ssl_handshake() return"]
    #[doc = "                 value except #MBEDTLS_ERR_SSL_CLIENT_RECONNECT that can't"]
    #[doc = "                 happen during a renegotiation."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than \\c 0,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it"]
    #[doc = "                 or call \\c mbedtls_ssl_session_reset() on it before"]
    #[doc = "                 re-using it for a new connection; the current connection"]
    #[doc = "                 must be closed."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_ssl_renegotiate"]
    pub fn ssl_renegotiate(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Read at most 'len' application data bytes"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param buf      buffer that will hold the data"]
    #[doc = " \\param len      maximum number of bytes to read"]
    #[doc = ""]
    #[doc = " \\return         The (positive) number of bytes read if successful."]
    #[doc = " \\return         \\c 0 if the read end of the underlying transport was closed"]
    #[doc = "                 without sending a CloseNotify beforehand, which might happen"]
    #[doc = "                 because of various reasons (internal error of an underlying"]
    #[doc = "                 stack, non-conformant peer not sending a CloseNotify and"]
    #[doc = "                 such) - in this case you must stop using the context"]
    #[doc = "                 (see below)."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY if the underlying"]
    #[doc = "                 transport is still functional, but the peer has"]
    #[doc = "                 acknowledged to not send anything anymore."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE"]
    #[doc = "                 if the handshake is incomplete and waiting for data to"]
    #[doc = "                 be available for reading from or writing to the underlying"]
    #[doc = "                 transport - in this case you must call this function again"]
    #[doc = "                 when the underlying transport is ready for the operation."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous"]
    #[doc = "                 operation is in progress (see"]
    #[doc = "                 mbedtls_ssl_conf_async_private_cb()) - in this case you"]
    #[doc = "                 must call this function again when the operation is ready."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic"]
    #[doc = "                 operation is in progress (see mbedtls_ecp_set_max_ops()) -"]
    #[doc = "                 in this case you must call this function again to complete"]
    #[doc = "                 the handshake when you're done attending other tasks."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_CLIENT_RECONNECT if we're at the server"]
    #[doc = "                 side of a DTLS connection and the client is initiating a"]
    #[doc = "                 new connection using the same source port. See below."]
    #[doc = " \\return         Another SSL error code - in this case you must stop using"]
    #[doc = "                 the context (see below)."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than"]
    #[doc = "                 a positive value,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CLIENT_RECONNECT,"]
    #[doc = "                 you must stop using the SSL context for reading or writing,"]
    #[doc = "                 and either free it or call \\c mbedtls_ssl_session_reset()"]
    #[doc = "                 on it before re-using it for a new connection; the current"]
    #[doc = "                 connection must be closed."]
    #[doc = ""]
    #[doc = " \\note           When this function returns #MBEDTLS_ERR_SSL_CLIENT_RECONNECT"]
    #[doc = "                 (which can only happen server-side), it means that a client"]
    #[doc = "                 is initiating a new connection using the same source port."]
    #[doc = "                 You can either treat that as a connection close and wait"]
    #[doc = "                 for the client to resend a ClientHello, or directly"]
    #[doc = "                 continue with \\c mbedtls_ssl_handshake() with the same"]
    #[doc = "                 context (as it has been reset internally). Either way, you"]
    #[doc = "                 must make sure this is seen by the application as a new"]
    #[doc = "                 connection: application state, if any, should be reset, and"]
    #[doc = "                 most importantly the identity of the client must be checked"]
    #[doc = "                 again. WARNING: not validating the identity of the client"]
    #[doc = "                 again, or not transmitting the new identity to the"]
    #[doc = "                 application layer, would allow authentication bypass!"]
    #[doc = ""]
    #[doc = " \\note           Remarks regarding event-driven DTLS:"]
    #[doc = "                 - If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram"]
    #[doc = "                   from the underlying transport layer is currently being processed,"]
    #[doc = "                   and it is safe to idle until the timer or the underlying transport"]
    #[doc = "                   signal a new event."]
    #[doc = "                 - This function may return MBEDTLS_ERR_SSL_WANT_READ even if data was"]
    #[doc = "                   initially available on the underlying transport, as this data may have"]
    #[doc = "                   been only e.g. duplicated messages or a renegotiation request."]
    #[doc = "                   Therefore, you must be prepared to receive MBEDTLS_ERR_SSL_WANT_READ even"]
    #[doc = "                   when reacting to an incoming-data event from the underlying transport."]
    #[doc = "                 - On success, the datagram of the underlying transport that is currently"]
    #[doc = "                   being processed may contain further DTLS records. You should call"]
    #[doc = "                   \\c mbedtls_ssl_check_pending to check for remaining records."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_ssl_read"]
    pub fn ssl_read(
        ssl: *mut ssl_context,
        buf: *mut crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Try to write exactly 'len' application data bytes"]
    #[doc = ""]
    #[doc = " \\warning        This function will do partial writes in some cases. If the"]
    #[doc = "                 return value is non-negative but less than length, the"]
    #[doc = "                 function must be called again with updated arguments:"]
    #[doc = "                 buf + ret, len - ret (if ret is the return value) until"]
    #[doc = "                 it returns a value equal to the last 'len' argument."]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = " \\param buf      buffer holding the data"]
    #[doc = " \\param len      how many bytes must be written"]
    #[doc = ""]
    #[doc = " \\return         The (non-negative) number of bytes actually written if"]
    #[doc = "                 successful (may be less than \\p len)."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE"]
    #[doc = "                 if the handshake is incomplete and waiting for data to"]
    #[doc = "                 be available for reading from or writing to the underlying"]
    #[doc = "                 transport - in this case you must call this function again"]
    #[doc = "                 when the underlying transport is ready for the operation."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous"]
    #[doc = "                 operation is in progress (see"]
    #[doc = "                 mbedtls_ssl_conf_async_private_cb()) - in this case you"]
    #[doc = "                 must call this function again when the operation is ready."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic"]
    #[doc = "                 operation is in progress (see mbedtls_ecp_set_max_ops()) -"]
    #[doc = "                 in this case you must call this function again to complete"]
    #[doc = "                 the handshake when you're done attending other tasks."]
    #[doc = " \\return         Another SSL error code - in this case you must stop using"]
    #[doc = "                 the context (see below)."]
    #[doc = ""]
    #[doc = " \\warning        If this function returns something other than"]
    #[doc = "                 a non-negative value,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_READ,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_WANT_WRITE,"]
    #[doc = "                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or"]
    #[doc = "                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,"]
    #[doc = "                 you must stop using the SSL context for reading or writing,"]
    #[doc = "                 and either free it or call \\c mbedtls_ssl_session_reset()"]
    #[doc = "                 on it before re-using it for a new connection; the current"]
    #[doc = "                 connection must be closed."]
    #[doc = ""]
    #[doc = " \\note           When this function returns #MBEDTLS_ERR_SSL_WANT_WRITE/READ,"]
    #[doc = "                 it must be called later with the *same* arguments,"]
    #[doc = "                 until it returns a value greater that or equal to 0. When"]
    #[doc = "                 the function returns #MBEDTLS_ERR_SSL_WANT_WRITE there may be"]
    #[doc = "                 some partial data in the output buffer, however this is not"]
    #[doc = "                 yet sent."]
    #[doc = ""]
    #[doc = " \\note           If the requested length is greater than the maximum"]
    #[doc = "                 fragment length (either the built-in limit or the one set"]
    #[doc = "                 or negotiated with the peer), then:"]
    #[doc = "                 - with TLS, less bytes than requested are written."]
    #[doc = "                 - with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned."]
    #[doc = "                 \\c mbedtls_ssl_get_output_max_frag_len() may be used to"]
    #[doc = "                 query the active maximum fragment length."]
    #[doc = ""]
    #[doc = " \\note           Attempting to write 0 bytes will result in an empty TLS"]
    #[doc = "                 application record being sent."]
    #[link_name = "\u{1}mbedtls_ssl_write"]
    pub fn ssl_write(
        ssl: *mut ssl_context,
        buf: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Send an alert message"]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     The alert level of the message"]
    #[doc = "                  (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL)"]
    #[doc = " \\param message   The alert message (SSL_ALERT_MSG_*)"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific SSL error code."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0 or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it or"]
    #[doc = "                 call \\c mbedtls_ssl_session_reset() on it before re-using it"]
    #[doc = "                 for a new connection; the current connection must be closed."]
    #[link_name = "\u{1}mbedtls_ssl_send_alert_message"]
    pub fn ssl_send_alert_message(
        ssl: *mut ssl_context,
        level: crate::types::c_uchar,
        message: crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Notify the peer that the connection is being closed"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a specific SSL error code."]
    #[doc = ""]
    #[doc = " \\note           If this function returns something other than 0 or"]
    #[doc = "                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using"]
    #[doc = "                 the SSL context for reading or writing, and either free it or"]
    #[doc = "                 call \\c mbedtls_ssl_session_reset() on it before re-using it"]
    #[doc = "                 for a new connection; the current connection must be closed."]
    #[link_name = "\u{1}mbedtls_ssl_close_notify"]
    pub fn ssl_close_notify(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL context and clear memory"]
    #[doc = ""]
    #[doc = " \\param ssl      SSL context"]
    #[link_name = "\u{1}mbedtls_ssl_free"]
    pub fn ssl_free(ssl: *mut ssl_context);
}
extern "C" {
    #[doc = " \\brief          Save an active connection as serialized data in a buffer."]
    #[doc = "                 This allows the freeing or re-using of the SSL context"]
    #[doc = "                 while still picking up the connection later in a way that"]
    #[doc = "                 it entirely transparent to the peer."]
    #[doc = ""]
    #[doc = " \\see            mbedtls_ssl_context_load()"]
    #[doc = ""]
    #[doc = " \\note           This feature is currently only available under certain"]
    #[doc = "                 conditions, see the documentation of the return value"]
    #[doc = "                 #MBEDTLS_ERR_SSL_BAD_INPUT_DATA for details."]
    #[doc = ""]
    #[doc = " \\note           When this function succeeds, it calls"]
    #[doc = "                 mbedtls_ssl_session_reset() on \\p ssl which as a result is"]
    #[doc = "                 no longer associated with the connection that has been"]
    #[doc = "                 serialized. This avoids creating copies of the connection"]
    #[doc = "                 state. You're then free to either re-use the context"]
    #[doc = "                 structure for a different connection, or call"]
    #[doc = "                 mbedtls_ssl_free() on it. See the documentation of"]
    #[doc = "                 mbedtls_ssl_session_reset() for more details."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context to save. On success, it is no longer"]
    #[doc = "                 associated with the connection that has been serialized."]
    #[doc = " \\param buf      The buffer to write the serialized data to. It must be a"]
    #[doc = "                 writeable buffer of at least \\p buf_len bytes, or may be \\c"]
    #[doc = "                 NULL if \\p buf_len is \\c 0."]
    #[doc = " \\param buf_len  The number of bytes available for writing in \\p buf."]
    #[doc = " \\param olen     The size in bytes of the data that has been or would have"]
    #[doc = "                 been written. It must point to a valid \\c size_t."]
    #[doc = ""]
    #[doc = " \\note           \\p olen is updated to the correct value regardless of"]
    #[doc = "                 whether \\p buf_len was large enough. This makes it possible"]
    #[doc = "                 to determine the necessary size by calling this function"]
    #[doc = "                 with \\p buf set to \\c NULL and \\p buf_len to \\c 0. However,"]
    #[doc = "                 the value of \\p olen is only guaranteed to be correct when"]
    #[doc = "                 the function returns #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL or"]
    #[doc = "                 \\c 0. If the return value is different, then the value of"]
    #[doc = "                 \\p olen is undefined."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \\p buf is too small."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed"]
    #[doc = "                 while reseting the context."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if a handshake is in"]
    #[doc = "                 progress, or there is pending data for reading or sending,"]
    #[doc = "                 or the connection does not use DTLS 1.2 with an AEAD"]
    #[doc = "                 ciphersuite, or renegotiation is enabled."]
    #[link_name = "\u{1}mbedtls_ssl_context_save"]
    pub fn ssl_context_save(
        ssl: *mut ssl_context,
        buf: *mut crate::types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Load serialized connection data to an SSL context."]
    #[doc = ""]
    #[doc = " \\see            mbedtls_ssl_context_save()"]
    #[doc = ""]
    #[doc = " \\warning        The same serialized data must never be loaded into more"]
    #[doc = "                 that one context. In order to ensure that, after"]
    #[doc = "                 successfully loading serialized data to an SSL context, you"]
    #[doc = "                 should immediately destroy or invalidate all copies of the"]
    #[doc = "                 serialized data that was loaded. Loading the same data in"]
    #[doc = "                 more than one context would cause severe security failures"]
    #[doc = "                 including but not limited to loss of confidentiality."]
    #[doc = ""]
    #[doc = " \\note           Before calling this function, the SSL context must be"]
    #[doc = "                 prepared in one of the two following ways. The first way is"]
    #[doc = "                 to take a context freshly initialised with"]
    #[doc = "                 mbedtls_ssl_init() and call mbedtls_ssl_setup() on it with"]
    #[doc = "                 the same ::mbedtls_ssl_config structure that was used in"]
    #[doc = "                 the original connection. The second way is to"]
    #[doc = "                 call mbedtls_ssl_session_reset() on a context that was"]
    #[doc = "                 previously prepared as above but used in the meantime."]
    #[doc = "                 Either way, you must not use the context to perform a"]
    #[doc = "                 handshake between calling mbedtls_ssl_setup() or"]
    #[doc = "                 mbedtls_ssl_session_reset() and calling this function. You"]
    #[doc = "                 may however call other setter functions in that time frame"]
    #[doc = "                 as indicated in the note below."]
    #[doc = ""]
    #[doc = " \\note           Before or after calling this function successfully, you"]
    #[doc = "                 also need to configure some connection-specific callbacks"]
    #[doc = "                 and settings before you can use the connection again"]
    #[doc = "                 (unless they were already set before calling"]
    #[doc = "                 mbedtls_ssl_session_reset() and the values are suitable for"]
    #[doc = "                 the present connection). Specifically, you want to call"]
    #[doc = "                 at least mbedtls_ssl_set_bio() and"]
    #[doc = "                 mbedtls_ssl_set_timer_cb(). All other SSL setter functions"]
    #[doc = "                 are not necessary to call, either because they're only used"]
    #[doc = "                 in handshakes, or because the setting is already saved. You"]
    #[doc = "                 might choose to call them anyway, for example in order to"]
    #[doc = "                 share code between the cases of establishing a new"]
    #[doc = "                 connection and the case of loading an already-established"]
    #[doc = "                 connection."]
    #[doc = ""]
    #[doc = " \\note           If you have new information about the path MTU, you want to"]
    #[doc = "                 call mbedtls_ssl_set_mtu() after calling this function, as"]
    #[doc = "                 otherwise this function would overwrite your"]
    #[doc = "                 newly-configured value with the value that was active when"]
    #[doc = "                 the context was saved."]
    #[doc = ""]
    #[doc = " \\note           When this function returns an error code, it calls"]
    #[doc = "                 mbedtls_ssl_free() on \\p ssl. In this case, you need to"]
    #[doc = "                 prepare the context with the usual sequence starting with a"]
    #[doc = "                 call to mbedtls_ssl_init() if you want to use it again."]
    #[doc = ""]
    #[doc = " \\param ssl      The SSL context structure to be populated. It must have"]
    #[doc = "                 been prepared as described in the note above."]
    #[doc = " \\param buf      The buffer holding the serialized connection data. It must"]
    #[doc = "                 be a readable buffer of at least \\p len bytes."]
    #[doc = " \\param len      The size of the serialized data in bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data"]
    #[doc = "                 comes from a different Mbed TLS version or build."]
    #[doc = " \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid."]
    #[link_name = "\u{1}mbedtls_ssl_context_load"]
    pub fn ssl_context_load(
        ssl: *mut ssl_context,
        buf: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL configuration context"]
    #[doc = "                 Just makes the context ready for"]
    #[doc = "                 mbedtls_ssl_config_defaults() or mbedtls_ssl_config_free()."]
    #[doc = ""]
    #[doc = " \\note           You need to call mbedtls_ssl_config_defaults() unless you"]
    #[doc = "                 manually set all of the relevant fields yourself."]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    #[link_name = "\u{1}mbedtls_ssl_config_init"]
    pub fn ssl_config_init(conf: *mut ssl_config);
}
extern "C" {
    #[doc = " \\brief          Load reasonnable default SSL configuration values."]
    #[doc = "                 (You need to call mbedtls_ssl_config_init() first.)"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    #[doc = " \\param endpoint MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER"]
    #[doc = " \\param transport MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or"]
    #[doc = "                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS"]
    #[doc = " \\param preset   a MBEDTLS_SSL_PRESET_XXX value"]
    #[doc = ""]
    #[doc = " \\note           See \\c mbedtls_ssl_conf_transport() for notes on DTLS."]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or"]
    #[doc = "                 MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error."]
    #[link_name = "\u{1}mbedtls_ssl_config_defaults"]
    pub fn ssl_config_defaults(
        conf: *mut ssl_config,
        endpoint: crate::types::c_int,
        transport: crate::types::c_int,
        preset: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Free an SSL configuration context"]
    #[doc = ""]
    #[doc = " \\param conf     SSL configuration context"]
    #[link_name = "\u{1}mbedtls_ssl_config_free"]
    pub fn ssl_config_free(conf: *mut ssl_config);
}
extern "C" {
    #[doc = " \\brief          Initialize SSL session structure"]
    #[doc = ""]
    #[doc = " \\param session  SSL session"]
    #[link_name = "\u{1}mbedtls_ssl_session_init"]
    pub fn ssl_session_init(session: *mut ssl_session);
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL session including the"]
    #[doc = "                 peer certificate and clear memory"]
    #[doc = ""]
    #[doc = " \\note           A session object can be freed even if the SSL context"]
    #[doc = "                 that was used to retrieve the session is still in use."]
    #[doc = ""]
    #[doc = " \\param session  SSL session"]
    #[link_name = "\u{1}mbedtls_ssl_session_free"]
    pub fn ssl_session_free(session: *mut ssl_session);
}
extern "C" {
    #[doc = " \\brief          TLS-PRF function for key derivation."]
    #[doc = ""]
    #[doc = " \\param prf      The tls_prf type funtion type to be used."]
    #[doc = " \\param secret   Secret for the key derivation function."]
    #[doc = " \\param slen     Length of the secret."]
    #[doc = " \\param label    String label for the key derivation function,"]
    #[doc = "                 terminated with null character."]
    #[doc = " \\param random   Random bytes."]
    #[doc = " \\param rlen     Length of the random bytes buffer."]
    #[doc = " \\param dstbuf   The buffer holding the derived key."]
    #[doc = " \\param dlen     Length of the output buffer."]
    #[doc = ""]
    #[doc = " \\return         0 on sucess. An SSL specific error on failure."]
    #[link_name = "\u{1}mbedtls_ssl_tls_prf"]
    pub fn ssl_tls_prf(
        prf: tls_prf_types,
        secret: *const crate::types::c_uchar,
        slen: usize,
        label: *const crate::types::c_char,
        random: *const crate::types::c_uchar,
        rlen: usize,
        dstbuf: *mut crate::types::c_uchar,
        dlen: usize,
    ) -> crate::types::c_int;
}
#[doc = " \\brief          MD5 context structure"]
#[doc = ""]
#[doc = " \\warning        MD5 is considered a weak message digest and its use"]
#[doc = "                 constitutes a security risk. We recommend considering"]
#[doc = "                 stronger message digests instead."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md5_context {
    #[doc = "< number of bytes processed"]
    pub total: [u32; 2usize],
    #[doc = "< intermediate digest state"]
    pub state: [u32; 4usize],
    #[doc = "< data block being processed"]
    pub buffer: [crate::types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md5_context() {
    assert_eq!(
        ::core::mem::size_of::<md5_context>(),
        88usize,
        concat!("Size of: ", stringify!(md5_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md5_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md5_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md5_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md5_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md5_context>())).buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for md5_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Initialize MD5 context"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context to be initialized"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_init"]
    pub fn md5_init(ctx: *mut md5_context);
}
extern "C" {
    #[doc = " \\brief          Clear MD5 context"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context to be cleared"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_free"]
    pub fn md5_free(ctx: *mut md5_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) an MD5 context"]
    #[doc = ""]
    #[doc = " \\param dst      The destination context"]
    #[doc = " \\param src      The context to be cloned"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_clone"]
    pub fn md5_clone(dst: *mut md5_context, src: *const md5_context);
}
extern "C" {
    #[doc = " \\brief          MD5 context setup"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_starts_ret"]
    pub fn md5_starts_ret(ctx: *mut md5_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 process buffer"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_update_ret"]
    pub fn md5_update_ret(
        ctx: *mut md5_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 final digest"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param output   MD5 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_finish_ret"]
    pub fn md5_finish_ret(
        ctx: *mut md5_context,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param data     buffer holding one block of data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_internal_md5_process"]
    pub fn internal_md5_process(
        ctx: *mut md5_context,
        data: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 context setup"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md5_starts_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_starts"]
    pub fn md5_starts(ctx: *mut md5_context);
}
extern "C" {
    #[doc = " \\brief          MD5 process buffer"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md5_update_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_update"]
    pub fn md5_update(ctx: *mut md5_context, input: *const crate::types::c_uchar, ilen: usize);
}
extern "C" {
    #[doc = " \\brief          MD5 final digest"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md5_finish_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param output   MD5 checksum result"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_finish"]
    pub fn md5_finish(ctx: *mut md5_context, output: *mut crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          MD5 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_internal_md5_process() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      MD5 context"]
    #[doc = " \\param data     buffer holding one block of data"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_process"]
    pub fn md5_process(ctx: *mut md5_context, data: *const crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          Output = MD5( input buffer )"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   MD5 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_ret"]
    pub fn md5_ret(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = MD5( input buffer )"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md5_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   MD5 checksum result"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5"]
    pub fn md5(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[doc = ""]
    #[doc = " \\warning        MD5 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md5_self_test"]
    pub fn md5_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          The SHA-1 context structure."]
#[doc = ""]
#[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
#[doc = "                 constitutes a security risk. We recommend considering"]
#[doc = "                 stronger message digests instead."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha1_context {
    #[doc = "< The number of Bytes processed."]
    pub total: [u32; 2usize],
    #[doc = "< The intermediate digest state."]
    pub state: [u32; 5usize],
    #[doc = "< The data block being processed."]
    pub buffer: [crate::types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_sha1_context() {
    assert_eq!(
        ::core::mem::size_of::<sha1_context>(),
        92usize,
        concat!("Size of: ", stringify!(sha1_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha1_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sha1_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha1_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha1_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha1_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha1_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha1_context>())).buffer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sha1_context),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for sha1_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-1 context."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to initialize."]
    #[doc = "                 This must not be \\c NULL."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1_init"]
    pub fn sha1_init(ctx: *mut sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-1 context."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to clear. This may be \\c NULL,"]
    #[doc = "                 in which case this function does nothing. If it is"]
    #[doc = "                 not \\c NULL, it must point to an initialized"]
    #[doc = "                 SHA-1 context."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1_free"]
    pub fn sha1_free(ctx: *mut sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-1 context."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param dst      The SHA-1 context to clone to. This must be initialized."]
    #[doc = " \\param src      The SHA-1 context to clone from. This must be initialized."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1_clone"]
    pub fn sha1_clone(dst: *mut sha1_context, src: *const sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-1 checksum calculation."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to initialize. This must be initialized."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1_starts_ret"]
    pub fn sha1_starts_ret(ctx: *mut sha1_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing SHA-1"]
    #[doc = "                 checksum calculation."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 This must be a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data \\p input in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_sha1_update_ret"]
    pub fn sha1_update_ret(
        ctx: *mut sha1_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-1 operation, and writes"]
    #[doc = "                 the result to the output buffer."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to use. This must be initialized and"]
    #[doc = "                 have a hash operation started."]
    #[doc = " \\param output   The SHA-1 checksum result. This must be a writable"]
    #[doc = "                 buffer of length \\c 20 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_sha1_finish_ret"]
    pub fn sha1_finish_ret(
        ctx: *mut sha1_context,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          SHA-1 process data block (internal use only)."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to use. This must be initialized."]
    #[doc = " \\param data     The data block being processed. This must be a"]
    #[doc = "                 readable buffer of length \\c 64 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_internal_sha1_process"]
    pub fn internal_sha1_process(
        ctx: *mut sha1_context,
        data: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-1 checksum calculation."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha1_starts_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context to initialize. This must be initialized."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1_starts"]
    pub fn sha1_starts(ctx: *mut sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing SHA-1"]
    #[doc = "                 checksum calculation."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha1_update_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context. This must be initialized and"]
    #[doc = "                 have a hash operation started."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 This must be a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data \\p input in Bytes."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1_update"]
    pub fn sha1_update(ctx: *mut sha1_context, input: *const crate::types::c_uchar, ilen: usize);
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-1 operation, and writes"]
    #[doc = "                 the result to the output buffer."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha1_finish_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context. This must be initialized and"]
    #[doc = "                 have a hash operation started."]
    #[doc = " \\param output   The SHA-1 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 20 Bytes."]
    #[link_name = "\u{1}mbedtls_sha1_finish"]
    pub fn sha1_finish(ctx: *mut sha1_context, output: *mut crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          SHA-1 process data block (internal use only)."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_internal_sha1_process() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-1 context. This must be initialized."]
    #[doc = " \\param data     The data block being processed."]
    #[doc = "                 This must be a readable buffer of length \\c 64 bytes."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1_process"]
    pub fn sha1_process(ctx: *mut sha1_context, data: *const crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-1 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-1 result is calculated as"]
    #[doc = "                 output = SHA-1(input buffer)."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 This must be a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data \\p input in Bytes."]
    #[doc = " \\param output   The SHA-1 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 20 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1_ret"]
    pub fn sha1_ret(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-1 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-1 result is calculated as"]
    #[doc = "                 output = SHA-1(input buffer)."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha1_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 This must be a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data \\p input in Bytes."]
    #[doc = " \\param output   The SHA-1 checksum result. This must be a writable"]
    #[doc = "                 buffer of size \\c 20 Bytes."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1"]
    pub fn sha1(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          The SHA-1 checkup routine."]
    #[doc = ""]
    #[doc = " \\warning        SHA-1 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_sha1_self_test"]
    pub fn sha1_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          The SHA-256 context structure."]
#[doc = ""]
#[doc = "                 The structure is used both for SHA-256 and for SHA-224"]
#[doc = "                 checksum calculations. The choice between these two is"]
#[doc = "                 made in the call to mbedtls_sha256_starts_ret()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha256_context {
    #[doc = "< The number of Bytes processed."]
    pub total: [u32; 2usize],
    #[doc = "< The intermediate digest state."]
    pub state: [u32; 8usize],
    #[doc = "< The data block being processed."]
    pub buffer: [crate::types::c_uchar; 64usize],
    #[doc = "< Determines which function to use:"]
    #[doc = "0: Use SHA-256, or 1: Use SHA-224."]
    pub is224: crate::types::c_int,
}
#[test]
fn bindgen_test_layout_sha256_context() {
    assert_eq!(
        ::core::mem::size_of::<sha256_context>(),
        108usize,
        concat!("Size of: ", stringify!(sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha256_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sha256_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha256_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha256_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha256_context>())).buffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha256_context>())).is224 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(is224)
        )
    );
}
impl Default for sha256_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-256 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context to initialize. This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_sha256_init"]
    pub fn sha256_init(ctx: *mut sha256_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-256 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context to clear. This may be \\c NULL, in which"]
    #[doc = "                 case this function returns immediately. If it is not \\c NULL,"]
    #[doc = "                 it must point to an initialized SHA-256 context."]
    #[link_name = "\u{1}mbedtls_sha256_free"]
    pub fn sha256_free(ctx: *mut sha256_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-256 context."]
    #[doc = ""]
    #[doc = " \\param dst      The destination context. This must be initialized."]
    #[doc = " \\param src      The context to clone. This must be initialized."]
    #[link_name = "\u{1}mbedtls_sha256_clone"]
    pub fn sha256_clone(dst: *mut sha256_context, src: *const sha256_context);
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-224 or SHA-256 checksum"]
    #[doc = "                 calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The context to use. This must be initialized."]
    #[doc = " \\param is224    This determines which function to use. This must be"]
    #[doc = "                 either \\c 0 for SHA-256, or \\c 1 for SHA-224."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_sha256_starts_ret"]
    pub fn sha256_starts_ret(
        ctx: *mut sha256_context,
        is224: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing"]
    #[doc = "                 SHA-256 checksum calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param input    The buffer holding the data. This must be a readable"]
    #[doc = "                 buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_sha256_update_ret"]
    pub fn sha256_update_ret(
        ctx: *mut sha256_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-256 operation, and writes"]
    #[doc = "                 the result to the output buffer."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param output   The SHA-224 or SHA-256 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 32 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_sha256_finish_ret"]
    pub fn sha256_finish_ret(
        ctx: *mut sha256_context,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within"]
    #[doc = "                 the ongoing SHA-256 computation. This function is for"]
    #[doc = "                 internal use only."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context. This must be initialized."]
    #[doc = " \\param data     The buffer holding one block of data. This must"]
    #[doc = "                 be a readable buffer of length \\c 64 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_internal_sha256_process"]
    pub fn internal_sha256_process(
        ctx: *mut sha256_context,
        data: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-224 or SHA-256 checksum"]
    #[doc = "                 calculation."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha256_starts_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The context to use. This must be initialized."]
    #[doc = " \\param is224    Determines which function to use. This must be"]
    #[doc = "                 either \\c 0 for SHA-256, or \\c 1 for SHA-224."]
    #[link_name = "\u{1}mbedtls_sha256_starts"]
    pub fn sha256_starts(ctx: *mut sha256_context, is224: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing"]
    #[doc = "                 SHA-256 checksum calculation."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha256_update_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context to use. This must be"]
    #[doc = "                 initialized and have a hash operation started."]
    #[doc = " \\param input    The buffer holding the data. This must be a readable"]
    #[doc = "                 buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[link_name = "\u{1}mbedtls_sha256_update"]
    pub fn sha256_update(
        ctx: *mut sha256_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-256 operation, and writes"]
    #[doc = "                 the result to the output buffer."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha256_finish_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context. This must be initialized and"]
    #[doc = "                 have a hash operation started."]
    #[doc = " \\param output   The SHA-224 or SHA-256 checksum result. This must be"]
    #[doc = "                 a writable buffer of length \\c 32 Bytes."]
    #[link_name = "\u{1}mbedtls_sha256_finish"]
    pub fn sha256_finish(ctx: *mut sha256_context, output: *mut crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within"]
    #[doc = "                 the ongoing SHA-256 computation. This function is for"]
    #[doc = "                 internal use only."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_internal_sha256_process() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-256 context. This must be initialized."]
    #[doc = " \\param data     The buffer holding one block of data. This must be"]
    #[doc = "                 a readable buffer of size \\c 64 Bytes."]
    #[link_name = "\u{1}mbedtls_sha256_process"]
    pub fn sha256_process(ctx: *mut sha256_context, data: *const crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-224 or SHA-256"]
    #[doc = "                 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-256 result is calculated as"]
    #[doc = "                 output = SHA-256(input buffer)."]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the data. This must be a readable"]
    #[doc = "                 buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = " \\param output   The SHA-224 or SHA-256 checksum result. This must"]
    #[doc = "                 be a writable buffer of length \\c 32 Bytes."]
    #[doc = " \\param is224    Determines which function to use. This must be"]
    #[doc = "                 either \\c 0 for SHA-256, or \\c 1 for SHA-224."]
    #[link_name = "\u{1}mbedtls_sha256_ret"]
    pub fn sha256_ret(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        is224: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-224 or SHA-256 checksum"]
    #[doc = "                 of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-256 result is calculated as"]
    #[doc = "                 output = SHA-256(input buffer)."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha256_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the data. This must be a readable"]
    #[doc = "                 buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = " \\param output   The SHA-224 or SHA-256 checksum result. This must be"]
    #[doc = "                 a writable buffer of length \\c 32 Bytes."]
    #[doc = " \\param is224    Determines which function to use. This must be either"]
    #[doc = "                 \\c 0 for SHA-256, or \\c 1 for SHA-224."]
    #[link_name = "\u{1}mbedtls_sha256"]
    pub fn sha256(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        is224: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          The SHA-224 and SHA-256 checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_sha256_self_test"]
    pub fn sha256_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          The SHA-512 context structure."]
#[doc = ""]
#[doc = "                 The structure is used both for SHA-384 and for SHA-512"]
#[doc = "                 checksum calculations. The choice between these two is"]
#[doc = "                 made in the call to mbedtls_sha512_starts_ret()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha512_context {
    #[doc = "< The number of Bytes processed."]
    pub total: [u64; 2usize],
    #[doc = "< The intermediate digest state."]
    pub state: [u64; 8usize],
    #[doc = "< The data block being processed."]
    pub buffer: [crate::types::c_uchar; 128usize],
    #[doc = "< Determines which function to use:"]
    #[doc = "0: Use SHA-512, or 1: Use SHA-384."]
    pub is384: crate::types::c_int,
}
#[test]
fn bindgen_test_layout_sha512_context() {
    assert_eq!(
        ::core::mem::size_of::<sha512_context>(),
        216usize,
        concat!("Size of: ", stringify!(sha512_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha512_context>(),
        8usize,
        concat!("Alignment of ", stringify!(sha512_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha512_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha512_context>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha512_context>())).buffer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha512_context>())).is384 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(is384)
        )
    );
}
impl Default for sha512_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-512 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to initialize. This must"]
    #[doc = "                 not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_sha512_init"]
    pub fn sha512_init(ctx: *mut sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-512 context."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to clear. This may be \\c NULL,"]
    #[doc = "                 in which case this function does nothing. If it"]
    #[doc = "                 is not \\c NULL, it must point to an initialized"]
    #[doc = "                 SHA-512 context."]
    #[link_name = "\u{1}mbedtls_sha512_free"]
    pub fn sha512_free(ctx: *mut sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-512 context."]
    #[doc = ""]
    #[doc = " \\param dst      The destination context. This must be initialized."]
    #[doc = " \\param src      The context to clone. This must be initialized."]
    #[link_name = "\u{1}mbedtls_sha512_clone"]
    pub fn sha512_clone(dst: *mut sha512_context, src: *const sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-384 or SHA-512 checksum"]
    #[doc = "                 calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to use. This must be initialized."]
    #[doc = " \\param is384    Determines which function to use. This must be"]
    #[doc = "                 either \\c 0 for SHA-512, or \\c 1 for SHA-384."]
    #[doc = ""]
    #[doc = " \\note           When \\c MBEDTLS_SHA512_NO_SHA384 is defined, \\p is384 must"]
    #[doc = "                 be \\c 0, or the function will return"]
    #[doc = "                 #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_sha512_starts_ret"]
    pub fn sha512_starts_ret(
        ctx: *mut sha512_context,
        is384: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing"]
    #[doc = "                 SHA-512 checksum calculation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param input    The buffer holding the input data. This must"]
    #[doc = "                 be a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_sha512_update_ret"]
    pub fn sha512_update_ret(
        ctx: *mut sha512_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-512 operation, and writes"]
    #[doc = "                 the result to the output buffer. This function is for"]
    #[doc = "                 internal use only."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 64 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_sha512_finish_ret"]
    pub fn sha512_finish_ret(
        ctx: *mut sha512_context,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within"]
    #[doc = "                 the ongoing SHA-512 computation."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context. This must be initialized."]
    #[doc = " \\param data     The buffer holding one block of data. This"]
    #[doc = "                 must be a readable buffer of length \\c 128 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_internal_sha512_process"]
    pub fn internal_sha512_process(
        ctx: *mut sha512_context,
        data: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-384 or SHA-512 checksum"]
    #[doc = "                 calculation."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha512_starts_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context to use. This must be initialized."]
    #[doc = " \\param is384    Determines which function to use. This must be either"]
    #[doc = "                 \\c 0 for SHA-512 or \\c 1 for SHA-384."]
    #[doc = ""]
    #[doc = " \\note           When \\c MBEDTLS_SHA512_NO_SHA384 is defined, \\p is384 must"]
    #[doc = "                 be \\c 0, or the function will fail to work."]
    #[link_name = "\u{1}mbedtls_sha512_starts"]
    pub fn sha512_starts(ctx: *mut sha512_context, is384: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing"]
    #[doc = "                 SHA-512 checksum calculation."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha512_update_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param input    The buffer holding the data. This must be a readable"]
    #[doc = "                 buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[link_name = "\u{1}mbedtls_sha512_update"]
    pub fn sha512_update(
        ctx: *mut sha512_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-512 operation, and writes"]
    #[doc = "                 the result to the output buffer."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha512_finish_ret() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context. This must be initialized"]
    #[doc = "                 and have a hash operation started."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result. This must"]
    #[doc = "                 be a writable buffer of size \\c 64 Bytes."]
    #[link_name = "\u{1}mbedtls_sha512_finish"]
    pub fn sha512_finish(ctx: *mut sha512_context, output: *mut crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within"]
    #[doc = "                 the ongoing SHA-512 computation. This function is for"]
    #[doc = "                 internal use only."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_internal_sha512_process() in 2.7.0."]
    #[doc = ""]
    #[doc = " \\param ctx      The SHA-512 context. This must be initialized."]
    #[doc = " \\param data     The buffer holding one block of data. This must be"]
    #[doc = "                 a readable buffer of length \\c 128 Bytes."]
    #[link_name = "\u{1}mbedtls_sha512_process"]
    pub fn sha512_process(ctx: *mut sha512_context, data: *const crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-512 or SHA-384"]
    #[doc = "                 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-512 result is calculated as"]
    #[doc = "                 output = SHA-512(input buffer)."]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the input data. This must be"]
    #[doc = "                 a readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result."]
    #[doc = "                 This must be a writable buffer of length \\c 64 Bytes."]
    #[doc = " \\param is384    Determines which function to use. This must be either"]
    #[doc = "                 \\c 0 for SHA-512, or \\c 1 for SHA-384."]
    #[doc = ""]
    #[doc = " \\note           When \\c MBEDTLS_SHA512_NO_SHA384 is defined, \\p is384 must"]
    #[doc = "                 be \\c 0, or the function will return"]
    #[doc = "                 #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_sha512_ret"]
    pub fn sha512_ret(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        is384: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-512 or SHA-384"]
    #[doc = "                 checksum of a buffer."]
    #[doc = ""]
    #[doc = "                 The function allocates the context, performs the"]
    #[doc = "                 calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                 The SHA-512 result is calculated as"]
    #[doc = "                 output = SHA-512(input buffer)."]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_sha512_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param input    The buffer holding the data. This must be a"]
    #[doc = "                 readable buffer of length \\p ilen Bytes."]
    #[doc = " \\param ilen     The length of the input data in Bytes."]
    #[doc = " \\param output   The SHA-384 or SHA-512 checksum result. This must"]
    #[doc = "                 be a writable buffer of length \\c 64 Bytes."]
    #[doc = " \\param is384    Determines which function to use. This must be either"]
    #[doc = "                 \\c 0 for SHA-512, or \\c 1 for SHA-384."]
    #[doc = ""]
    #[doc = " \\note           When \\c MBEDTLS_SHA512_NO_SHA384 is defined, \\p is384 must"]
    #[doc = "                 be \\c 0, or the function will fail to work."]
    #[link_name = "\u{1}mbedtls_sha512"]
    pub fn sha512(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
        is384: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          The SHA-384 or SHA-512 checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_sha512_self_test"]
    pub fn sha512_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_sig_hash_set_t {
    pub rsa: md_type_t,
    pub ecdsa: md_type_t,
}
#[test]
fn bindgen_test_layout_ssl_sig_hash_set_t() {
    assert_eq!(
        ::core::mem::size_of::<ssl_sig_hash_set_t>(),
        8usize,
        concat!("Size of: ", stringify!(ssl_sig_hash_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_sig_hash_set_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_sig_hash_set_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_sig_hash_set_t>())).rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_sig_hash_set_t),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_sig_hash_set_t>())).ecdsa as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_sig_hash_set_t),
            "::",
            stringify!(ecdsa)
        )
    );
}
impl Default for ssl_sig_hash_set_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ssl_tls_prf_cb = ::core::option::Option<
    unsafe extern "C" fn(
        secret: *const crate::types::c_uchar,
        slen: usize,
        label: *const crate::types::c_char,
        random: *const crate::types::c_uchar,
        rlen: usize,
        dstbuf: *mut crate::types::c_uchar,
        dlen: usize,
    ) -> crate::types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_handshake_params {
    #[doc = "<  Set of suitable sig-hash pairs"]
    pub hash_algs: ssl_sig_hash_set_t,
    #[doc = "<  DHM key exchange"]
    pub dhm_ctx: dhm_context,
    #[doc = "<  ECDH key exchange"]
    pub ecdh_ctx: ecdh_context,
    #[doc = "<  Supported elliptic curves"]
    pub curves: *mut *const ecp_curve_info,
    #[doc = "<  PSK from the callback"]
    pub psk: *mut crate::types::c_uchar,
    #[doc = "<  Length of PSK from callback"]
    pub psk_len: usize,
    #[doc = "< chosen key/cert pair (server)"]
    pub key_cert: *mut ssl_key_cert,
    #[doc = "< authmode from SNI callback"]
    pub sni_authmode: crate::types::c_int,
    #[doc = "< key/cert list from SNI"]
    pub sni_key_cert: *mut ssl_key_cert,
    #[doc = "< trusted CAs from SNI callback"]
    pub sni_ca_chain: *mut x509_crt,
    #[doc = "< trusted CAs CRLs from SNI"]
    pub sni_ca_crl: *mut x509_crl,
    #[doc = "<  Outgoing handshake sequence number"]
    pub out_msg_seq: crate::types::c_uint,
    #[doc = "<  Incoming handshake sequence number"]
    pub in_msg_seq: crate::types::c_uint,
    #[doc = "<  Cli: HelloVerifyRequest cookie"]
    #[doc = "Srv: unused"]
    pub verify_cookie: *mut crate::types::c_uchar,
    #[doc = "<  Cli: cookie length"]
    #[doc = "Srv: flag for sending a cookie"]
    pub verify_cookie_len: crate::types::c_uchar,
    #[doc = "<  Current value of timeout"]
    pub retransmit_timeout: u32,
    #[doc = "<  Retransmission state"]
    pub retransmit_state: crate::types::c_uchar,
    #[doc = "<  Current outgoing flight"]
    pub flight: *mut ssl_flight_item,
    #[doc = "<  Current message in flight"]
    pub cur_msg: *mut ssl_flight_item,
    #[doc = "<  Position in current message"]
    pub cur_msg_p: *mut crate::types::c_uchar,
    #[doc = "<  Minimum message sequence in the"]
    #[doc = "flight being received"]
    pub in_flight_start_seq: crate::types::c_uint,
    #[doc = "<  Alternative transform for"]
    #[doc = "resending messages"]
    pub alt_transform_out: *mut ssl_transform,
    #[doc = "<  Alternative record epoch/counter"]
    #[doc = "for resending messages"]
    pub alt_out_ctr: [crate::types::c_uchar; 8usize],
    pub buffering: ssl_handshake_params__bindgen_ty_1,
    #[doc = "<  Handshake mtu, used to fragment outgoing messages"]
    pub mtu: u16,
    pub fin_md5: md5_context,
    pub fin_sha1: sha1_context,
    pub fin_sha256: sha256_context,
    pub fin_sha512: sha512_context,
    pub update_checksum: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ssl_context,
            arg2: *const crate::types::c_uchar,
            arg3: usize,
        ),
    >,
    pub calc_verify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ssl_context,
            arg2: *mut crate::types::c_uchar,
            arg3: *mut usize,
        ),
    >,
    pub calc_finished: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ssl_context,
            arg2: *mut crate::types::c_uchar,
            arg3: crate::types::c_int,
        ),
    >,
    pub tls_prf: ssl_tls_prf_cb,
    pub ciphersuite_info: *const ssl_ciphersuite_t,
    #[doc = "<  premaster length"]
    pub pmslen: usize,
    #[doc = "<  random bytes"]
    pub randbytes: [crate::types::c_uchar; 64usize],
    pub premaster: [crate::types::c_uchar; 292usize],
    #[doc = "<  session resume indicator"]
    pub resume: crate::types::c_int,
    #[doc = "< max. major version client"]
    pub max_major_ver: crate::types::c_int,
    #[doc = "< max. minor version client"]
    pub max_minor_ver: crate::types::c_int,
    #[doc = "< client extension presence"]
    pub cli_exts: crate::types::c_int,
    #[doc = "< use NewSessionTicket?"]
    pub new_session_ticket: crate::types::c_int,
    #[doc = "< use Extended Master Secret?"]
    pub extended_ms: crate::types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_handshake_params__bindgen_ty_1 {
    #[doc = "< Cumulative size of heap allocated"]
    #[doc = "   buffers used for message buffering."]
    pub total_bytes_buffered: usize,
    #[doc = "< Indicates if a CCS message has"]
    #[doc = "   been seen in the current flight."]
    pub seen_ccs: u8,
    pub hs: [ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer; 4usize],
    pub future_record: ssl_handshake_params__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub data: *mut crate::types::c_uchar,
    pub data_len: usize,
}
#[test]
fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer() {
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>()))
                .data as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>()))
                .data_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer),
            "::",
            stringify!(data_len)
        )
    );
}
impl Default for ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer {
    #[inline]
    pub fn is_valid(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_valid(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_fragmented(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_fragmented(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_complete(&self) -> crate::types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_complete(&mut self, val: crate::types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_valid: crate::types::c_uint,
        is_fragmented: crate::types::c_uint,
        is_complete: crate::types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_valid: u32 = unsafe { ::core::mem::transmute(is_valid) };
            is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_fragmented: u32 = unsafe { ::core::mem::transmute(is_fragmented) };
            is_fragmented as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_complete: u32 = unsafe { ::core::mem::transmute(is_complete) };
            is_complete as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 {
    pub data: *mut crate::types::c_uchar,
    pub len: usize,
    pub epoch: crate::types::c_uint,
}
#[test]
fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>())).len
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>())).epoch
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(epoch)
        )
    );
}
impl Default for ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params__bindgen_ty_1>(),
        68usize,
        concat!("Size of: ", stringify!(ssl_handshake_params__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ssl_handshake_params__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1>())).total_bytes_buffered
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(total_bytes_buffered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1>())).seen_ccs as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(seen_ccs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1>())).hs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(hs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1>())).future_record
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(future_record)
        )
    );
}
impl Default for ssl_handshake_params__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ssl_handshake_params() {
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params>(),
        1512usize,
        concat!("Size of: ", stringify!(ssl_handshake_params))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_handshake_params))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).hash_algs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(hash_algs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).dhm_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(dhm_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).ecdh_ctx as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(ecdh_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).curves as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(curves)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).psk as *const _ as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(psk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).psk_len as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(psk_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).key_cert as *const _ as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(key_cert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).sni_authmode as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_authmode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).sni_key_cert as *const _ as usize
        },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_key_cert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).sni_ca_chain as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_ca_chain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).sni_ca_crl as *const _ as usize
        },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_ca_crl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).out_msg_seq as *const _ as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(out_msg_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).in_msg_seq as *const _ as usize
        },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(in_msg_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).verify_cookie as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(verify_cookie)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).verify_cookie_len as *const _ as usize
        },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(verify_cookie_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).retransmit_timeout as *const _
                as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(retransmit_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).retransmit_state as *const _ as usize
        },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(retransmit_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).flight as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(flight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).cur_msg as *const _ as usize },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(cur_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).cur_msg_p as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(cur_msg_p)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).in_flight_start_seq as *const _
                as usize
        },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(in_flight_start_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).alt_transform_out as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(alt_transform_out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).alt_out_ctr as *const _ as usize
        },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(alt_out_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).buffering as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(buffering)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).mtu as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).fin_md5 as *const _ as usize },
        596usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_md5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).fin_sha1 as *const _ as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_sha1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).fin_sha256 as *const _ as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_sha256)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).fin_sha512 as *const _ as usize
        },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_sha512)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).update_checksum as *const _ as usize
        },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(update_checksum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).calc_verify as *const _ as usize
        },
        1108usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(calc_verify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).calc_finished as *const _ as usize
        },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(calc_finished)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).tls_prf as *const _ as usize },
        1116usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(tls_prf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).ciphersuite_info as *const _ as usize
        },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(ciphersuite_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).pmslen as *const _ as usize },
        1124usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(pmslen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).randbytes as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(randbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).premaster as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(premaster)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).resume as *const _ as usize },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(resume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).max_major_ver as *const _ as usize
        },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(max_major_ver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).max_minor_ver as *const _ as usize
        },
        1492usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(max_minor_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).cli_exts as *const _ as usize },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(cli_exts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).new_session_ticket as *const _
                as usize
        },
        1500usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(new_session_ticket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).extended_ms as *const _ as usize
        },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(extended_ms)
        )
    );
}
impl Default for ssl_handshake_params {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type ssl_hs_buffer = ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_transform {
    #[doc = "<  min. ciphertext length"]
    pub minlen: usize,
    #[doc = "<  IV length"]
    pub ivlen: usize,
    #[doc = "<  Fixed part of IV (AEAD)"]
    pub fixed_ivlen: usize,
    #[doc = "<  MAC(CBC) len"]
    pub maclen: usize,
    #[doc = "<  TAG(AEAD) len"]
    pub taglen: usize,
    #[doc = "<  IV (encryption)"]
    pub iv_enc: [crate::types::c_uchar; 16usize],
    #[doc = "<  IV (decryption)"]
    pub iv_dec: [crate::types::c_uchar; 16usize],
    #[doc = "<  MAC (encryption)"]
    pub md_ctx_enc: md_context_t,
    #[doc = "<  MAC (decryption)"]
    pub md_ctx_dec: md_context_t,
    #[doc = "< flag for EtM activation"]
    pub encrypt_then_mac: crate::types::c_int,
    #[doc = "<  encryption context"]
    pub cipher_ctx_enc: cipher_context_t,
    #[doc = "<  decryption context"]
    pub cipher_ctx_dec: cipher_context_t,
    pub minor_ver: crate::types::c_int,
    #[doc = "< ServerHello.random+ClientHello.random"]
    pub randbytes: [crate::types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_ssl_transform() {
    assert_eq!(
        ::core::mem::size_of::<ssl_transform>(),
        276usize,
        concat!("Size of: ", stringify!(ssl_transform))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_transform>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_transform))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).minlen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(minlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).ivlen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(ivlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).fixed_ivlen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(fixed_ivlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).maclen as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(maclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).taglen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(taglen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).iv_enc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(iv_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).iv_dec as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(iv_dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).md_ctx_enc as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(md_ctx_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).md_ctx_dec as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(md_ctx_dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).encrypt_then_mac as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(encrypt_then_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).cipher_ctx_enc as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(cipher_ctx_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).cipher_ctx_dec as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(cipher_ctx_dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).minor_ver as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(minor_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).randbytes as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(randbytes)
        )
    );
}
impl Default for ssl_transform {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct record {
    pub ctr: [u8; 8usize],
    pub type_: u8,
    pub ver: [u8; 2usize],
    pub buf: *mut crate::types::c_uchar,
    pub buf_len: usize,
    pub data_offset: usize,
    pub data_len: usize,
}
#[test]
fn bindgen_test_layout_record() {
    assert_eq!(
        ::core::mem::size_of::<record>(),
        28usize,
        concat!("Size of: ", stringify!(record))
    );
    assert_eq!(
        ::core::mem::align_of::<record>(),
        4usize,
        concat!("Alignment of ", stringify!(record))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<record>())).ctr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<record>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<record>())).ver as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<record>())).buf as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<record>())).buf_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(buf_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<record>())).data_offset as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<record>())).data_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(record),
            "::",
            stringify!(data_len)
        )
    );
}
impl Default for record {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_key_cert {
    #[doc = "< cert"]
    pub cert: *mut x509_crt,
    #[doc = "< private key"]
    pub key: *mut pk_context,
    #[doc = "< next key/cert pair"]
    pub next: *mut ssl_key_cert,
}
#[test]
fn bindgen_test_layout_ssl_key_cert() {
    assert_eq!(
        ::core::mem::size_of::<ssl_key_cert>(),
        12usize,
        concat!("Size of: ", stringify!(ssl_key_cert))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_key_cert>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_key_cert))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_key_cert>())).cert as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_cert),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_key_cert>())).key as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_cert),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_key_cert>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_cert),
            "::",
            stringify!(next)
        )
    );
}
impl Default for ssl_key_cert {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_flight_item {
    #[doc = "< message, including handshake headers"]
    pub p: *mut crate::types::c_uchar,
    #[doc = "< length of p"]
    pub len: usize,
    #[doc = "< type of the message: handshake or CCS"]
    pub type_: crate::types::c_uchar,
    #[doc = "< next handshake message(s)"]
    pub next: *mut ssl_flight_item,
}
#[test]
fn bindgen_test_layout_ssl_flight_item() {
    assert_eq!(
        ::core::mem::size_of::<ssl_flight_item>(),
        16usize,
        concat!("Size of: ", stringify!(ssl_flight_item))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_flight_item>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_flight_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_flight_item>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_flight_item>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_flight_item>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_flight_item>())).next as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(next)
        )
    );
}
impl Default for ssl_flight_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_hash_set_find"]
    pub fn ssl_sig_hash_set_find(set: *mut ssl_sig_hash_set_t, sig_alg: pk_type_t) -> md_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_hash_set_add"]
    pub fn ssl_sig_hash_set_add(
        set: *mut ssl_sig_hash_set_t,
        sig_alg: pk_type_t,
        md_alg: md_type_t,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_hash_set_const_hash"]
    pub fn ssl_sig_hash_set_const_hash(set: *mut ssl_sig_hash_set_t, md_alg: md_type_t);
}
extern "C" {
    #[doc = " \\brief           Free referenced items in an SSL transform context and clear"]
    #[doc = "                  memory"]
    #[doc = ""]
    #[doc = " \\param transform SSL transform context"]
    #[link_name = "\u{1}mbedtls_ssl_transform_free"]
    pub fn ssl_transform_free(transform: *mut ssl_transform);
}
extern "C" {
    #[doc = " \\brief           Free referenced items in an SSL handshake context and clear"]
    #[doc = "                  memory"]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[link_name = "\u{1}mbedtls_ssl_handshake_free"]
    pub fn ssl_handshake_free(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handshake_client_step"]
    pub fn ssl_handshake_client_step(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handshake_server_step"]
    pub fn ssl_handshake_server_step(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handshake_wrapup"]
    pub fn ssl_handshake_wrapup(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_send_fatal_handshake_failure"]
    pub fn ssl_send_fatal_handshake_failure(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_reset_checksum"]
    pub fn ssl_reset_checksum(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_derive_keys"]
    pub fn ssl_derive_keys(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handle_message_type"]
    pub fn ssl_handle_message_type(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_prepare_handshake_record"]
    pub fn ssl_prepare_handshake_record(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_update_handshake_status"]
    pub fn ssl_update_handshake_status(ssl: *mut ssl_context);
}
extern "C" {
    #[doc = " \\brief       Update record layer"]
    #[doc = ""]
    #[doc = "              This function roughly separates the implementation"]
    #[doc = "              of the logic of (D)TLS from the implementation"]
    #[doc = "              of the secure transport."]
    #[doc = ""]
    #[doc = " \\param  ssl              The SSL context to use."]
    #[doc = " \\param  update_hs_digest This indicates if the handshake digest"]
    #[doc = "                          should be automatically updated in case"]
    #[doc = "                          a handshake message is found."]
    #[doc = ""]
    #[doc = " \\return      0 or non-zero error code."]
    #[doc = ""]
    #[doc = " \\note        A clarification on what is called 'record layer' here"]
    #[doc = "              is in order, as many sensible definitions are possible:"]
    #[doc = ""]
    #[doc = "              The record layer takes as input an untrusted underlying"]
    #[doc = "              transport (stream or datagram) and transforms it into"]
    #[doc = "              a serially multiplexed, secure transport, which"]
    #[doc = "              conceptually provides the following:"]
    #[doc = ""]
    #[doc = "              (1) Three datagram based, content-agnostic transports"]
    #[doc = "                  for handshake, alert and CCS messages."]
    #[doc = "              (2) One stream- or datagram-based transport"]
    #[doc = "                  for application data."]
    #[doc = "              (3) Functionality for changing the underlying transform"]
    #[doc = "                  securing the contents."]
    #[doc = ""]
    #[doc = "              The interface to this functionality is given as follows:"]
    #[doc = ""]
    #[doc = "              a Updating"]
    #[doc = "                [Currently implemented by mbedtls_ssl_read_record]"]
    #[doc = ""]
    #[doc = "                Check if and on which of the four 'ports' data is pending:"]
    #[doc = "                Nothing, a controlling datagram of type (1), or application"]
    #[doc = "                data (2). In any case data is present, internal buffers"]
    #[doc = "                provide access to the data for the user to process it."]
    #[doc = "                Consumption of type (1) datagrams is done automatically"]
    #[doc = "                on the next update, invalidating that the internal buffers"]
    #[doc = "                for previous datagrams, while consumption of application"]
    #[doc = "                data (2) is user-controlled."]
    #[doc = ""]
    #[doc = "              b Reading of application data"]
    #[doc = "                [Currently manual adaption of ssl->in_offt pointer]"]
    #[doc = ""]
    #[doc = "                As mentioned in the last paragraph, consumption of data"]
    #[doc = "                is different from the automatic consumption of control"]
    #[doc = "                datagrams (1) because application data is treated as a stream."]
    #[doc = ""]
    #[doc = "              c Tracking availability of application data"]
    #[doc = "                [Currently manually through decreasing ssl->in_msglen]"]
    #[doc = ""]
    #[doc = "                For efficiency and to retain datagram semantics for"]
    #[doc = "                application data in case of DTLS, the record layer"]
    #[doc = "                provides functionality for checking how much application"]
    #[doc = "                data is still available in the internal buffer."]
    #[doc = ""]
    #[doc = "              d Changing the transformation securing the communication."]
    #[doc = ""]
    #[doc = "              Given an opaque implementation of the record layer in the"]
    #[doc = "              above sense, it should be possible to implement the logic"]
    #[doc = "              of (D)TLS on top of it without the need to know anything"]
    #[doc = "              about the record layer's internals. This is done e.g."]
    #[doc = "              in all the handshake handling functions, and in the"]
    #[doc = "              application data reading function mbedtls_ssl_read."]
    #[doc = ""]
    #[doc = " \\note        The above tries to give a conceptual picture of the"]
    #[doc = "              record layer, but the current implementation deviates"]
    #[doc = "              from it in some places. For example, our implementation of"]
    #[doc = "              the update functionality through mbedtls_ssl_read_record"]
    #[doc = "              discards datagrams depending on the current state, which"]
    #[doc = "              wouldn't fall under the record layer's responsibility"]
    #[doc = "              following the above definition."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_ssl_read_record"]
    pub fn ssl_read_record(
        ssl: *mut ssl_context,
        update_hs_digest: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_fetch_input"]
    pub fn ssl_fetch_input(ssl: *mut ssl_context, nb_want: usize) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_write_handshake_msg"]
    pub fn ssl_write_handshake_msg(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_write_record"]
    pub fn ssl_write_record(ssl: *mut ssl_context, force_flush: u8) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_flush_output"]
    pub fn ssl_flush_output(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_parse_certificate"]
    pub fn ssl_parse_certificate(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_write_certificate"]
    pub fn ssl_write_certificate(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_parse_change_cipher_spec"]
    pub fn ssl_parse_change_cipher_spec(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_write_change_cipher_spec"]
    pub fn ssl_write_change_cipher_spec(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_parse_finished"]
    pub fn ssl_parse_finished(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_write_finished"]
    pub fn ssl_write_finished(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_optimize_checksum"]
    pub fn ssl_optimize_checksum(ssl: *mut ssl_context, ciphersuite_info: *const ssl_ciphersuite_t);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_psk_derive_premaster"]
    pub fn ssl_psk_derive_premaster(
        ssl: *mut ssl_context,
        key_ex: key_exchange_type_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_from_pk"]
    pub fn ssl_sig_from_pk(pk: *mut pk_context) -> crate::types::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_sig_from_pk_alg"]
    pub fn ssl_sig_from_pk_alg(type_: pk_type_t) -> crate::types::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_pk_alg_from_sig"]
    pub fn ssl_pk_alg_from_sig(sig: crate::types::c_uchar) -> pk_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_md_alg_from_hash"]
    pub fn ssl_md_alg_from_hash(hash: crate::types::c_uchar) -> md_type_t;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_hash_from_md_alg"]
    pub fn ssl_hash_from_md_alg(md: crate::types::c_int) -> crate::types::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_calc_verify_md"]
    pub fn ssl_set_calc_verify_md(
        ssl: *mut ssl_context,
        md: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_check_curve"]
    pub fn ssl_check_curve(ssl: *const ssl_context, grp_id: ecp_group_id) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_check_sig_hash"]
    pub fn ssl_check_sig_hash(ssl: *const ssl_context, md: md_type_t) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_check_cert_usage"]
    pub fn ssl_check_cert_usage(
        cert: *const x509_crt,
        ciphersuite: *const ssl_ciphersuite_t,
        cert_endpoint: crate::types::c_int,
        flags: *mut u32,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_write_version"]
    pub fn ssl_write_version(
        major: crate::types::c_int,
        minor: crate::types::c_int,
        transport: crate::types::c_int,
        ver: *mut crate::types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_read_version"]
    pub fn ssl_read_version(
        major: *mut crate::types::c_int,
        minor: *mut crate::types::c_int,
        transport: crate::types::c_int,
        ver: *const crate::types::c_uchar,
    );
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_send_flight_completed"]
    pub fn ssl_send_flight_completed(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_recv_flight_completed"]
    pub fn ssl_recv_flight_completed(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_resend"]
    pub fn ssl_resend(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_flight_transmit"]
    pub fn ssl_flight_transmit(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_dtls_replay_check"]
    pub fn ssl_dtls_replay_check(ssl: *const ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_dtls_replay_update"]
    pub fn ssl_dtls_replay_update(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_session_copy"]
    pub fn ssl_session_copy(dst: *mut ssl_session, src: *const ssl_session) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_key_exchange_md_ssl_tls"]
    pub fn ssl_get_key_exchange_md_ssl_tls(
        ssl: *mut ssl_context,
        output: *mut crate::types::c_uchar,
        data: *mut crate::types::c_uchar,
        data_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_key_exchange_md_tls1_2"]
    pub fn ssl_get_key_exchange_md_tls1_2(
        ssl: *mut ssl_context,
        hash: *mut crate::types::c_uchar,
        hashlen: *mut usize,
        data: *mut crate::types::c_uchar,
        data_len: usize,
        md_alg: md_type_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_transform_init"]
    pub fn ssl_transform_init(transform: *mut ssl_transform);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_encrypt_buf"]
    pub fn ssl_encrypt_buf(
        ssl: *mut ssl_context,
        transform: *mut ssl_transform,
        rec: *mut record,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_decrypt_buf"]
    pub fn ssl_decrypt_buf(
        ssl: *const ssl_context,
        transform: *mut ssl_transform,
        rec: *mut record,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_resend_hello_request"]
    pub fn ssl_resend_hello_request(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_set_timer"]
    pub fn ssl_set_timer(ssl: *mut ssl_context, millisecs: u32);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_check_timer"]
    pub fn ssl_check_timer(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_reset_in_out_pointers"]
    pub fn ssl_reset_in_out_pointers(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_update_out_pointers"]
    pub fn ssl_update_out_pointers(ssl: *mut ssl_context, transform: *mut ssl_transform);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_update_in_pointers"]
    pub fn ssl_update_in_pointers(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_session_reset_int"]
    pub fn ssl_session_reset_int(
        ssl: *mut ssl_context,
        partial: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_dtls_replay_reset"]
    pub fn ssl_dtls_replay_reset(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_handshake_wrapup_free_hs_transform"]
    pub fn ssl_handshake_wrapup_free_hs_transform(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_start_renegotiation"]
    pub fn ssl_start_renegotiation(ssl: *mut ssl_context) -> crate::types::c_int;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_get_current_mtu"]
    pub fn ssl_get_current_mtu(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_buffering_free"]
    pub fn ssl_buffering_free(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "\u{1}mbedtls_ssl_flight_free"]
    pub fn ssl_flight_free(flight: *mut ssl_flight_item);
}
#[doc = " \\brief   Information for session ticket protection"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ticket_key {
    #[doc = "< random key identifier"]
    pub name: [crate::types::c_uchar; 4usize],
    #[doc = "< key generation timestamp (seconds)"]
    pub generation_time: u32,
    #[doc = "< context for auth enc/decryption"]
    pub ctx: cipher_context_t,
}
#[test]
fn bindgen_test_layout_ssl_ticket_key() {
    assert_eq!(
        ::core::mem::size_of::<ssl_ticket_key>(),
        72usize,
        concat!("Size of: ", stringify!(ssl_ticket_key))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_ticket_key>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_ticket_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_key>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_key),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_key>())).generation_time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_key),
            "::",
            stringify!(generation_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_key>())).ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_key),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for ssl_ticket_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " \\brief   Context for session ticket handling functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ssl_ticket_context {
    #[doc = "< ticket protection keys"]
    pub keys: [ssl_ticket_key; 2usize],
    #[doc = "< index of the currently active key"]
    pub active: crate::types::c_uchar,
    #[doc = "< lifetime of tickets in seconds"]
    pub ticket_lifetime: u32,
    #[doc = " Callback for getting (pseudo-)random numbers"]
    pub f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut crate::types::c_uchar,
            arg3: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for the RNG function"]
    pub p_rng: *mut crate::types::c_void,
}
#[test]
fn bindgen_test_layout_ssl_ticket_context() {
    assert_eq!(
        ::core::mem::size_of::<ssl_ticket_context>(),
        160usize,
        concat!("Size of: ", stringify!(ssl_ticket_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_ticket_context>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_ticket_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_context>())).keys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_context>())).active as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ticket_context>())).ticket_lifetime as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(ticket_lifetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_context>())).f_rng as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(f_rng)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_context>())).p_rng as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(p_rng)
        )
    );
}
impl Default for ssl_ticket_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           Initialize a ticket context."]
    #[doc = "                  (Just make it ready for mbedtls_ssl_ticket_setup()"]
    #[doc = "                  or mbedtls_ssl_ticket_free().)"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to be initialized"]
    #[link_name = "\u{1}mbedtls_ssl_ticket_init"]
    pub fn ssl_ticket_init(ctx: *mut ssl_ticket_context);
}
extern "C" {
    #[doc = " \\brief           Prepare context to be actually used"]
    #[doc = ""]
    #[doc = " \\param ctx       Context to be set up"]
    #[doc = " \\param f_rng     RNG callback function"]
    #[doc = " \\param p_rng     RNG callback context"]
    #[doc = " \\param cipher    AEAD cipher to use for ticket protection."]
    #[doc = "                  Recommended value: MBEDTLS_CIPHER_AES_256_GCM."]
    #[doc = " \\param lifetime  Tickets lifetime in seconds"]
    #[doc = "                  Recommended value: 86400 (one day)."]
    #[doc = ""]
    #[doc = " \\note            It is highly recommended to select a cipher that is at"]
    #[doc = "                  least as strong as the the strongest ciphersuite"]
    #[doc = "                  supported. Usually that means a 256-bit key."]
    #[doc = ""]
    #[doc = " \\note            The lifetime of the keys is twice the lifetime of tickets."]
    #[doc = "                  It is recommended to pick a reasonnable lifetime so as not"]
    #[doc = "                  to negate the benefits of forward secrecy."]
    #[doc = ""]
    #[doc = " \\return          0 if successful,"]
    #[doc = "                  or a specific MBEDTLS_ERR_XXX error code"]
    #[link_name = "\u{1}mbedtls_ssl_ticket_setup"]
    pub fn ssl_ticket_setup(
        ctx: *mut ssl_ticket_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
        cipher: cipher_type_t,
        lifetime: u32,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Implementation of the ticket write callback"]
    #[doc = ""]
    #[doc = " \\note            See \\c mbedtls_ssl_ticket_write_t for description"]
    #[link_name = "\u{1}mbedtls_ssl_ticket_write"]
    pub fn ssl_ticket_write(
        p_ticket: *mut crate::types::c_void,
        session: *const ssl_session,
        start: *mut crate::types::c_uchar,
        end: *const crate::types::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Implementation of the ticket parse callback"]
    #[doc = ""]
    #[doc = " \\note            See \\c mbedtls_ssl_ticket_parse_t for description"]
    #[link_name = "\u{1}mbedtls_ssl_ticket_parse"]
    pub fn ssl_ticket_parse(
        p_ticket: *mut crate::types::c_void,
        session: *mut ssl_session,
        buf: *mut crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Free a context's content and zeroize it."]
    #[doc = ""]
    #[doc = " \\param ctx       Context to be cleaned up"]
    #[link_name = "\u{1}mbedtls_ssl_ticket_free"]
    pub fn ssl_ticket_free(ctx: *mut ssl_ticket_context);
}
#[doc = " HMAC_DRBG context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hmac_drbg_context {
    #[doc = "< HMAC context (inc. K)"]
    pub md_ctx: md_context_t,
    #[doc = "< V in the spec"]
    pub V: [crate::types::c_uchar; 64usize],
    #[doc = "< reseed counter"]
    pub reseed_counter: crate::types::c_int,
    #[doc = "< entropy bytes grabbed on each (re)seed"]
    pub entropy_len: usize,
    #[doc = "< enable prediction resistance (Automatic"]
    #[doc = "reseed before every random generation)"]
    pub prediction_resistance: crate::types::c_int,
    #[doc = "< reseed interval"]
    pub reseed_interval: crate::types::c_int,
    #[doc = "< entropy function"]
    pub f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut crate::types::c_uchar,
            arg3: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = "< context for the entropy function"]
    pub p_entropy: *mut crate::types::c_void,
}
#[test]
fn bindgen_test_layout_hmac_drbg_context() {
    assert_eq!(
        ::core::mem::size_of::<hmac_drbg_context>(),
        100usize,
        concat!("Size of: ", stringify!(hmac_drbg_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hmac_drbg_context>(),
        4usize,
        concat!("Alignment of ", stringify!(hmac_drbg_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).md_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(md_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).V as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(V)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hmac_drbg_context>())).reseed_counter as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(reseed_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).entropy_len as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(entropy_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hmac_drbg_context>())).prediction_resistance as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(prediction_resistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hmac_drbg_context>())).reseed_interval as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(reseed_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).f_entropy as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(f_entropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).p_entropy as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(p_entropy)
        )
    );
}
impl Default for hmac_drbg_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief               HMAC_DRBG context initialization."]
    #[doc = ""]
    #[doc = " This function makes the context ready for mbedtls_hmac_drbg_seed(),"]
    #[doc = " mbedtls_hmac_drbg_seed_buf() or mbedtls_hmac_drbg_free()."]
    #[doc = ""]
    #[doc = " \\param ctx           HMAC_DRBG context to be initialized."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_init"]
    pub fn hmac_drbg_init(ctx: *mut hmac_drbg_context);
}
extern "C" {
    #[doc = " \\brief               HMAC_DRBG initial seeding."]
    #[doc = ""]
    #[doc = " Set the initial seed and set up the entropy source for future reseeds."]
    #[doc = ""]
    #[doc = " A typical choice for the \\p f_entropy and \\p p_entropy parameters is"]
    #[doc = " to use the entropy module:"]
    #[doc = " - \\p f_entropy is mbedtls_entropy_func();"]
    #[doc = " - \\p p_entropy is an instance of ::mbedtls_entropy_context initialized"]
    #[doc = "   with mbedtls_entropy_init() (which registers the platform's default"]
    #[doc = "   entropy sources)."]
    #[doc = ""]
    #[doc = " You can provide a personalization string in addition to the"]
    #[doc = " entropy source, to make this instantiation as unique as possible."]
    #[doc = ""]
    #[doc = " \\note                By default, the security strength as defined by NIST is:"]
    #[doc = "                      - 128 bits if \\p md_info is SHA-1;"]
    #[doc = "                      - 192 bits if \\p md_info is SHA-224;"]
    #[doc = "                      - 256 bits if \\p md_info is SHA-256, SHA-384 or SHA-512."]
    #[doc = "                      Note that SHA-256 is just as efficient as SHA-224."]
    #[doc = "                      The security strength can be reduced if a smaller"]
    #[doc = "                      entropy length is set with"]
    #[doc = "                      mbedtls_hmac_drbg_set_entropy_len()."]
    #[doc = ""]
    #[doc = " \\note                The default entropy length is the security strength"]
    #[doc = "                      (converted from bits to bytes). You can override"]
    #[doc = "                      it by calling mbedtls_hmac_drbg_set_entropy_len()."]
    #[doc = ""]
    #[doc = " \\note                During the initial seeding, this function calls"]
    #[doc = "                      the entropy source to obtain a nonce"]
    #[doc = "                      whose length is half the entropy length."]
    #[doc = ""]
    #[doc = " \\param ctx           HMAC_DRBG context to be seeded."]
    #[doc = " \\param md_info       MD algorithm to use for HMAC_DRBG."]
    #[doc = " \\param f_entropy     The entropy callback, taking as arguments the"]
    #[doc = "                      \\p p_entropy context, the buffer to fill, and the"]
    #[doc = "                      length of the buffer."]
    #[doc = "                      \\p f_entropy is always called with a length that is"]
    #[doc = "                      less than or equal to the entropy length."]
    #[doc = " \\param p_entropy     The entropy context to pass to \\p f_entropy."]
    #[doc = " \\param custom        The personalization string."]
    #[doc = "                      This can be \\c NULL, in which case the personalization"]
    #[doc = "                      string is empty regardless of the value of \\p len."]
    #[doc = " \\param len           The length of the personalization string."]
    #[doc = "                      This must be at most #MBEDTLS_HMAC_DRBG_MAX_INPUT"]
    #[doc = "                      and also at most"]
    #[doc = "                      #MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT - \\p entropy_len * 3 / 2"]
    #[doc = "                      where \\p entropy_len is the entropy length"]
    #[doc = "                      described above."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 if successful."]
    #[doc = " \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA if \\p md_info is"]
    #[doc = "                      invalid."]
    #[doc = " \\return              #MBEDTLS_ERR_MD_ALLOC_FAILED if there was not enough"]
    #[doc = "                      memory to allocate context data."]
    #[doc = " \\return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED"]
    #[doc = "                      if the call to \\p f_entropy failed."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_seed"]
    pub fn hmac_drbg_seed(
        ctx: *mut hmac_drbg_context,
        md_info: *const md_info_t,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_entropy: *mut crate::types::c_void,
        custom: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               Initilisation of simpified HMAC_DRBG (never reseeds)."]
    #[doc = ""]
    #[doc = " This function is meant for use in algorithms that need a pseudorandom"]
    #[doc = " input such as deterministic ECDSA."]
    #[doc = ""]
    #[doc = " \\param ctx           HMAC_DRBG context to be initialised."]
    #[doc = " \\param md_info       MD algorithm to use for HMAC_DRBG."]
    #[doc = " \\param data          Concatenation of the initial entropy string and"]
    #[doc = "                      the additional data."]
    #[doc = " \\param data_len      Length of \\p data in bytes."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 if successful. or"]
    #[doc = " \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA if \\p md_info is"]
    #[doc = "                      invalid."]
    #[doc = " \\return              #MBEDTLS_ERR_MD_ALLOC_FAILED if there was not enough"]
    #[doc = "                      memory to allocate context data."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_seed_buf"]
    pub fn hmac_drbg_seed_buf(
        ctx: *mut hmac_drbg_context,
        md_info: *const md_info_t,
        data: *const crate::types::c_uchar,
        data_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function turns prediction resistance on or off."]
    #[doc = "                      The default value is off."]
    #[doc = ""]
    #[doc = " \\note                If enabled, entropy is gathered at the beginning of"]
    #[doc = "                      every call to mbedtls_hmac_drbg_random_with_add()"]
    #[doc = "                      or mbedtls_hmac_drbg_random()."]
    #[doc = "                      Only use this if your entropy source has sufficient"]
    #[doc = "                      throughput."]
    #[doc = ""]
    #[doc = " \\param ctx           The HMAC_DRBG context."]
    #[doc = " \\param resistance    #MBEDTLS_HMAC_DRBG_PR_ON or #MBEDTLS_HMAC_DRBG_PR_OFF."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_set_prediction_resistance"]
    pub fn hmac_drbg_set_prediction_resistance(
        ctx: *mut hmac_drbg_context,
        resistance: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               This function sets the amount of entropy grabbed on each"]
    #[doc = "                      seed or reseed."]
    #[doc = ""]
    #[doc = " See the documentation of mbedtls_hmac_drbg_seed() for the default value."]
    #[doc = ""]
    #[doc = " \\param ctx           The HMAC_DRBG context."]
    #[doc = " \\param len           The amount of entropy to grab, in bytes."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_set_entropy_len"]
    pub fn hmac_drbg_set_entropy_len(ctx: *mut hmac_drbg_context, len: usize);
}
extern "C" {
    #[doc = " \\brief               Set the reseed interval."]
    #[doc = ""]
    #[doc = " The reseed interval is the number of calls to mbedtls_hmac_drbg_random()"]
    #[doc = " or mbedtls_hmac_drbg_random_with_add() after which the entropy function"]
    #[doc = " is called again."]
    #[doc = ""]
    #[doc = " The default value is #MBEDTLS_HMAC_DRBG_RESEED_INTERVAL."]
    #[doc = ""]
    #[doc = " \\param ctx           The HMAC_DRBG context."]
    #[doc = " \\param interval      The reseed interval."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_set_reseed_interval"]
    pub fn hmac_drbg_set_reseed_interval(
        ctx: *mut hmac_drbg_context,
        interval: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               This function updates the state of the HMAC_DRBG context."]
    #[doc = ""]
    #[doc = " \\param ctx           The HMAC_DRBG context."]
    #[doc = " \\param additional    The data to update the state with."]
    #[doc = "                      If this is \\c NULL, there is no additional data."]
    #[doc = " \\param add_len       Length of \\p additional in bytes."]
    #[doc = "                      Unused if \\p additional is \\c NULL."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success, or an error from the underlying"]
    #[doc = "                      hash calculation."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_update_ret"]
    pub fn hmac_drbg_update_ret(
        ctx: *mut hmac_drbg_context,
        additional: *const crate::types::c_uchar,
        add_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function reseeds the HMAC_DRBG context, that is"]
    #[doc = "                      extracts data from the entropy source."]
    #[doc = ""]
    #[doc = " \\param ctx           The HMAC_DRBG context."]
    #[doc = " \\param additional    Additional data to add to the state."]
    #[doc = "                      If this is \\c NULL, there is no additional data"]
    #[doc = "                      and \\p len should be \\c 0."]
    #[doc = " \\param len           The length of the additional data."]
    #[doc = "                      This must be at most #MBEDTLS_HMAC_DRBG_MAX_INPUT"]
    #[doc = "                      and also at most"]
    #[doc = "                      #MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT - \\p entropy_len"]
    #[doc = "                      where \\p entropy_len is the entropy length"]
    #[doc = "                      (see mbedtls_hmac_drbg_set_entropy_len())."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 if successful."]
    #[doc = " \\return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED"]
    #[doc = "                      if a call to the entropy function failed."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_reseed"]
    pub fn hmac_drbg_reseed(
        ctx: *mut hmac_drbg_context,
        additional: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function updates an HMAC_DRBG instance with additional"]
    #[doc = "          data and uses it to generate random data."]
    #[doc = ""]
    #[doc = " This function automatically reseeds if the reseed counter is exceeded"]
    #[doc = " or prediction resistance is enabled."]
    #[doc = ""]
    #[doc = " \\param p_rng         The HMAC_DRBG context. This must be a pointer to a"]
    #[doc = "                      #mbedtls_hmac_drbg_context structure."]
    #[doc = " \\param output        The buffer to fill."]
    #[doc = " \\param output_len    The length of the buffer in bytes."]
    #[doc = "                      This must be at most #MBEDTLS_HMAC_DRBG_MAX_REQUEST."]
    #[doc = " \\param additional    Additional data to update with."]
    #[doc = "                      If this is \\c NULL, there is no additional data"]
    #[doc = "                      and \\p add_len should be \\c 0."]
    #[doc = " \\param add_len       The length of the additional data."]
    #[doc = "                      This must be at most #MBEDTLS_HMAC_DRBG_MAX_INPUT."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 if successful."]
    #[doc = " \\return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED"]
    #[doc = "                      if a call to the entropy source failed."]
    #[doc = " \\return              #MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG if"]
    #[doc = "                      \\p output_len > #MBEDTLS_HMAC_DRBG_MAX_REQUEST."]
    #[doc = " \\return              #MBEDTLS_ERR_HMAC_DRBG_INPUT_TOO_BIG if"]
    #[doc = "                      \\p add_len > #MBEDTLS_HMAC_DRBG_MAX_INPUT."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_random_with_add"]
    pub fn hmac_drbg_random_with_add(
        p_rng: *mut crate::types::c_void,
        output: *mut crate::types::c_uchar,
        output_len: usize,
        additional: *const crate::types::c_uchar,
        add_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function uses HMAC_DRBG to generate random data."]
    #[doc = ""]
    #[doc = " This function automatically reseeds if the reseed counter is exceeded"]
    #[doc = " or prediction resistance is enabled."]
    #[doc = ""]
    #[doc = " \\param p_rng         The HMAC_DRBG context. This must be a pointer to a"]
    #[doc = "                      #mbedtls_hmac_drbg_context structure."]
    #[doc = " \\param output        The buffer to fill."]
    #[doc = " \\param out_len       The length of the buffer in bytes."]
    #[doc = "                      This must be at most #MBEDTLS_HMAC_DRBG_MAX_REQUEST."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 if successful."]
    #[doc = " \\return              #MBEDTLS_ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED"]
    #[doc = "                      if a call to the entropy source failed."]
    #[doc = " \\return              #MBEDTLS_ERR_HMAC_DRBG_REQUEST_TOO_BIG if"]
    #[doc = "                      \\p out_len > #MBEDTLS_HMAC_DRBG_MAX_REQUEST."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_random"]
    pub fn hmac_drbg_random(
        p_rng: *mut crate::types::c_void,
        output: *mut crate::types::c_uchar,
        out_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               Free an HMAC_DRBG context"]
    #[doc = ""]
    #[doc = " \\param ctx           The HMAC_DRBG context to free."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_free"]
    pub fn hmac_drbg_free(ctx: *mut hmac_drbg_context);
}
extern "C" {
    #[doc = " \\brief               This function updates the state of the HMAC_DRBG context."]
    #[doc = ""]
    #[doc = " \\deprecated          Superseded by mbedtls_hmac_drbg_update_ret()"]
    #[doc = "                      in 2.16.0."]
    #[doc = ""]
    #[doc = " \\param ctx           The HMAC_DRBG context."]
    #[doc = " \\param additional    The data to update the state with."]
    #[doc = "                      If this is \\c NULL, there is no additional data."]
    #[doc = " \\param add_len       Length of \\p additional in bytes."]
    #[doc = "                      Unused if \\p additional is \\c NULL."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_update"]
    pub fn hmac_drbg_update(
        ctx: *mut hmac_drbg_context,
        additional: *const crate::types::c_uchar,
        add_len: usize,
    );
}
extern "C" {
    #[doc = " \\brief               The HMAC_DRBG Checkup routine."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 if successful."]
    #[doc = " \\return              \\c 1 if the test failed."]
    #[link_name = "\u{1}mbedtls_hmac_drbg_self_test"]
    pub fn hmac_drbg_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " Base cipher information. The non-mode specific functions and values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cipher_base_t {
    #[doc = " Base Cipher type (e.g. MBEDTLS_CIPHER_ID_AES)"]
    pub cipher: cipher_id_t,
    #[doc = " Encrypt using ECB"]
    pub ecb_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            mode: operation_t,
            input: *const crate::types::c_uchar,
            output: *mut crate::types::c_uchar,
        ) -> crate::types::c_int,
    >,
    #[doc = " Encrypt using CBC"]
    pub cbc_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            mode: operation_t,
            length: usize,
            iv: *mut crate::types::c_uchar,
            input: *const crate::types::c_uchar,
            output: *mut crate::types::c_uchar,
        ) -> crate::types::c_int,
    >,
    #[doc = " Encrypt using CFB (Full length)"]
    pub cfb_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            mode: operation_t,
            length: usize,
            iv_off: *mut usize,
            iv: *mut crate::types::c_uchar,
            input: *const crate::types::c_uchar,
            output: *mut crate::types::c_uchar,
        ) -> crate::types::c_int,
    >,
    #[doc = " Encrypt using OFB (Full length)"]
    pub ofb_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            length: usize,
            iv_off: *mut usize,
            iv: *mut crate::types::c_uchar,
            input: *const crate::types::c_uchar,
            output: *mut crate::types::c_uchar,
        ) -> crate::types::c_int,
    >,
    #[doc = " Encrypt using CTR"]
    pub ctr_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            length: usize,
            nc_off: *mut usize,
            nonce_counter: *mut crate::types::c_uchar,
            stream_block: *mut crate::types::c_uchar,
            input: *const crate::types::c_uchar,
            output: *mut crate::types::c_uchar,
        ) -> crate::types::c_int,
    >,
    #[doc = " Encrypt or decrypt using XTS."]
    pub xts_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            mode: operation_t,
            length: usize,
            data_unit: *const crate::types::c_uchar,
            input: *const crate::types::c_uchar,
            output: *mut crate::types::c_uchar,
        ) -> crate::types::c_int,
    >,
    #[doc = " Encrypt using STREAM"]
    pub stream_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            length: usize,
            input: *const crate::types::c_uchar,
            output: *mut crate::types::c_uchar,
        ) -> crate::types::c_int,
    >,
    #[doc = " Set key for encryption purposes"]
    pub setkey_enc_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            key: *const crate::types::c_uchar,
            key_bitlen: crate::types::c_uint,
        ) -> crate::types::c_int,
    >,
    #[doc = " Set key for decryption purposes"]
    pub setkey_dec_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut crate::types::c_void,
            key: *const crate::types::c_uchar,
            key_bitlen: crate::types::c_uint,
        ) -> crate::types::c_int,
    >,
    #[doc = " Allocate a new context"]
    pub ctx_alloc_func: ::core::option::Option<unsafe extern "C" fn() -> *mut crate::types::c_void>,
    #[doc = " Free the given context"]
    pub ctx_free_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::types::c_void)>,
}
#[test]
fn bindgen_test_layout_cipher_base_t() {
    assert_eq!(
        ::core::mem::size_of::<cipher_base_t>(),
        48usize,
        concat!("Size of: ", stringify!(cipher_base_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_base_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cipher_base_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).cipher as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ecb_func as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ecb_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).cbc_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(cbc_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).cfb_func as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(cfb_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ofb_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ofb_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ctr_func as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ctr_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).xts_func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(xts_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).stream_func as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(stream_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).setkey_enc_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(setkey_enc_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).setkey_dec_func as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(setkey_dec_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ctx_alloc_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ctx_alloc_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ctx_free_func as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ctx_free_func)
        )
    );
}
impl Default for cipher_base_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cipher_definition_t {
    pub type_: cipher_type_t,
    pub info: *const cipher_info_t,
}
#[test]
fn bindgen_test_layout_cipher_definition_t() {
    assert_eq!(
        ::core::mem::size_of::<cipher_definition_t>(),
        8usize,
        concat!("Size of: ", stringify!(cipher_definition_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_definition_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cipher_definition_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_definition_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_definition_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_definition_t>())).info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_definition_t),
            "::",
            stringify!(info)
        )
    );
}
impl Default for cipher_definition_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_definitions"]
    pub static mut cipher_definitions: [cipher_definition_t; 0usize];
}
extern "C" {
    #[link_name = "\u{1}mbedtls_cipher_supported"]
    pub static mut cipher_supported: [crate::types::c_int; 0usize];
}
#[doc = " \\brief Base OID descriptor structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oid_descriptor_t {
    #[doc = "< OID ASN.1 representation"]
    pub asn1: *const crate::types::c_char,
    #[doc = "< length of asn1"]
    pub asn1_len: usize,
    #[doc = "< official name (e.g. from RFC)"]
    pub name: *const crate::types::c_char,
    #[doc = "< human friendly description"]
    pub description: *const crate::types::c_char,
}
#[test]
fn bindgen_test_layout_oid_descriptor_t() {
    assert_eq!(
        ::core::mem::size_of::<oid_descriptor_t>(),
        16usize,
        concat!("Size of: ", stringify!(oid_descriptor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<oid_descriptor_t>(),
        4usize,
        concat!("Alignment of ", stringify!(oid_descriptor_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<oid_descriptor_t>())).asn1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(asn1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<oid_descriptor_t>())).asn1_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(asn1_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<oid_descriptor_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<oid_descriptor_t>())).description as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(description)
        )
    );
}
impl Default for oid_descriptor_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           Translate an ASN.1 OID into its numeric representation"]
    #[doc = "                  (e.g. \"\\x2A\\x86\\x48\\x86\\xF7\\x0D\" into \"1.2.840.113549\")"]
    #[doc = ""]
    #[doc = " \\param buf       buffer to put representation in"]
    #[doc = " \\param size      size of the buffer"]
    #[doc = " \\param oid       OID to translate"]
    #[doc = ""]
    #[doc = " \\return          Length of the string written (excluding final NULL) or"]
    #[doc = "                  MBEDTLS_ERR_OID_BUF_TOO_SMALL in case of error"]
    #[link_name = "\u{1}mbedtls_oid_get_numeric_string"]
    pub fn oid_get_numeric_string(
        buf: *mut crate::types::c_char,
        size: usize,
        oid: *const asn1_buf,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate an X.509 extension OID into local values"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param ext_type place to store the extension type"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_x509_ext_type"]
    pub fn oid_get_x509_ext_type(
        oid: *const asn1_buf,
        ext_type: *mut crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate an X.509 attribute type OID into the short name"]
    #[doc = "                 (e.g. the OID for an X520 Common Name into \"CN\")"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param short_name    place to store the string pointer"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_attr_short_name"]
    pub fn oid_get_attr_short_name(
        oid: *const asn1_buf,
        short_name: *mut *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate PublicKeyAlgorithm OID into pk_type"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param pk_alg   place to store public key algorithm"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_pk_alg"]
    pub fn oid_get_pk_alg(oid: *const asn1_buf, pk_alg: *mut pk_type_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate pk_type into PublicKeyAlgorithm OID"]
    #[doc = ""]
    #[doc = " \\param pk_alg   Public key type to look for"]
    #[doc = " \\param oid      place to store ASN.1 OID string pointer"]
    #[doc = " \\param olen     length of the OID"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_oid_by_pk_alg"]
    pub fn oid_get_oid_by_pk_alg(
        pk_alg: pk_type_t,
        oid: *mut *const crate::types::c_char,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate NamedCurve OID into an EC group identifier"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param grp_id   place to store group id"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_ec_grp"]
    pub fn oid_get_ec_grp(oid: *const asn1_buf, grp_id: *mut ecp_group_id) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate EC group identifier into NamedCurve OID"]
    #[doc = ""]
    #[doc = " \\param grp_id   EC group identifier"]
    #[doc = " \\param oid      place to store ASN.1 OID string pointer"]
    #[doc = " \\param olen     length of the OID"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_oid_by_ec_grp"]
    pub fn oid_get_oid_by_ec_grp(
        grp_id: ecp_group_id,
        oid: *mut *const crate::types::c_char,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate SignatureAlgorithm OID into md_type and pk_type"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param md_alg   place to store message digest algorithm"]
    #[doc = " \\param pk_alg   place to store public key algorithm"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_sig_alg"]
    pub fn oid_get_sig_alg(
        oid: *const asn1_buf,
        md_alg: *mut md_type_t,
        pk_alg: *mut pk_type_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate SignatureAlgorithm OID into description"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param desc     place to store string pointer"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_sig_alg_desc"]
    pub fn oid_get_sig_alg_desc(
        oid: *const asn1_buf,
        desc: *mut *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate md_type and pk_type into SignatureAlgorithm OID"]
    #[doc = ""]
    #[doc = " \\param md_alg   message digest algorithm"]
    #[doc = " \\param pk_alg   public key algorithm"]
    #[doc = " \\param oid      place to store ASN.1 OID string pointer"]
    #[doc = " \\param olen     length of the OID"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_oid_by_sig_alg"]
    pub fn oid_get_oid_by_sig_alg(
        pk_alg: pk_type_t,
        md_alg: md_type_t,
        oid: *mut *const crate::types::c_char,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate hash algorithm OID into md_type"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param md_alg   place to store message digest algorithm"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_md_alg"]
    pub fn oid_get_md_alg(oid: *const asn1_buf, md_alg: *mut md_type_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate hmac algorithm OID into md_type"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param md_hmac  place to store message hmac algorithm"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_md_hmac"]
    pub fn oid_get_md_hmac(oid: *const asn1_buf, md_hmac: *mut md_type_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate Extended Key Usage OID into description"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param desc     place to store string pointer"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_extended_key_usage"]
    pub fn oid_get_extended_key_usage(
        oid: *const asn1_buf,
        desc: *mut *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate certificate policies OID into description"]
    #[doc = ""]
    #[doc = " \\param oid      OID to use"]
    #[doc = " \\param desc     place to store string pointer"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_certificate_policies"]
    pub fn oid_get_certificate_policies(
        oid: *const asn1_buf,
        desc: *mut *const crate::types::c_char,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate md_type into hash algorithm OID"]
    #[doc = ""]
    #[doc = " \\param md_alg   message digest algorithm"]
    #[doc = " \\param oid      place to store ASN.1 OID string pointer"]
    #[doc = " \\param olen     length of the OID"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_oid_by_md"]
    pub fn oid_get_oid_by_md(
        md_alg: md_type_t,
        oid: *mut *const crate::types::c_char,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate encryption algorithm OID into cipher_type"]
    #[doc = ""]
    #[doc = " \\param oid           OID to use"]
    #[doc = " \\param cipher_alg    place to store cipher algorithm"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_cipher_alg"]
    pub fn oid_get_cipher_alg(
        oid: *const asn1_buf,
        cipher_alg: *mut cipher_type_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Translate PKCS#12 PBE algorithm OID into md_type and"]
    #[doc = "                 cipher_type"]
    #[doc = ""]
    #[doc = " \\param oid           OID to use"]
    #[doc = " \\param md_alg        place to store message digest algorithm"]
    #[doc = " \\param cipher_alg    place to store cipher algorithm"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_OID_NOT_FOUND"]
    #[link_name = "\u{1}mbedtls_oid_get_pkcs12_pbe_alg"]
    pub fn oid_get_pkcs12_pbe_alg(
        oid: *const asn1_buf,
        md_alg: *mut md_type_t,
        cipher_alg: *mut cipher_type_t,
    ) -> crate::types::c_int;
}
#[doc = " \\brief The AES context-type definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aes_context {
    #[doc = "< The number of rounds."]
    pub nr: crate::types::c_int,
    #[doc = "< AES round keys."]
    pub rk: *mut u32,
    #[doc = "< Unaligned data buffer. This buffer can"]
    #[doc = "hold 32 extra Bytes, which can be used for"]
    #[doc = "one of the following purposes:"]
    #[doc = "<ul><li>Alignment if VIA padlock is"]
    #[doc = "used.</li>"]
    #[doc = "<li>Simplifying key expansion in the 256-bit"]
    #[doc = "case by generating an extra round key."]
    #[doc = "</li></ul>"]
    pub buf: [u32; 68usize],
}
#[test]
fn bindgen_test_layout_aes_context() {
    assert_eq!(
        ::core::mem::size_of::<aes_context>(),
        280usize,
        concat!("Size of: ", stringify!(aes_context))
    );
    assert_eq!(
        ::core::mem::align_of::<aes_context>(),
        4usize,
        concat!("Alignment of ", stringify!(aes_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_context>())).nr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_context),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_context>())).rk as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_context),
            "::",
            stringify!(rk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_context>())).buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_context),
            "::",
            stringify!(buf)
        )
    );
}
impl Default for aes_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " \\brief The AES XTS context-type definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aes_xts_context {
    #[doc = "< The AES context to use for AES block"]
    #[doc = "encryption or decryption."]
    pub crypt: aes_context,
    #[doc = "< The AES context used for tweak"]
    #[doc = "computation."]
    pub tweak: aes_context,
}
#[test]
fn bindgen_test_layout_aes_xts_context() {
    assert_eq!(
        ::core::mem::size_of::<aes_xts_context>(),
        560usize,
        concat!("Size of: ", stringify!(aes_xts_context))
    );
    assert_eq!(
        ::core::mem::align_of::<aes_xts_context>(),
        4usize,
        concat!("Alignment of ", stringify!(aes_xts_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_xts_context>())).crypt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_xts_context),
            "::",
            stringify!(crypt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_xts_context>())).tweak as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_xts_context),
            "::",
            stringify!(tweak)
        )
    );
}
impl Default for aes_xts_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified AES context."]
    #[doc = ""]
    #[doc = "                 It must be the first API called before using"]
    #[doc = "                 the context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to initialize. This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_aes_init"]
    pub fn aes_init(ctx: *mut aes_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified AES context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to clear."]
    #[doc = "                 If this is \\c NULL, this function does nothing."]
    #[doc = "                 Otherwise, the context must have been at least initialized."]
    #[link_name = "\u{1}mbedtls_aes_free"]
    pub fn aes_free(ctx: *mut aes_context);
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified AES XTS context."]
    #[doc = ""]
    #[doc = "                 It must be the first API called before using"]
    #[doc = "                 the context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to initialize. This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_aes_xts_init"]
    pub fn aes_xts_init(ctx: *mut aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified AES XTS context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to clear."]
    #[doc = "                 If this is \\c NULL, this function does nothing."]
    #[doc = "                 Otherwise, the context must have been at least initialized."]
    #[link_name = "\u{1}mbedtls_aes_xts_free"]
    pub fn aes_xts_free(ctx: *mut aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          This function sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to which the key should be bound."]
    #[doc = "                 It must be initialized."]
    #[doc = " \\param key      The encryption key."]
    #[doc = "                 This must be a readable buffer of size \\p keybits bits."]
    #[doc = " \\param keybits  The size of data passed in bits. Valid options are:"]
    #[doc = "                 <ul><li>128 bits</li>"]
    #[doc = "                 <li>192 bits</li>"]
    #[doc = "                 <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    #[link_name = "\u{1}mbedtls_aes_setkey_enc"]
    pub fn aes_setkey_enc(
        ctx: *mut aes_context,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets the decryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to which the key should be bound."]
    #[doc = "                 It must be initialized."]
    #[doc = " \\param key      The decryption key."]
    #[doc = "                 This must be a readable buffer of size \\p keybits bits."]
    #[doc = " \\param keybits  The size of data passed. Valid options are:"]
    #[doc = "                 <ul><li>128 bits</li>"]
    #[doc = "                 <li>192 bits</li>"]
    #[doc = "                 <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    #[link_name = "\u{1}mbedtls_aes_setkey_dec"]
    pub fn aes_setkey_dec(
        ctx: *mut aes_context,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for encryption and"]
    #[doc = "                 sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to which the key should be bound."]
    #[doc = "                 It must be initialized."]
    #[doc = " \\param key      The encryption key. This is comprised of the XTS key1"]
    #[doc = "                 concatenated with the XTS key2."]
    #[doc = "                 This must be a readable buffer of size \\p keybits bits."]
    #[doc = " \\param keybits  The size of \\p key passed in bits. Valid options are:"]
    #[doc = "                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>"]
    #[doc = "                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    #[link_name = "\u{1}mbedtls_aes_xts_setkey_enc"]
    pub fn aes_xts_setkey_enc(
        ctx: *mut aes_xts_context,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for decryption and"]
    #[doc = "                 sets the decryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES XTS context to which the key should be bound."]
    #[doc = "                 It must be initialized."]
    #[doc = " \\param key      The decryption key. This is comprised of the XTS key1"]
    #[doc = "                 concatenated with the XTS key2."]
    #[doc = "                 This must be a readable buffer of size \\p keybits bits."]
    #[doc = " \\param keybits  The size of \\p key passed in bits. Valid options are:"]
    #[doc = "                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>"]
    #[doc = "                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    #[link_name = "\u{1}mbedtls_aes_xts_setkey_dec"]
    pub fn aes_xts_setkey_dec(
        ctx: *mut aes_xts_context,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an AES single-block encryption or"]
    #[doc = "                 decryption operation."]
    #[doc = ""]
    #[doc = "                 It performs the operation defined in the \\p mode parameter"]
    #[doc = "                 (encrypt or decrypt), on the input data buffer defined in"]
    #[doc = "                 the \\p input parameter."]
    #[doc = ""]
    #[doc = "                 mbedtls_aes_init(), and either mbedtls_aes_setkey_enc() or"]
    #[doc = "                 mbedtls_aes_setkey_dec() must be called before the first"]
    #[doc = "                 call to this API with the same context."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and at least \\c 16 Bytes long."]
    #[doc = " \\param output   The buffer where the output data will be written."]
    #[doc = "                 It must be writeable and at least \\c 16 Bytes long."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_aes_crypt_ecb"]
    pub fn aes_crypt_ecb(
        ctx: *mut aes_context,
        mode: crate::types::c_int,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief  This function performs an AES-CBC encryption or decryption operation"]
    #[doc = "         on full blocks."]
    #[doc = ""]
    #[doc = "         It performs the operation defined in the \\p mode"]
    #[doc = "         parameter (encrypt/decrypt), on the input data buffer defined in"]
    #[doc = "         the \\p input parameter."]
    #[doc = ""]
    #[doc = "         It can be called as many times as needed, until all the input"]
    #[doc = "         data is processed. mbedtls_aes_init(), and either"]
    #[doc = "         mbedtls_aes_setkey_enc() or mbedtls_aes_setkey_dec() must be called"]
    #[doc = "         before the first call to this API with the same context."]
    #[doc = ""]
    #[doc = " \\note   This function operates on full blocks, that is, the input size"]
    #[doc = "         must be a multiple of the AES block size of \\c 16 Bytes."]
    #[doc = ""]
    #[doc = " \\note   Upon exit, the content of the IV is updated so that you can"]
    #[doc = "         call the same function again on the next"]
    #[doc = "         block(s) of data and get the same result as if it was"]
    #[doc = "         encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "         If you need to retain the contents of the IV, you should"]
    #[doc = "         either save it manually or use the cipher module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param length   The length of the input data in Bytes. This must be a"]
    #[doc = "                 multiple of the block size (\\c 16 Bytes)."]
    #[doc = " \\param iv       Initialization vector (updated after use)."]
    #[doc = "                 It must be a readable and writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = "                 It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH"]
    #[doc = "                 on failure."]
    #[link_name = "\u{1}mbedtls_aes_crypt_cbc"]
    pub fn aes_crypt_cbc(
        ctx: *mut aes_context,
        mode: crate::types::c_int,
        length: usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function performs an AES-XTS encryption or decryption"]
    #[doc = "             operation for an entire XTS data unit."]
    #[doc = ""]
    #[doc = "             AES-XTS encrypts or decrypts blocks based on their location as"]
    #[doc = "             defined by a data unit number. The data unit number must be"]
    #[doc = "             provided by \\p data_unit."]
    #[doc = ""]
    #[doc = "             NIST SP 800-38E limits the maximum size of a data unit to 2^20"]
    #[doc = "             AES blocks. If the data unit is larger than this, this function"]
    #[doc = "             returns #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH."]
    #[doc = ""]
    #[doc = " \\param ctx          The AES XTS context to use for AES XTS operations."]
    #[doc = "                     It must be initialized and bound to a key."]
    #[doc = " \\param mode         The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                     #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param length       The length of a data unit in Bytes. This can be any"]
    #[doc = "                     length between 16 bytes and 2^24 bytes inclusive"]
    #[doc = "                     (between 1 and 2^20 block cipher blocks)."]
    #[doc = " \\param data_unit    The address of the data unit encoded as an array of 16"]
    #[doc = "                     bytes in little-endian format. For disk encryption, this"]
    #[doc = "                     is typically the index of the block device sector that"]
    #[doc = "                     contains the data."]
    #[doc = " \\param input        The buffer holding the input data (which is an entire"]
    #[doc = "                     data unit). This function reads \\p length Bytes from \\p"]
    #[doc = "                     input."]
    #[doc = " \\param output       The buffer holding the output data (which is an entire"]
    #[doc = "                     data unit). This function writes \\p length Bytes to \\p"]
    #[doc = "                     output."]
    #[doc = ""]
    #[doc = " \\return             \\c 0 on success."]
    #[doc = " \\return             #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH if \\p length is"]
    #[doc = "                     smaller than an AES block in size (16 Bytes) or if \\p"]
    #[doc = "                     length is larger than 2^20 blocks (16 MiB)."]
    #[link_name = "\u{1}mbedtls_aes_crypt_xts"]
    pub fn aes_crypt_xts(
        ctx: *mut aes_xts_context,
        mode: crate::types::c_int,
        length: usize,
        data_unit: *const crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief This function performs an AES-CFB128 encryption or decryption"]
    #[doc = "        operation."]
    #[doc = ""]
    #[doc = "        It performs the operation defined in the \\p mode"]
    #[doc = "        parameter (encrypt or decrypt), on the input data buffer"]
    #[doc = "        defined in the \\p input parameter."]
    #[doc = ""]
    #[doc = "        For CFB, you must set up the context with mbedtls_aes_setkey_enc(),"]
    #[doc = "        regardless of whether you are performing an encryption or decryption"]
    #[doc = "        operation, that is, regardless of the \\p mode parameter. This is"]
    #[doc = "        because CFB mode uses the same key schedule for encryption and"]
    #[doc = "        decryption."]
    #[doc = ""]
    #[doc = " \\note  Upon exit, the content of the IV is updated so that you can"]
    #[doc = "        call the same function again on the next"]
    #[doc = "        block(s) of data and get the same result as if it was"]
    #[doc = "        encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "        If you need to retain the contents of the"]
    #[doc = "        IV, you must either save it manually or use the cipher"]
    #[doc = "        module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT."]
    #[doc = " \\param length   The length of the input data in Bytes."]
    #[doc = " \\param iv_off   The offset in IV (updated after use)."]
    #[doc = "                 It must point to a valid \\c size_t."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = "                 It must be a readable and writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = "                 It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_aes_crypt_cfb128"]
    pub fn aes_crypt_cfb128(
        ctx: *mut aes_context,
        mode: crate::types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief This function performs an AES-CFB8 encryption or decryption"]
    #[doc = "        operation."]
    #[doc = ""]
    #[doc = "        It performs the operation defined in the \\p mode"]
    #[doc = "        parameter (encrypt/decrypt), on the input data buffer defined"]
    #[doc = "        in the \\p input parameter."]
    #[doc = ""]
    #[doc = "        Due to the nature of CFB, you must use the same key schedule for"]
    #[doc = "        both encryption and decryption operations. Therefore, you must"]
    #[doc = "        use the context initialized with mbedtls_aes_setkey_enc() for"]
    #[doc = "        both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT."]
    #[doc = ""]
    #[doc = " \\note  Upon exit, the content of the IV is updated so that you can"]
    #[doc = "        call the same function again on the next"]
    #[doc = "        block(s) of data and get the same result as if it was"]
    #[doc = "        encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "        If you need to retain the contents of the"]
    #[doc = "        IV, you should either save it manually or use the cipher"]
    #[doc = "        module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or"]
    #[doc = "                 #MBEDTLS_AES_DECRYPT"]
    #[doc = " \\param length   The length of the input data."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = "                 It must be a readable and writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = "                 It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_aes_crypt_cfb8"]
    pub fn aes_crypt_cfb8(
        ctx: *mut aes_context,
        mode: crate::types::c_int,
        length: usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       This function performs an AES-OFB (Output Feedback Mode)"]
    #[doc = "              encryption or decryption operation."]
    #[doc = ""]
    #[doc = "              For OFB, you must set up the context with"]
    #[doc = "              mbedtls_aes_setkey_enc(), regardless of whether you are"]
    #[doc = "              performing an encryption or decryption operation. This is"]
    #[doc = "              because OFB mode uses the same key schedule for encryption and"]
    #[doc = "              decryption."]
    #[doc = ""]
    #[doc = "              The OFB operation is identical for encryption or decryption,"]
    #[doc = "              therefore no operation mode needs to be specified."]
    #[doc = ""]
    #[doc = " \\note        Upon exit, the content of iv, the Initialisation Vector, is"]
    #[doc = "              updated so that you can call the same function again on the next"]
    #[doc = "              block(s) of data and get the same result as if it was encrypted"]
    #[doc = "              in one call. This allows a \"streaming\" usage, by initialising"]
    #[doc = "              iv_off to 0 before the first call, and preserving its value"]
    #[doc = "              between calls."]
    #[doc = ""]
    #[doc = "              For non-streaming use, the iv should be initialised on each call"]
    #[doc = "              to a unique value, and iv_off set to 0 on each call."]
    #[doc = ""]
    #[doc = "              If you need to retain the contents of the initialisation vector,"]
    #[doc = "              you must either save it manually or use the cipher module"]
    #[doc = "              instead."]
    #[doc = ""]
    #[doc = " \\warning     For the OFB mode, the initialisation vector must be unique"]
    #[doc = "              every encryption operation. Reuse of an initialisation vector"]
    #[doc = "              will compromise security."]
    #[doc = ""]
    #[doc = " \\param ctx      The AES context to use for encryption or decryption."]
    #[doc = "                 It must be initialized and bound to a key."]
    #[doc = " \\param length   The length of the input data."]
    #[doc = " \\param iv_off   The offset in IV (updated after use)."]
    #[doc = "                 It must point to a valid \\c size_t."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = "                 It must be a readable and writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data."]
    #[doc = "                 It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data."]
    #[doc = "                 It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_aes_crypt_ofb"]
    pub fn aes_crypt_ofb(
        ctx: *mut aes_context,
        length: usize,
        iv_off: *mut usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function performs an AES-CTR encryption or decryption"]
    #[doc = "             operation."]
    #[doc = ""]
    #[doc = "             This function performs the operation defined in the \\p mode"]
    #[doc = "             parameter (encrypt/decrypt), on the input data buffer"]
    #[doc = "             defined in the \\p input parameter."]
    #[doc = ""]
    #[doc = "             Due to the nature of CTR, you must use the same key schedule"]
    #[doc = "             for both encryption and decryption operations. Therefore, you"]
    #[doc = "             must use the context initialized with mbedtls_aes_setkey_enc()"]
    #[doc = "             for both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT."]
    #[doc = ""]
    #[doc = " \\warning    You must never reuse a nonce value with the same key. Doing so"]
    #[doc = "             would void the encryption for the two messages encrypted with"]
    #[doc = "             the same nonce and key."]
    #[doc = ""]
    #[doc = "             There are two common strategies for managing nonces with CTR:"]
    #[doc = ""]
    #[doc = "             1. You can handle everything as a single message processed over"]
    #[doc = "             successive calls to this function. In that case, you want to"]
    #[doc = "             set \\p nonce_counter and \\p nc_off to 0 for the first call, and"]
    #[doc = "             then preserve the values of \\p nonce_counter, \\p nc_off and \\p"]
    #[doc = "             stream_block across calls to this function as they will be"]
    #[doc = "             updated by this function."]
    #[doc = ""]
    #[doc = "             With this strategy, you must not encrypt more than 2**128"]
    #[doc = "             blocks of data with the same key."]
    #[doc = ""]
    #[doc = "             2. You can encrypt separate messages by dividing the \\p"]
    #[doc = "             nonce_counter buffer in two areas: the first one used for a"]
    #[doc = "             per-message nonce, handled by yourself, and the second one"]
    #[doc = "             updated by this function internally."]
    #[doc = ""]
    #[doc = "             For example, you might reserve the first 12 bytes for the"]
    #[doc = "             per-message nonce, and the last 4 bytes for internal use. In that"]
    #[doc = "             case, before calling this function on a new message you need to"]
    #[doc = "             set the first 12 bytes of \\p nonce_counter to your chosen nonce"]
    #[doc = "             value, the last 4 to 0, and \\p nc_off to 0 (which will cause \\p"]
    #[doc = "             stream_block to be ignored). That way, you can encrypt at most"]
    #[doc = "             2**96 messages of up to 2**32 blocks each with the same key."]
    #[doc = ""]
    #[doc = "             The per-message nonce (or information sufficient to reconstruct"]
    #[doc = "             it) needs to be communicated with the ciphertext and must be unique."]
    #[doc = "             The recommended way to ensure uniqueness is to use a message"]
    #[doc = "             counter. An alternative is to generate random nonces, but this"]
    #[doc = "             limits the number of messages that can be securely encrypted:"]
    #[doc = "             for example, with 96-bit random nonces, you should not encrypt"]
    #[doc = "             more than 2**32 messages with the same key."]
    #[doc = ""]
    #[doc = "             Note that for both stategies, sizes are measured in blocks and"]
    #[doc = "             that an AES block is 16 bytes."]
    #[doc = ""]
    #[doc = " \\warning    Upon return, \\p stream_block contains sensitive data. Its"]
    #[doc = "             content must not be written to insecure storage and should be"]
    #[doc = "             securely discarded as soon as it's no longer needed."]
    #[doc = ""]
    #[doc = " \\param ctx              The AES context to use for encryption or decryption."]
    #[doc = "                         It must be initialized and bound to a key."]
    #[doc = " \\param length           The length of the input data."]
    #[doc = " \\param nc_off           The offset in the current \\p stream_block, for"]
    #[doc = "                         resuming within the current cipher stream. The"]
    #[doc = "                         offset pointer should be 0 at the start of a stream."]
    #[doc = "                         It must point to a valid \\c size_t."]
    #[doc = " \\param nonce_counter    The 128-bit nonce and counter."]
    #[doc = "                         It must be a readable-writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param stream_block     The saved stream block for resuming. This is"]
    #[doc = "                         overwritten by the function."]
    #[doc = "                         It must be a readable-writeable buffer of \\c 16 Bytes."]
    #[doc = " \\param input            The buffer holding the input data."]
    #[doc = "                         It must be readable and of size \\p length Bytes."]
    #[doc = " \\param output           The buffer holding the output data."]
    #[doc = "                         It must be writeable and of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return                 \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_aes_crypt_ctr"]
    pub fn aes_crypt_ctr(
        ctx: *mut aes_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut crate::types::c_uchar,
        stream_block: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block encryption function. This is only"]
    #[doc = "                  exposed to allow overriding it using"]
    #[doc = "                  \\c MBEDTLS_AES_ENCRYPT_ALT."]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for encryption."]
    #[doc = " \\param input     The plaintext block."]
    #[doc = " \\param output    The output (ciphertext) block."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_internal_aes_encrypt"]
    pub fn internal_aes_encrypt(
        ctx: *mut aes_context,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block decryption function. This is only"]
    #[doc = "                  exposed to allow overriding it using see"]
    #[doc = "                  \\c MBEDTLS_AES_DECRYPT_ALT."]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for decryption."]
    #[doc = " \\param input     The ciphertext block."]
    #[doc = " \\param output    The output (plaintext) block."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_internal_aes_decrypt"]
    pub fn internal_aes_decrypt(
        ctx: *mut aes_context,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Deprecated internal AES block encryption function"]
    #[doc = "                  without return value."]
    #[doc = ""]
    #[doc = " \\deprecated      Superseded by mbedtls_internal_aes_encrypt()"]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for encryption."]
    #[doc = " \\param input     Plaintext block."]
    #[doc = " \\param output    Output (ciphertext) block."]
    #[link_name = "\u{1}mbedtls_aes_encrypt"]
    pub fn aes_encrypt(
        ctx: *mut aes_context,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief           Deprecated internal AES block decryption function"]
    #[doc = "                  without return value."]
    #[doc = ""]
    #[doc = " \\deprecated      Superseded by mbedtls_internal_aes_decrypt()"]
    #[doc = ""]
    #[doc = " \\param ctx       The AES context to use for decryption."]
    #[doc = " \\param input     Ciphertext block."]
    #[doc = " \\param output    Output (plaintext) block."]
    #[link_name = "\u{1}mbedtls_aes_decrypt"]
    pub fn aes_decrypt(
        ctx: *mut aes_context,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_aes_self_test"]
    pub fn aes_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief       PEM context structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pem_context {
    #[doc = "< buffer for decoded data"]
    pub buf: *mut crate::types::c_uchar,
    #[doc = "< length of the buffer"]
    pub buflen: usize,
    #[doc = "< buffer for extra header information"]
    pub info: *mut crate::types::c_uchar,
}
#[test]
fn bindgen_test_layout_pem_context() {
    assert_eq!(
        ::core::mem::size_of::<pem_context>(),
        12usize,
        concat!("Size of: ", stringify!(pem_context))
    );
    assert_eq!(
        ::core::mem::align_of::<pem_context>(),
        4usize,
        concat!("Alignment of ", stringify!(pem_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pem_context>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_context),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pem_context>())).buflen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_context),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pem_context>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_context),
            "::",
            stringify!(info)
        )
    );
}
impl Default for pem_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief       PEM context setup"]
    #[doc = ""]
    #[doc = " \\param ctx   context to be initialized"]
    #[link_name = "\u{1}mbedtls_pem_init"]
    pub fn pem_init(ctx: *mut pem_context);
}
extern "C" {
    #[doc = " \\brief       Read a buffer for PEM information and store the resulting"]
    #[doc = "              data into the specified context buffers."]
    #[doc = ""]
    #[doc = " \\param ctx       context to use"]
    #[doc = " \\param header    header string to seek and expect"]
    #[doc = " \\param footer    footer string to seek and expect"]
    #[doc = " \\param data      source data to look in (must be nul-terminated)"]
    #[doc = " \\param pwd       password for decryption (can be NULL)"]
    #[doc = " \\param pwdlen    length of password"]
    #[doc = " \\param use_len   destination for total length used (set after header is"]
    #[doc = "                  correctly read, so unless you get"]
    #[doc = "                  MBEDTLS_ERR_PEM_BAD_INPUT_DATA or"]
    #[doc = "                  MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT, use_len is"]
    #[doc = "                  the length to skip)"]
    #[doc = ""]
    #[doc = " \\note            Attempts to check password correctness by verifying if"]
    #[doc = "                  the decrypted text starts with an ASN.1 sequence of"]
    #[doc = "                  appropriate length"]
    #[doc = ""]
    #[doc = " \\return          0 on success, or a specific PEM error code"]
    #[link_name = "\u{1}mbedtls_pem_read_buffer"]
    pub fn pem_read_buffer(
        ctx: *mut pem_context,
        header: *const crate::types::c_char,
        footer: *const crate::types::c_char,
        data: *const crate::types::c_uchar,
        pwd: *const crate::types::c_uchar,
        pwdlen: usize,
        use_len: *mut usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief       PEM context memory freeing"]
    #[doc = ""]
    #[doc = " \\param ctx   context to be freed"]
    #[link_name = "\u{1}mbedtls_pem_free"]
    pub fn pem_free(ctx: *mut pem_context);
}
extern "C" {
    #[doc = " \\brief           Write a buffer of PEM information from a DER encoded"]
    #[doc = "                  buffer."]
    #[doc = ""]
    #[doc = " \\param header    The header string to write."]
    #[doc = " \\param footer    The footer string to write."]
    #[doc = " \\param der_data  The DER data to encode."]
    #[doc = " \\param der_len   The length of the DER data \\p der_data in Bytes."]
    #[doc = " \\param buf       The buffer to write to."]
    #[doc = " \\param buf_len   The length of the output buffer \\p buf in Bytes."]
    #[doc = " \\param olen      The address at which to store the total length written"]
    #[doc = "                  or required (if \\p buf_len is not enough)."]
    #[doc = ""]
    #[doc = " \\note            You may pass \\c NULL for \\p buf and \\c 0 for \\p buf_len"]
    #[doc = "                  to request the length of the resulting PEM buffer in"]
    #[doc = "                  `*olen`."]
    #[doc = ""]
    #[doc = " \\note            This function may be called with overlapping \\p der_data"]
    #[doc = "                  and \\p buf buffers."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL if \\p buf isn't large"]
    #[doc = "                  enough to hold the PEM buffer. In  this case, `*olen` holds"]
    #[doc = "                  the required minimum size of \\p buf."]
    #[doc = " \\return          Another PEM or BASE64 error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_pem_write_buffer"]
    pub fn pem_write_buffer(
        header: *const crate::types::c_char,
        footer: *const crate::types::c_char,
        der_data: *const crate::types::c_uchar,
        der_len: usize,
        buf: *mut crate::types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> crate::types::c_int;
}
#[doc = " \\brief     ARC4 context structure"]
#[doc = ""]
#[doc = " \\warning   ARC4 is considered a weak cipher and its use constitutes a"]
#[doc = "            security risk. We recommend considering stronger ciphers instead."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arc4_context {
    #[doc = "< permutation index"]
    pub x: crate::types::c_int,
    #[doc = "< permutation index"]
    pub y: crate::types::c_int,
    #[doc = "< permutation table"]
    pub m: [crate::types::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_arc4_context() {
    assert_eq!(
        ::core::mem::size_of::<arc4_context>(),
        264usize,
        concat!("Size of: ", stringify!(arc4_context))
    );
    assert_eq!(
        ::core::mem::align_of::<arc4_context>(),
        4usize,
        concat!("Alignment of ", stringify!(arc4_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arc4_context>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arc4_context),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arc4_context>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arc4_context),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arc4_context>())).m as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arc4_context),
            "::",
            stringify!(m)
        )
    );
}
impl Default for arc4_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Initialize ARC4 context"]
    #[doc = ""]
    #[doc = " \\param ctx      ARC4 context to be initialized"]
    #[doc = ""]
    #[doc = " \\warning        ARC4 is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_arc4_init"]
    pub fn arc4_init(ctx: *mut arc4_context);
}
extern "C" {
    #[doc = " \\brief          Clear ARC4 context"]
    #[doc = ""]
    #[doc = " \\param ctx      ARC4 context to be cleared"]
    #[doc = ""]
    #[doc = " \\warning        ARC4 is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_arc4_free"]
    pub fn arc4_free(ctx: *mut arc4_context);
}
extern "C" {
    #[doc = " \\brief          ARC4 key schedule"]
    #[doc = ""]
    #[doc = " \\param ctx      ARC4 context to be setup"]
    #[doc = " \\param key      the secret key"]
    #[doc = " \\param keylen   length of the key, in bytes"]
    #[doc = ""]
    #[doc = " \\warning        ARC4 is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_arc4_setup"]
    pub fn arc4_setup(
        ctx: *mut arc4_context,
        key: *const crate::types::c_uchar,
        keylen: crate::types::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief          ARC4 cipher function"]
    #[doc = ""]
    #[doc = " \\param ctx      ARC4 context"]
    #[doc = " \\param length   length of the input data"]
    #[doc = " \\param input    buffer holding the input data"]
    #[doc = " \\param output   buffer for the output data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        ARC4 is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_arc4_crypt"]
    pub fn arc4_crypt(
        ctx: *mut arc4_context,
        length: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[doc = ""]
    #[doc = " \\warning        ARC4 is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_arc4_self_test"]
    pub fn arc4_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief The ARIA context-type definition."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aria_context {
    #[doc = "< The number of rounds (12, 14 or 16)"]
    pub nr: crate::types::c_uchar,
    #[doc = " The ARIA round keys."]
    pub rk: [[u32; 4usize]; 17usize],
}
#[test]
fn bindgen_test_layout_aria_context() {
    assert_eq!(
        ::core::mem::size_of::<aria_context>(),
        276usize,
        concat!("Size of: ", stringify!(aria_context))
    );
    assert_eq!(
        ::core::mem::align_of::<aria_context>(),
        4usize,
        concat!("Alignment of ", stringify!(aria_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aria_context>())).nr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aria_context),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aria_context>())).rk as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aria_context),
            "::",
            stringify!(rk)
        )
    );
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified ARIA context."]
    #[doc = ""]
    #[doc = "                 It must be the first API called before using"]
    #[doc = "                 the context."]
    #[doc = ""]
    #[doc = " \\param ctx      The ARIA context to initialize. This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_aria_init"]
    pub fn aria_init(ctx: *mut aria_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified ARIA context."]
    #[doc = ""]
    #[doc = " \\param ctx      The ARIA context to clear. This may be \\c NULL, in which"]
    #[doc = "                 case this function returns immediately. If it is not \\c NULL,"]
    #[doc = "                 it must point to an initialized ARIA context."]
    #[link_name = "\u{1}mbedtls_aria_free"]
    pub fn aria_free(ctx: *mut aria_context);
}
extern "C" {
    #[doc = " \\brief          This function sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The ARIA context to which the key should be bound."]
    #[doc = "                 This must be initialized."]
    #[doc = " \\param key      The encryption key. This must be a readable buffer"]
    #[doc = "                 of size \\p keybits Bits."]
    #[doc = " \\param keybits  The size of \\p key in Bits. Valid options are:"]
    #[doc = "                 <ul><li>128 bits</li>"]
    #[doc = "                 <li>192 bits</li>"]
    #[doc = "                 <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_aria_setkey_enc"]
    pub fn aria_setkey_enc(
        ctx: *mut aria_context,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets the decryption key."]
    #[doc = ""]
    #[doc = " \\param ctx      The ARIA context to which the key should be bound."]
    #[doc = "                 This must be initialized."]
    #[doc = " \\param key      The decryption key. This must be a readable buffer"]
    #[doc = "                 of size \\p keybits Bits."]
    #[doc = " \\param keybits  The size of data passed. Valid options are:"]
    #[doc = "                 <ul><li>128 bits</li>"]
    #[doc = "                 <li>192 bits</li>"]
    #[doc = "                 <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_aria_setkey_dec"]
    pub fn aria_setkey_dec(
        ctx: *mut aria_context,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an ARIA single-block encryption or"]
    #[doc = "                 decryption operation."]
    #[doc = ""]
    #[doc = "                 It performs encryption or decryption (depending on whether"]
    #[doc = "                 the key was set for encryption on decryption) on the input"]
    #[doc = "                 data buffer defined in the \\p input parameter."]
    #[doc = ""]
    #[doc = "                 mbedtls_aria_init(), and either mbedtls_aria_setkey_enc() or"]
    #[doc = "                 mbedtls_aria_setkey_dec() must be called before the first"]
    #[doc = "                 call to this API with the same context."]
    #[doc = ""]
    #[doc = " \\param ctx      The ARIA context to use for encryption or decryption."]
    #[doc = "                 This must be initialized and bound to a key."]
    #[doc = " \\param input    The 16-Byte buffer holding the input data."]
    #[doc = " \\param output   The 16-Byte buffer holding the output data."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_aria_crypt_ecb"]
    pub fn aria_crypt_ecb(
        ctx: *mut aria_context,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief  This function performs an ARIA-CBC encryption or decryption operation"]
    #[doc = "         on full blocks."]
    #[doc = ""]
    #[doc = "         It performs the operation defined in the \\p mode"]
    #[doc = "         parameter (encrypt/decrypt), on the input data buffer defined in"]
    #[doc = "         the \\p input parameter."]
    #[doc = ""]
    #[doc = "         It can be called as many times as needed, until all the input"]
    #[doc = "         data is processed. mbedtls_aria_init(), and either"]
    #[doc = "         mbedtls_aria_setkey_enc() or mbedtls_aria_setkey_dec() must be called"]
    #[doc = "         before the first call to this API with the same context."]
    #[doc = ""]
    #[doc = " \\note   This function operates on aligned blocks, that is, the input size"]
    #[doc = "         must be a multiple of the ARIA block size of 16 Bytes."]
    #[doc = ""]
    #[doc = " \\note   Upon exit, the content of the IV is updated so that you can"]
    #[doc = "         call the same function again on the next"]
    #[doc = "         block(s) of data and get the same result as if it was"]
    #[doc = "         encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "         If you need to retain the contents of the IV, you should"]
    #[doc = "         either save it manually or use the cipher module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The ARIA context to use for encryption or decryption."]
    #[doc = "                 This must be initialized and bound to a key."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_ARIA_ENCRYPT for encryption, or"]
    #[doc = "                 #MBEDTLS_ARIA_DECRYPT for decryption."]
    #[doc = " \\param length   The length of the input data in Bytes. This must be a"]
    #[doc = "                 multiple of the block size (16 Bytes)."]
    #[doc = " \\param iv       Initialization vector (updated after use)."]
    #[doc = "                 This must be a readable buffer of size 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data. This must"]
    #[doc = "                 be a readable buffer of length \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data. This must"]
    #[doc = "                 be a writable buffer of length \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_aria_crypt_cbc"]
    pub fn aria_crypt_cbc(
        ctx: *mut aria_context,
        mode: crate::types::c_int,
        length: usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief This function performs an ARIA-CFB128 encryption or decryption"]
    #[doc = "        operation."]
    #[doc = ""]
    #[doc = "        It performs the operation defined in the \\p mode"]
    #[doc = "        parameter (encrypt or decrypt), on the input data buffer"]
    #[doc = "        defined in the \\p input parameter."]
    #[doc = ""]
    #[doc = "        For CFB, you must set up the context with mbedtls_aria_setkey_enc(),"]
    #[doc = "        regardless of whether you are performing an encryption or decryption"]
    #[doc = "        operation, that is, regardless of the \\p mode parameter. This is"]
    #[doc = "        because CFB mode uses the same key schedule for encryption and"]
    #[doc = "        decryption."]
    #[doc = ""]
    #[doc = " \\note  Upon exit, the content of the IV is updated so that you can"]
    #[doc = "        call the same function again on the next"]
    #[doc = "        block(s) of data and get the same result as if it was"]
    #[doc = "        encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "        If you need to retain the contents of the"]
    #[doc = "        IV, you must either save it manually or use the cipher"]
    #[doc = "        module instead."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param ctx      The ARIA context to use for encryption or decryption."]
    #[doc = "                 This must be initialized and bound to a key."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_ARIA_ENCRYPT for encryption, or"]
    #[doc = "                 #MBEDTLS_ARIA_DECRYPT for decryption."]
    #[doc = " \\param length   The length of the input data \\p input in Bytes."]
    #[doc = " \\param iv_off   The offset in IV (updated after use)."]
    #[doc = "                 This must not be larger than 15."]
    #[doc = " \\param iv       The initialization vector (updated after use)."]
    #[doc = "                 This must be a readable buffer of size 16 Bytes."]
    #[doc = " \\param input    The buffer holding the input data. This must"]
    #[doc = "                 be a readable buffer of length \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data. This must"]
    #[doc = "                 be a writable buffer of length \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_aria_crypt_cfb128"]
    pub fn aria_crypt_cfb128(
        ctx: *mut aria_context,
        mode: crate::types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function performs an ARIA-CTR encryption or decryption"]
    #[doc = "             operation."]
    #[doc = ""]
    #[doc = "             This function performs the operation defined in the \\p mode"]
    #[doc = "             parameter (encrypt/decrypt), on the input data buffer"]
    #[doc = "             defined in the \\p input parameter."]
    #[doc = ""]
    #[doc = "             Due to the nature of CTR, you must use the same key schedule"]
    #[doc = "             for both encryption and decryption operations. Therefore, you"]
    #[doc = "             must use the context initialized with mbedtls_aria_setkey_enc()"]
    #[doc = "             for both #MBEDTLS_ARIA_ENCRYPT and #MBEDTLS_ARIA_DECRYPT."]
    #[doc = ""]
    #[doc = " \\warning    You must never reuse a nonce value with the same key. Doing so"]
    #[doc = "             would void the encryption for the two messages encrypted with"]
    #[doc = "             the same nonce and key."]
    #[doc = ""]
    #[doc = "             There are two common strategies for managing nonces with CTR:"]
    #[doc = ""]
    #[doc = "             1. You can handle everything as a single message processed over"]
    #[doc = "             successive calls to this function. In that case, you want to"]
    #[doc = "             set \\p nonce_counter and \\p nc_off to 0 for the first call, and"]
    #[doc = "             then preserve the values of \\p nonce_counter, \\p nc_off and \\p"]
    #[doc = "             stream_block across calls to this function as they will be"]
    #[doc = "             updated by this function."]
    #[doc = ""]
    #[doc = "             With this strategy, you must not encrypt more than 2**128"]
    #[doc = "             blocks of data with the same key."]
    #[doc = ""]
    #[doc = "             2. You can encrypt separate messages by dividing the \\p"]
    #[doc = "             nonce_counter buffer in two areas: the first one used for a"]
    #[doc = "             per-message nonce, handled by yourself, and the second one"]
    #[doc = "             updated by this function internally."]
    #[doc = ""]
    #[doc = "             For example, you might reserve the first 12 bytes for the"]
    #[doc = "             per-message nonce, and the last 4 bytes for internal use. In that"]
    #[doc = "             case, before calling this function on a new message you need to"]
    #[doc = "             set the first 12 bytes of \\p nonce_counter to your chosen nonce"]
    #[doc = "             value, the last 4 to 0, and \\p nc_off to 0 (which will cause \\p"]
    #[doc = "             stream_block to be ignored). That way, you can encrypt at most"]
    #[doc = "             2**96 messages of up to 2**32 blocks each with the same key."]
    #[doc = ""]
    #[doc = "             The per-message nonce (or information sufficient to reconstruct"]
    #[doc = "             it) needs to be communicated with the ciphertext and must be unique."]
    #[doc = "             The recommended way to ensure uniqueness is to use a message"]
    #[doc = "             counter. An alternative is to generate random nonces, but this"]
    #[doc = "             limits the number of messages that can be securely encrypted:"]
    #[doc = "             for example, with 96-bit random nonces, you should not encrypt"]
    #[doc = "             more than 2**32 messages with the same key."]
    #[doc = ""]
    #[doc = "             Note that for both stategies, sizes are measured in blocks and"]
    #[doc = "             that an ARIA block is 16 bytes."]
    #[doc = ""]
    #[doc = " \\warning    Upon return, \\p stream_block contains sensitive data. Its"]
    #[doc = "             content must not be written to insecure storage and should be"]
    #[doc = "             securely discarded as soon as it's no longer needed."]
    #[doc = ""]
    #[doc = " \\param ctx              The ARIA context to use for encryption or decryption."]
    #[doc = "                         This must be initialized and bound to a key."]
    #[doc = " \\param length           The length of the input data \\p input in Bytes."]
    #[doc = " \\param nc_off           The offset in Bytes in the current \\p stream_block,"]
    #[doc = "                         for resuming within the current cipher stream. The"]
    #[doc = "                         offset pointer should be \\c 0 at the start of a"]
    #[doc = "                         stream. This must not be larger than \\c 15 Bytes."]
    #[doc = " \\param nonce_counter    The 128-bit nonce and counter. This must point to"]
    #[doc = "                         a read/write buffer of length \\c 16 bytes."]
    #[doc = " \\param stream_block     The saved stream block for resuming. This must"]
    #[doc = "                         point to a read/write buffer of length \\c 16 bytes."]
    #[doc = "                         This is overwritten by the function."]
    #[doc = " \\param input            The buffer holding the input data. This must"]
    #[doc = "                         be a readable buffer of length \\p length Bytes."]
    #[doc = " \\param output           The buffer holding the output data. This must"]
    #[doc = "                         be a writable buffer of length \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return                 \\c 0 on success."]
    #[doc = " \\return                 A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_aria_crypt_ctr"]
    pub fn aria_crypt_ctr(
        ctx: *mut aria_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut crate::types::c_uchar,
        stream_block: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success, or \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_aria_self_test"]
    pub fn aria_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Encode a buffer into base64 format"]
    #[doc = ""]
    #[doc = " \\param dst      destination buffer"]
    #[doc = " \\param dlen     size of the destination buffer"]
    #[doc = " \\param olen     number of bytes written"]
    #[doc = " \\param src      source buffer"]
    #[doc = " \\param slen     amount of data to be encoded"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL."]
    #[doc = "                 *olen is always updated to reflect the amount"]
    #[doc = "                 of data that has (or would have) been written."]
    #[doc = "                 If that length cannot be represented, then no data is"]
    #[doc = "                 written to the buffer and *olen is set to the maximum"]
    #[doc = "                 length representable as a size_t."]
    #[doc = ""]
    #[doc = " \\note           Call this function with dlen = 0 to obtain the"]
    #[doc = "                 required buffer size in *olen"]
    #[link_name = "\u{1}mbedtls_base64_encode"]
    pub fn base64_encode(
        dst: *mut crate::types::c_uchar,
        dlen: usize,
        olen: *mut usize,
        src: *const crate::types::c_uchar,
        slen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Decode a base64-formatted buffer"]
    #[doc = ""]
    #[doc = " \\param dst      destination buffer (can be NULL for checking size)"]
    #[doc = " \\param dlen     size of the destination buffer"]
    #[doc = " \\param olen     number of bytes written"]
    #[doc = " \\param src      source buffer"]
    #[doc = " \\param slen     amount of data to be decoded"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL, or"]
    #[doc = "                 MBEDTLS_ERR_BASE64_INVALID_CHARACTER if the input data is"]
    #[doc = "                 not correct. *olen is always updated to reflect the amount"]
    #[doc = "                 of data that has (or would have) been written."]
    #[doc = ""]
    #[doc = " \\note           Call this function with *dst = NULL or dlen = 0 to obtain"]
    #[doc = "                 the required buffer size in *olen"]
    #[link_name = "\u{1}mbedtls_base64_decode"]
    pub fn base64_decode(
        dst: *mut crate::types::c_uchar,
        dlen: usize,
        olen: *mut usize,
        src: *const crate::types::c_uchar,
        slen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[link_name = "\u{1}mbedtls_base64_self_test"]
    pub fn base64_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          Blowfish context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blowfish_context {
    #[doc = "<  Blowfish round keys"]
    pub P: [u32; 18usize],
    #[doc = "<  key dependent S-boxes"]
    pub S: [[u32; 256usize]; 4usize],
}
#[test]
fn bindgen_test_layout_blowfish_context() {
    assert_eq!(
        ::core::mem::size_of::<blowfish_context>(),
        4168usize,
        concat!("Size of: ", stringify!(blowfish_context))
    );
    assert_eq!(
        ::core::mem::align_of::<blowfish_context>(),
        4usize,
        concat!("Alignment of ", stringify!(blowfish_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blowfish_context>())).P as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blowfish_context),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blowfish_context>())).S as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blowfish_context),
            "::",
            stringify!(S)
        )
    );
}
impl Default for blowfish_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Initialize a Blowfish context."]
    #[doc = ""]
    #[doc = " \\param ctx      The Blowfish context to be initialized."]
    #[doc = "                 This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_blowfish_init"]
    pub fn blowfish_init(ctx: *mut blowfish_context);
}
extern "C" {
    #[doc = " \\brief          Clear a Blowfish context."]
    #[doc = ""]
    #[doc = " \\param ctx      The Blowfish context to be cleared."]
    #[doc = "                 This may be \\c NULL, in which case this function"]
    #[doc = "                 returns immediately. If it is not \\c NULL, it must"]
    #[doc = "                 point to an initialized Blowfish context."]
    #[link_name = "\u{1}mbedtls_blowfish_free"]
    pub fn blowfish_free(ctx: *mut blowfish_context);
}
extern "C" {
    #[doc = " \\brief          Perform a Blowfish key schedule operation."]
    #[doc = ""]
    #[doc = " \\param ctx      The Blowfish context to perform the key schedule on."]
    #[doc = " \\param key      The encryption key. This must be a readable buffer of"]
    #[doc = "                 length \\p keybits Bits."]
    #[doc = " \\param keybits  The length of \\p key in Bits. This must be between"]
    #[doc = "                 \\c 32 and \\c 448 and a multiple of \\c 8."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_blowfish_setkey"]
    pub fn blowfish_setkey(
        ctx: *mut blowfish_context,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a Blowfish-ECB block encryption/decryption operation."]
    #[doc = ""]
    #[doc = " \\param ctx      The Blowfish context to use. This must be initialized"]
    #[doc = "                 and bound to a key."]
    #[doc = " \\param mode     The mode of operation. Possible values are"]
    #[doc = "                 #MBEDTLS_BLOWFISH_ENCRYPT for encryption, or"]
    #[doc = "                 #MBEDTLS_BLOWFISH_DECRYPT for decryption."]
    #[doc = " \\param input    The input block. This must be a readable buffer"]
    #[doc = "                 of size \\c 8 Bytes."]
    #[doc = " \\param output   The output block. This must be a writable buffer"]
    #[doc = "                 of size \\c 8 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_blowfish_crypt_ecb"]
    pub fn blowfish_crypt_ecb(
        ctx: *mut blowfish_context,
        mode: crate::types::c_int,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a Blowfish-CBC buffer encryption/decryption operation."]
    #[doc = ""]
    #[doc = " \\note           Upon exit, the content of the IV is updated so that you can"]
    #[doc = "                 call the function same function again on the following"]
    #[doc = "                 block(s) of data and get the same result as if it was"]
    #[doc = "                 encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "                 If on the other hand you need to retain the contents of the"]
    #[doc = "                 IV, you should either save it manually or use the cipher"]
    #[doc = "                 module instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The Blowfish context to use. This must be initialized"]
    #[doc = "                 and bound to a key."]
    #[doc = " \\param mode     The mode of operation. Possible values are"]
    #[doc = "                 #MBEDTLS_BLOWFISH_ENCRYPT for encryption, or"]
    #[doc = "                 #MBEDTLS_BLOWFISH_DECRYPT for decryption."]
    #[doc = " \\param length   The length of the input data in Bytes. This must be"]
    #[doc = "                 multiple of \\c 8."]
    #[doc = " \\param iv       The initialization vector. This must be a read/write buffer"]
    #[doc = "                 of length \\c 8 Bytes. It is updated by this function."]
    #[doc = " \\param input    The input data. This must be a readable buffer of length"]
    #[doc = "                 \\p length Bytes."]
    #[doc = " \\param output   The output data. This must be a writable buffer of length"]
    #[doc = "                 \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_blowfish_crypt_cbc"]
    pub fn blowfish_crypt_cbc(
        ctx: *mut blowfish_context,
        mode: crate::types::c_int,
        length: usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a Blowfish CFB buffer encryption/decryption operation."]
    #[doc = ""]
    #[doc = " \\note           Upon exit, the content of the IV is updated so that you can"]
    #[doc = "                 call the function same function again on the following"]
    #[doc = "                 block(s) of data and get the same result as if it was"]
    #[doc = "                 encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "                 If on the other hand you need to retain the contents of the"]
    #[doc = "                 IV, you should either save it manually or use the cipher"]
    #[doc = "                 module instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The Blowfish context to use. This must be initialized"]
    #[doc = "                 and bound to a key."]
    #[doc = " \\param mode     The mode of operation. Possible values are"]
    #[doc = "                 #MBEDTLS_BLOWFISH_ENCRYPT for encryption, or"]
    #[doc = "                 #MBEDTLS_BLOWFISH_DECRYPT for decryption."]
    #[doc = " \\param length   The length of the input data in Bytes."]
    #[doc = " \\param iv_off   The offset in the initialiation vector."]
    #[doc = "                 The value pointed to must be smaller than \\c 8 Bytes."]
    #[doc = "                 It is updated by this function to support the aforementioned"]
    #[doc = "                 streaming usage."]
    #[doc = " \\param iv       The initialization vector. This must be a read/write buffer"]
    #[doc = "                 of size \\c 8 Bytes. It is updated after use."]
    #[doc = " \\param input    The input data. This must be a readable buffer of length"]
    #[doc = "                 \\p length Bytes."]
    #[doc = " \\param output   The output data. This must be a writable buffer of length"]
    #[doc = "                 \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_blowfish_crypt_cfb64"]
    pub fn blowfish_crypt_cfb64(
        ctx: *mut blowfish_context,
        mode: crate::types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief      Perform a Blowfish-CTR buffer encryption/decryption operation."]
    #[doc = ""]
    #[doc = " \\warning    You must never reuse a nonce value with the same key. Doing so"]
    #[doc = "             would void the encryption for the two messages encrypted with"]
    #[doc = "             the same nonce and key."]
    #[doc = ""]
    #[doc = "             There are two common strategies for managing nonces with CTR:"]
    #[doc = ""]
    #[doc = "             1. You can handle everything as a single message processed over"]
    #[doc = "             successive calls to this function. In that case, you want to"]
    #[doc = "             set \\p nonce_counter and \\p nc_off to 0 for the first call, and"]
    #[doc = "             then preserve the values of \\p nonce_counter, \\p nc_off and \\p"]
    #[doc = "             stream_block across calls to this function as they will be"]
    #[doc = "             updated by this function."]
    #[doc = ""]
    #[doc = "             With this strategy, you must not encrypt more than 2**64"]
    #[doc = "             blocks of data with the same key."]
    #[doc = ""]
    #[doc = "             2. You can encrypt separate messages by dividing the \\p"]
    #[doc = "             nonce_counter buffer in two areas: the first one used for a"]
    #[doc = "             per-message nonce, handled by yourself, and the second one"]
    #[doc = "             updated by this function internally."]
    #[doc = ""]
    #[doc = "             For example, you might reserve the first 4 bytes for the"]
    #[doc = "             per-message nonce, and the last 4 bytes for internal use. In that"]
    #[doc = "             case, before calling this function on a new message you need to"]
    #[doc = "             set the first 4 bytes of \\p nonce_counter to your chosen nonce"]
    #[doc = "             value, the last 4 to 0, and \\p nc_off to 0 (which will cause \\p"]
    #[doc = "             stream_block to be ignored). That way, you can encrypt at most"]
    #[doc = "             2**32 messages of up to 2**32 blocks each with the same key."]
    #[doc = ""]
    #[doc = "             The per-message nonce (or information sufficient to reconstruct"]
    #[doc = "             it) needs to be communicated with the ciphertext and must be unique."]
    #[doc = "             The recommended way to ensure uniqueness is to use a message"]
    #[doc = "             counter."]
    #[doc = ""]
    #[doc = "             Note that for both stategies, sizes are measured in blocks and"]
    #[doc = "             that a Blowfish block is 8 bytes."]
    #[doc = ""]
    #[doc = " \\warning    Upon return, \\p stream_block contains sensitive data. Its"]
    #[doc = "             content must not be written to insecure storage and should be"]
    #[doc = "             securely discarded as soon as it's no longer needed."]
    #[doc = ""]
    #[doc = " \\param ctx           The Blowfish context to use. This must be initialized"]
    #[doc = "                      and bound to a key."]
    #[doc = " \\param length        The length of the input data in Bytes."]
    #[doc = " \\param nc_off        The offset in the current stream_block (for resuming"]
    #[doc = "                      within current cipher stream). The offset pointer"]
    #[doc = "                      should be \\c 0 at the start of a stream and must be"]
    #[doc = "                      smaller than \\c 8. It is updated by this function."]
    #[doc = " \\param nonce_counter The 64-bit nonce and counter. This must point to a"]
    #[doc = "                      read/write buffer of length \\c 8 Bytes."]
    #[doc = " \\param stream_block  The saved stream-block for resuming. This must point to"]
    #[doc = "                      a read/write buffer of length \\c 8 Bytes."]
    #[doc = " \\param input         The input data. This must be a readable buffer of"]
    #[doc = "                      length \\p length Bytes."]
    #[doc = " \\param output        The output data. This must be a writable buffer of"]
    #[doc = "                      length \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 if successful."]
    #[doc = " \\return              A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_blowfish_crypt_ctr"]
    pub fn blowfish_crypt_ctr(
        ctx: *mut blowfish_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut crate::types::c_uchar,
        stream_block: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
#[doc = " \\brief    The CCM context-type definition. The CCM context is passed"]
#[doc = "           to the APIs called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ccm_context {
    #[doc = "< The cipher context used."]
    pub cipher_ctx: cipher_context_t,
}
#[test]
fn bindgen_test_layout_ccm_context() {
    assert_eq!(
        ::core::mem::size_of::<ccm_context>(),
        64usize,
        concat!("Size of: ", stringify!(ccm_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ccm_context>(),
        4usize,
        concat!("Alignment of ", stringify!(ccm_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ccm_context>())).cipher_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ccm_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
}
impl Default for ccm_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified CCM context,"]
    #[doc = "                  to make references valid, and prepare the context"]
    #[doc = "                  for mbedtls_ccm_setkey() or mbedtls_ccm_free()."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to initialize. This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_ccm_init"]
    pub fn ccm_init(ctx: *mut ccm_context);
}
extern "C" {
    #[doc = " \\brief           This function initializes the CCM context set in the"]
    #[doc = "                  \\p ctx parameter and sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to initialize. This must be an initialized"]
    #[doc = "                  context."]
    #[doc = " \\param cipher    The 128-bit block cipher to use."]
    #[doc = " \\param key       The encryption key. This must not be \\c NULL."]
    #[doc = " \\param keybits   The key size in bits. This must be acceptable by the cipher."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A CCM or cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_ccm_setkey"]
    pub fn ccm_setkey(
        ctx: *mut ccm_context,
        cipher: cipher_id_t,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function releases and clears the specified CCM context"]
    #[doc = "          and underlying cipher sub-context."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to clear. If this is \\c NULL, the function"]
    #[doc = "                  has no effect. Otherwise, this must be initialized."]
    #[link_name = "\u{1}mbedtls_ccm_free"]
    pub fn ccm_free(ctx: *mut ccm_context);
}
extern "C" {
    #[doc = " \\brief           This function encrypts a buffer using CCM."]
    #[doc = ""]
    #[doc = " \\note            The tag is written to a separate buffer. To concatenate"]
    #[doc = "                  the \\p tag with the \\p output, as done in <em>RFC-3610:"]
    #[doc = "                  Counter with CBC-MAC (CCM)</em>, use"]
    #[doc = "                  \\p tag = \\p output + \\p length, and make sure that the"]
    #[doc = "                  output buffer is at least \\p length + \\p tag_len wide."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to use for encryption. This must be"]
    #[doc = "                  initialized and bound to a key."]
    #[doc = " \\param length    The length of the input data in Bytes."]
    #[doc = " \\param iv        The initialization vector (nonce). This must be a readable"]
    #[doc = "                  buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,"]
    #[doc = "                  or 13. The length L of the message length field is"]
    #[doc = "                  15 - \\p iv_len."]
    #[doc = " \\param add       The additional data field. If \\p add_len is greater than"]
    #[doc = "                  zero, \\p add must be a readable buffer of at least that"]
    #[doc = "                  length."]
    #[doc = " \\param add_len   The length of additional data in Bytes."]
    #[doc = "                  This must be less than `2^16 - 2^8`."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, \\p input must be a readable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param output    The buffer holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, \\p output must be a writable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param tag       The buffer holding the authentication field. This must be a"]
    #[doc = "                  readable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the authentication field to generate in Bytes:"]
    #[doc = "                  4, 6, 8, 10, 12, 14 or 16."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A CCM or cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_ccm_encrypt_and_tag"]
    pub fn ccm_encrypt_and_tag(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        add: *const crate::types::c_uchar,
        add_len: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        tag: *mut crate::types::c_uchar,
        tag_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts a buffer using CCM*."]
    #[doc = ""]
    #[doc = " \\note            The tag is written to a separate buffer. To concatenate"]
    #[doc = "                  the \\p tag with the \\p output, as done in <em>RFC-3610:"]
    #[doc = "                  Counter with CBC-MAC (CCM)</em>, use"]
    #[doc = "                  \\p tag = \\p output + \\p length, and make sure that the"]
    #[doc = "                  output buffer is at least \\p length + \\p tag_len wide."]
    #[doc = ""]
    #[doc = " \\note            When using this function in a variable tag length context,"]
    #[doc = "                  the tag length has to be encoded into the \\p iv passed to"]
    #[doc = "                  this function."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to use for encryption. This must be"]
    #[doc = "                  initialized and bound to a key."]
    #[doc = " \\param length    The length of the input data in Bytes."]
    #[doc = " \\param iv        The initialization vector (nonce). This must be a readable"]
    #[doc = "                  buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,"]
    #[doc = "                  or 13. The length L of the message length field is"]
    #[doc = "                  15 - \\p iv_len."]
    #[doc = " \\param add       The additional data field. This must be a readable buffer of"]
    #[doc = "                  at least \\p add_len Bytes."]
    #[doc = " \\param add_len   The length of additional data in Bytes."]
    #[doc = "                  This must be less than 2^16 - 2^8."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, \\p input must be a readable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param output    The buffer holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, \\p output must be a writable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param tag       The buffer holding the authentication field. This must be a"]
    #[doc = "                  readable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the authentication field to generate in Bytes:"]
    #[doc = "                  0, 4, 6, 8, 10, 12, 14 or 16."]
    #[doc = ""]
    #[doc = " \\warning         Passing \\c 0 as \\p tag_len means that the message is no"]
    #[doc = "                  longer authenticated."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A CCM or cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_ccm_star_encrypt_and_tag"]
    pub fn ccm_star_encrypt_and_tag(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        add: *const crate::types::c_uchar,
        add_len: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        tag: *mut crate::types::c_uchar,
        tag_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a CCM authenticated decryption of a"]
    #[doc = "                  buffer."]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to use for decryption. This must be"]
    #[doc = "                  initialized and bound to a key."]
    #[doc = " \\param length    The length of the input data in Bytes."]
    #[doc = " \\param iv        The initialization vector (nonce). This must be a readable"]
    #[doc = "                  buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,"]
    #[doc = "                  or 13. The length L of the message length field is"]
    #[doc = "                  15 - \\p iv_len."]
    #[doc = " \\param add       The additional data field. This must be a readable buffer"]
    #[doc = "                  of at least that \\p add_len Bytes.."]
    #[doc = " \\param add_len   The length of additional data in Bytes."]
    #[doc = "                  This must be less than 2^16 - 2^8."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, \\p input must be a readable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param output    The buffer holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, \\p output must be a writable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param tag       The buffer holding the authentication field. This must be a"]
    #[doc = "                  readable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the authentication field to generate in Bytes:"]
    #[doc = "                  4, 6, 8, 10, 12, 14 or 16."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success. This indicates that the message is authentic."]
    #[doc = " \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match."]
    #[doc = " \\return          A cipher-specific error code on calculation failure."]
    #[link_name = "\u{1}mbedtls_ccm_auth_decrypt"]
    pub fn ccm_auth_decrypt(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        add: *const crate::types::c_uchar,
        add_len: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        tag: *const crate::types::c_uchar,
        tag_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a CCM* authenticated decryption of a"]
    #[doc = "                  buffer."]
    #[doc = ""]
    #[doc = " \\note            When using this function in a variable tag length context,"]
    #[doc = "                  the tag length has to be decoded from \\p iv and passed to"]
    #[doc = "                  this function as \\p tag_len. (\\p tag needs to be adjusted"]
    #[doc = "                  accordingly.)"]
    #[doc = ""]
    #[doc = " \\param ctx       The CCM context to use for decryption. This must be"]
    #[doc = "                  initialized and bound to a key."]
    #[doc = " \\param length    The length of the input data in Bytes."]
    #[doc = " \\param iv        The initialization vector (nonce). This must be a readable"]
    #[doc = "                  buffer of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,"]
    #[doc = "                  or 13. The length L of the message length field is"]
    #[doc = "                  15 - \\p iv_len."]
    #[doc = " \\param add       The additional data field. This must be a readable buffer of"]
    #[doc = "                  at least that \\p add_len Bytes."]
    #[doc = " \\param add_len   The length of additional data in Bytes."]
    #[doc = "                  This must be less than 2^16 - 2^8."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, \\p input must be a readable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param output    The buffer holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, \\p output must be a writable buffer of at least"]
    #[doc = "                  that length."]
    #[doc = " \\param tag       The buffer holding the authentication field. This must be a"]
    #[doc = "                  readable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the authentication field in Bytes."]
    #[doc = "                  0, 4, 6, 8, 10, 12, 14 or 16."]
    #[doc = ""]
    #[doc = " \\warning         Passing \\c 0 as \\p tag_len means that the message is nos"]
    #[doc = "                  longer authenticated."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match."]
    #[doc = " \\return          A cipher-specific error code on calculation failure."]
    #[link_name = "\u{1}mbedtls_ccm_star_auth_decrypt"]
    pub fn ccm_star_auth_decrypt(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        add: *const crate::types::c_uchar,
        add_len: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        tag: *const crate::types::c_uchar,
        tag_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          The CCM checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_ccm_self_test"]
    pub fn ccm_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          CAMELLIA context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct camellia_context {
    #[doc = "<  number of rounds"]
    pub nr: crate::types::c_int,
    #[doc = "<  CAMELLIA round keys"]
    pub rk: [u32; 68usize],
}
#[test]
fn bindgen_test_layout_camellia_context() {
    assert_eq!(
        ::core::mem::size_of::<camellia_context>(),
        276usize,
        concat!("Size of: ", stringify!(camellia_context))
    );
    assert_eq!(
        ::core::mem::align_of::<camellia_context>(),
        4usize,
        concat!("Alignment of ", stringify!(camellia_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<camellia_context>())).nr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_context),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<camellia_context>())).rk as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_context),
            "::",
            stringify!(rk)
        )
    );
}
impl Default for camellia_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Initialize a CAMELLIA context."]
    #[doc = ""]
    #[doc = " \\param ctx      The CAMELLIA context to be initialized."]
    #[doc = "                 This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_camellia_init"]
    pub fn camellia_init(ctx: *mut camellia_context);
}
extern "C" {
    #[doc = " \\brief          Clear a CAMELLIA context."]
    #[doc = ""]
    #[doc = " \\param ctx      The CAMELLIA context to be cleared. This may be \\c NULL,"]
    #[doc = "                 in which case this function returns immediately. If it is not"]
    #[doc = "                 \\c NULL, it must be initialized."]
    #[link_name = "\u{1}mbedtls_camellia_free"]
    pub fn camellia_free(ctx: *mut camellia_context);
}
extern "C" {
    #[doc = " \\brief          Perform a CAMELLIA key schedule operation for encryption."]
    #[doc = ""]
    #[doc = " \\param ctx      The CAMELLIA context to use. This must be initialized."]
    #[doc = " \\param key      The encryption key to use. This must be a readable buffer"]
    #[doc = "                 of size \\p keybits Bits."]
    #[doc = " \\param keybits  The length of \\p key in Bits. This must be either \\c 128,"]
    #[doc = "                 \\c 192 or \\c 256."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_camellia_setkey_enc"]
    pub fn camellia_setkey_enc(
        ctx: *mut camellia_context,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a CAMELLIA key schedule operation for decryption."]
    #[doc = ""]
    #[doc = " \\param ctx      The CAMELLIA context to use. This must be initialized."]
    #[doc = " \\param key      The decryption key. This must be a readable buffer"]
    #[doc = "                 of size \\p keybits Bits."]
    #[doc = " \\param keybits  The length of \\p key in Bits. This must be either \\c 128,"]
    #[doc = "                 \\c 192 or \\c 256."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_camellia_setkey_dec"]
    pub fn camellia_setkey_dec(
        ctx: *mut camellia_context,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a CAMELLIA-ECB block encryption/decryption operation."]
    #[doc = ""]
    #[doc = " \\param ctx      The CAMELLIA context to use. This must be initialized"]
    #[doc = "                 and bound to a key."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT."]
    #[doc = " \\param input    The input block. This must be a readable buffer"]
    #[doc = "                 of size \\c 16 Bytes."]
    #[doc = " \\param output   The output block. This must be a writable buffer"]
    #[doc = "                 of size \\c 16 Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_camellia_crypt_ecb"]
    pub fn camellia_crypt_ecb(
        ctx: *mut camellia_context,
        mode: crate::types::c_int,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a CAMELLIA-CBC buffer encryption/decryption operation."]
    #[doc = ""]
    #[doc = " \\note           Upon exit, the content of the IV is updated so that you can"]
    #[doc = "                 call the function same function again on the following"]
    #[doc = "                 block(s) of data and get the same result as if it was"]
    #[doc = "                 encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "                 If on the other hand you need to retain the contents of the"]
    #[doc = "                 IV, you should either save it manually or use the cipher"]
    #[doc = "                 module instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The CAMELLIA context to use. This must be initialized"]
    #[doc = "                 and bound to a key."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT."]
    #[doc = " \\param length   The length in Bytes of the input data \\p input."]
    #[doc = "                 This must be a multiple of \\c 16 Bytes."]
    #[doc = " \\param iv       The initialization vector. This must be a read/write buffer"]
    #[doc = "                 of length \\c 16 Bytes. It is updated to allow streaming"]
    #[doc = "                 use as explained above."]
    #[doc = " \\param input    The buffer holding the input data. This must point to a"]
    #[doc = "                 readable buffer of length \\p length Bytes."]
    #[doc = " \\param output   The buffer holding the output data. This must point to a"]
    #[doc = "                 writable buffer of length \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_camellia_crypt_cbc"]
    pub fn camellia_crypt_cbc(
        ctx: *mut camellia_context,
        mode: crate::types::c_int,
        length: usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a CAMELLIA-CFB128 buffer encryption/decryption"]
    #[doc = "                 operation."]
    #[doc = ""]
    #[doc = " \\note           Due to the nature of CFB mode, you should use the same"]
    #[doc = "                 key for both encryption and decryption. In particular, calls"]
    #[doc = "                 to this function should be preceded by a key-schedule via"]
    #[doc = "                 mbedtls_camellia_setkey_enc() regardless of whether \\p mode"]
    #[doc = "                 is #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT."]
    #[doc = ""]
    #[doc = " \\note           Upon exit, the content of the IV is updated so that you can"]
    #[doc = "                 call the function same function again on the following"]
    #[doc = "                 block(s) of data and get the same result as if it was"]
    #[doc = "                 encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "                 If on the other hand you need to retain the contents of the"]
    #[doc = "                 IV, you should either save it manually or use the cipher"]
    #[doc = "                 module instead."]
    #[doc = ""]
    #[doc = " \\param ctx      The CAMELLIA context to use. This must be initialized"]
    #[doc = "                 and bound to a key."]
    #[doc = " \\param mode     The mode of operation. This must be either"]
    #[doc = "                 #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT."]
    #[doc = " \\param length   The length of the input data \\p input. Any value is allowed."]
    #[doc = " \\param iv_off   The current offset in the IV. This must be smaller"]
    #[doc = "                 than \\c 16 Bytes. It is updated after this call to allow"]
    #[doc = "                 the aforementioned streaming usage."]
    #[doc = " \\param iv       The initialization vector. This must be a read/write buffer"]
    #[doc = "                 of length \\c 16 Bytes. It is updated after this call to"]
    #[doc = "                 allow the aforementioned streaming usage."]
    #[doc = " \\param input    The buffer holding the input data. This must be a readable"]
    #[doc = "                 buffer of size \\p length Bytes."]
    #[doc = " \\param output   The buffer to hold the output data. This must be a writable"]
    #[doc = "                 buffer of length \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 if successful."]
    #[doc = " \\return         A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_camellia_crypt_cfb128"]
    pub fn camellia_crypt_cfb128(
        ctx: *mut camellia_context,
        mode: crate::types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief      Perform a CAMELLIA-CTR buffer encryption/decryption operation."]
    #[doc = ""]
    #[doc = " *note       Due to the nature of CTR mode, you should use the same"]
    #[doc = "             key for both encryption and decryption. In particular, calls"]
    #[doc = "             to this function should be preceded by a key-schedule via"]
    #[doc = "             mbedtls_camellia_setkey_enc() regardless of whether \\p mode"]
    #[doc = "             is #MBEDTLS_CAMELLIA_ENCRYPT or #MBEDTLS_CAMELLIA_DECRYPT."]
    #[doc = ""]
    #[doc = " \\warning    You must never reuse a nonce value with the same key. Doing so"]
    #[doc = "             would void the encryption for the two messages encrypted with"]
    #[doc = "             the same nonce and key."]
    #[doc = ""]
    #[doc = "             There are two common strategies for managing nonces with CTR:"]
    #[doc = ""]
    #[doc = "             1. You can handle everything as a single message processed over"]
    #[doc = "             successive calls to this function. In that case, you want to"]
    #[doc = "             set \\p nonce_counter and \\p nc_off to 0 for the first call, and"]
    #[doc = "             then preserve the values of \\p nonce_counter, \\p nc_off and \\p"]
    #[doc = "             stream_block across calls to this function as they will be"]
    #[doc = "             updated by this function."]
    #[doc = ""]
    #[doc = "             With this strategy, you must not encrypt more than 2**128"]
    #[doc = "             blocks of data with the same key."]
    #[doc = ""]
    #[doc = "             2. You can encrypt separate messages by dividing the \\p"]
    #[doc = "             nonce_counter buffer in two areas: the first one used for a"]
    #[doc = "             per-message nonce, handled by yourself, and the second one"]
    #[doc = "             updated by this function internally."]
    #[doc = ""]
    #[doc = "             For example, you might reserve the first \\c 12 Bytes for the"]
    #[doc = "             per-message nonce, and the last \\c 4 Bytes for internal use."]
    #[doc = "             In that case, before calling this function on a new message you"]
    #[doc = "             need to set the first \\c 12 Bytes of \\p nonce_counter to your"]
    #[doc = "             chosen nonce value, the last four to \\c 0, and \\p nc_off to \\c 0"]
    #[doc = "             (which will cause \\p stream_block to be ignored). That way, you"]
    #[doc = "             can encrypt at most \\c 2**96 messages of up to \\c 2**32 blocks"]
    #[doc = "             each  with the same key."]
    #[doc = ""]
    #[doc = "             The per-message nonce (or information sufficient to reconstruct"]
    #[doc = "             it) needs to be communicated with the ciphertext and must be"]
    #[doc = "             unique. The recommended way to ensure uniqueness is to use a"]
    #[doc = "             message counter. An alternative is to generate random nonces,"]
    #[doc = "             but this limits the number of messages that can be securely"]
    #[doc = "             encrypted: for example, with 96-bit random nonces, you should"]
    #[doc = "             not encrypt more than 2**32 messages with the same key."]
    #[doc = ""]
    #[doc = "             Note that for both stategies, sizes are measured in blocks and"]
    #[doc = "             that a CAMELLIA block is \\c 16 Bytes."]
    #[doc = ""]
    #[doc = " \\warning    Upon return, \\p stream_block contains sensitive data. Its"]
    #[doc = "             content must not be written to insecure storage and should be"]
    #[doc = "             securely discarded as soon as it's no longer needed."]
    #[doc = ""]
    #[doc = " \\param ctx           The CAMELLIA context to use. This must be initialized"]
    #[doc = "                      and bound to a key."]
    #[doc = " \\param length        The length of the input data \\p input in Bytes."]
    #[doc = "                      Any value is allowed."]
    #[doc = " \\param nc_off        The offset in the current \\p stream_block (for resuming"]
    #[doc = "                      within current cipher stream). The offset pointer to"]
    #[doc = "                      should be \\c 0 at the start of a stream. It is updated"]
    #[doc = "                      at the end of this call."]
    #[doc = " \\param nonce_counter The 128-bit nonce and counter. This must be a read/write"]
    #[doc = "                      buffer of length \\c 16 Bytes."]
    #[doc = " \\param stream_block  The saved stream-block for resuming. This must be a"]
    #[doc = "                      read/write buffer of length \\c 16 Bytes."]
    #[doc = " \\param input         The input data stream. This must be a readable buffer of"]
    #[doc = "                      size \\p length Bytes."]
    #[doc = " \\param output        The output data stream. This must be a writable buffer"]
    #[doc = "                      of size \\p length Bytes."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 if successful."]
    #[doc = " \\return              A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_camellia_crypt_ctr"]
    pub fn camellia_crypt_ctr(
        ctx: *mut camellia_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut crate::types::c_uchar,
        stream_block: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[link_name = "\u{1}mbedtls_camellia_self_test"]
    pub fn camellia_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct chacha20_context {
    pub state: [u32; 16usize],
    #[doc = " The state (before round operations)."]
    pub keystream8: [u8; 64usize],
    #[doc = " Leftover keystream bytes."]
    pub keystream_bytes_used: usize,
}
#[test]
fn bindgen_test_layout_chacha20_context() {
    assert_eq!(
        ::core::mem::size_of::<chacha20_context>(),
        132usize,
        concat!("Size of: ", stringify!(chacha20_context))
    );
    assert_eq!(
        ::core::mem::align_of::<chacha20_context>(),
        4usize,
        concat!("Alignment of ", stringify!(chacha20_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chacha20_context>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(chacha20_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chacha20_context>())).keystream8 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(chacha20_context),
            "::",
            stringify!(keystream8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<chacha20_context>())).keystream_bytes_used as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(chacha20_context),
            "::",
            stringify!(keystream_bytes_used)
        )
    );
}
impl Default for chacha20_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified ChaCha20 context."]
    #[doc = ""]
    #[doc = "                  It must be the first API called before using"]
    #[doc = "                  the context."]
    #[doc = ""]
    #[doc = "                  It is usually followed by calls to"]
    #[doc = "                  \\c mbedtls_chacha20_setkey() and"]
    #[doc = "                  \\c mbedtls_chacha20_starts(), then one or more calls to"]
    #[doc = "                  to \\c mbedtls_chacha20_update(), and finally to"]
    #[doc = "                  \\c mbedtls_chacha20_free()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to initialize."]
    #[doc = "                  This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_chacha20_init"]
    pub fn chacha20_init(ctx: *mut chacha20_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified"]
    #[doc = "                  ChaCha20 context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to clear. This may be \\c NULL,"]
    #[doc = "                  in which case this function is a no-op. If it is not"]
    #[doc = "                  \\c NULL, it must point to an initialized context."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_chacha20_free"]
    pub fn chacha20_free(ctx: *mut chacha20_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the encryption/decryption key."]
    #[doc = ""]
    #[doc = " \\note            After using this function, you must also call"]
    #[doc = "                  \\c mbedtls_chacha20_starts() to set a nonce before you"]
    #[doc = "                  start encrypting/decrypting data with"]
    #[doc = "                  \\c mbedtls_chacha_update()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to which the key should be bound."]
    #[doc = "                  It must be initialized."]
    #[doc = " \\param key       The encryption/decryption key. This must be \\c 32 Bytes"]
    #[doc = "                  in length."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or key is NULL."]
    #[link_name = "\u{1}mbedtls_chacha20_setkey"]
    pub fn chacha20_setkey(
        ctx: *mut chacha20_context,
        key: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the nonce and initial counter value."]
    #[doc = ""]
    #[doc = " \\note            A ChaCha20 context can be re-used with the same key by"]
    #[doc = "                  calling this function to change the nonce."]
    #[doc = ""]
    #[doc = " \\warning         You must never use the same nonce twice with the same key."]
    #[doc = "                  This would void any confidentiality guarantees for the"]
    #[doc = "                  messages encrypted with the same nonce and key."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to which the nonce should be bound."]
    #[doc = "                  It must be initialized and bound to a key."]
    #[doc = " \\param nonce     The nonce. This must be \\c 12 Bytes in size."]
    #[doc = " \\param counter   The initial counter value. This is usually \\c 0."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or nonce is"]
    #[doc = "                  NULL."]
    #[link_name = "\u{1}mbedtls_chacha20_starts"]
    pub fn chacha20_starts(
        ctx: *mut chacha20_context,
        nonce: *const crate::types::c_uchar,
        counter: u32,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts or decrypts data."]
    #[doc = ""]
    #[doc = "                  Since ChaCha20 is a stream cipher, the same operation is"]
    #[doc = "                  used for encrypting and decrypting data."]
    #[doc = ""]
    #[doc = " \\note            The \\p input and \\p output pointers must either be equal or"]
    #[doc = "                  point to non-overlapping buffers."]
    #[doc = ""]
    #[doc = " \\note            \\c mbedtls_chacha20_setkey() and"]
    #[doc = "                  \\c mbedtls_chacha20_starts() must be called at least once"]
    #[doc = "                  to setup the context before this function can be called."]
    #[doc = ""]
    #[doc = " \\note            This function can be called multiple times in a row in"]
    #[doc = "                  order to encrypt of decrypt data piecewise with the same"]
    #[doc = "                  key and nonce."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20 context to use for encryption or decryption."]
    #[doc = "                  It must be initialized and bound to a key and nonce."]
    #[doc = " \\param size      The length of the input data in Bytes."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = "                  This pointer can be \\c NULL if `size == 0`."]
    #[doc = " \\param output    The buffer holding the output data."]
    #[doc = "                  This must be able to hold \\p size Bytes."]
    #[doc = "                  This pointer can be \\c NULL if `size == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_chacha20_update"]
    pub fn chacha20_update(
        ctx: *mut chacha20_context,
        size: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts or decrypts data with ChaCha20 and"]
    #[doc = "                  the given key and nonce."]
    #[doc = ""]
    #[doc = "                  Since ChaCha20 is a stream cipher, the same operation is"]
    #[doc = "                  used for encrypting and decrypting data."]
    #[doc = ""]
    #[doc = " \\warning         You must never use the same (key, nonce) pair more than"]
    #[doc = "                  once. This would void any confidentiality guarantees for"]
    #[doc = "                  the messages encrypted with the same nonce and key."]
    #[doc = ""]
    #[doc = " \\note            The \\p input and \\p output pointers must either be equal or"]
    #[doc = "                  point to non-overlapping buffers."]
    #[doc = ""]
    #[doc = " \\param key       The encryption/decryption key."]
    #[doc = "                  This must be \\c 32 Bytes in length."]
    #[doc = " \\param nonce     The nonce. This must be \\c 12 Bytes in size."]
    #[doc = " \\param counter   The initial counter value. This is usually \\c 0."]
    #[doc = " \\param size      The length of the input data in Bytes."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = "                  This pointer can be \\c NULL if `size == 0`."]
    #[doc = " \\param output    The buffer holding the output data."]
    #[doc = "                  This must be able to hold \\p size Bytes."]
    #[doc = "                  This pointer can be \\c NULL if `size == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_chacha20_crypt"]
    pub fn chacha20_crypt(
        key: *const crate::types::c_uchar,
        nonce: *const crate::types::c_uchar,
        counter: u32,
        size: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           The ChaCha20 checkup routine."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_chacha20_self_test"]
    pub fn chacha20_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct poly1305_context {
    pub r: [u32; 4usize],
    #[doc = " The value for 'r' (low 128 bits of the key)."]
    pub s: [u32; 4usize],
    #[doc = " The value for 's' (high 128 bits of the key)."]
    pub acc: [u32; 5usize],
    #[doc = " The accumulator number."]
    pub queue: [u8; 16usize],
    #[doc = " The current partial block of data."]
    pub queue_len: usize,
}
#[test]
fn bindgen_test_layout_poly1305_context() {
    assert_eq!(
        ::core::mem::size_of::<poly1305_context>(),
        72usize,
        concat!("Size of: ", stringify!(poly1305_context))
    );
    assert_eq!(
        ::core::mem::align_of::<poly1305_context>(),
        4usize,
        concat!("Alignment of ", stringify!(poly1305_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).s as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).acc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(acc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).queue as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).queue_len as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(queue_len)
        )
    );
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified Poly1305 context."]
    #[doc = ""]
    #[doc = "                  It must be the first API called before using"]
    #[doc = "                  the context."]
    #[doc = ""]
    #[doc = "                  It is usually followed by a call to"]
    #[doc = "                  \\c mbedtls_poly1305_starts(), then one or more calls to"]
    #[doc = "                  \\c mbedtls_poly1305_update(), then one call to"]
    #[doc = "                  \\c mbedtls_poly1305_finish(), then finally"]
    #[doc = "                  \\c mbedtls_poly1305_free()."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to initialize. This must"]
    #[doc = "                  not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_poly1305_init"]
    pub fn poly1305_init(ctx: *mut poly1305_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified"]
    #[doc = "                  Poly1305 context."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to clear. This may be \\c NULL, in which"]
    #[doc = "                  case this function is a no-op. If it is not \\c NULL, it must"]
    #[doc = "                  point to an initialized Poly1305 context."]
    #[link_name = "\u{1}mbedtls_poly1305_free"]
    pub fn poly1305_free(ctx: *mut poly1305_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the one-time authentication key."]
    #[doc = ""]
    #[doc = " \\warning         The key must be unique and unpredictable for each"]
    #[doc = "                  invocation of Poly1305."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to which the key should be bound."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_poly1305_starts"]
    pub fn poly1305_starts(
        ctx: *mut poly1305_context,
        key: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This functions feeds an input buffer into an ongoing"]
    #[doc = "                  Poly1305 computation."]
    #[doc = ""]
    #[doc = "                  It is called between \\c mbedtls_cipher_poly1305_starts() and"]
    #[doc = "                  \\c mbedtls_cipher_poly1305_finish()."]
    #[doc = "                  It can be called repeatedly to process a stream of data."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to use for the Poly1305 operation."]
    #[doc = "                  This must be initialized and bound to a key."]
    #[doc = " \\param ilen      The length of the input data in Bytes."]
    #[doc = "                  Any value is accepted."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_poly1305_update"]
    pub fn poly1305_update(
        ctx: *mut poly1305_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates the Poly1305 Message"]
    #[doc = "                  Authentication Code (MAC)."]
    #[doc = ""]
    #[doc = " \\param ctx       The Poly1305 context to use for the Poly1305 operation."]
    #[doc = "                  This must be initialized and bound to a key."]
    #[doc = " \\param mac       The buffer to where the MAC is written. This must"]
    #[doc = "                  be a writable buffer of length \\c 16 Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_poly1305_finish"]
    pub fn poly1305_finish(
        ctx: *mut poly1305_context,
        mac: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function calculates the Poly1305 MAC of the input"]
    #[doc = "                  buffer with the provided key."]
    #[doc = ""]
    #[doc = " \\warning         The key must be unique and unpredictable for each"]
    #[doc = "                  invocation of Poly1305."]
    #[doc = ""]
    #[doc = " \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key."]
    #[doc = " \\param ilen      The length of the input data in Bytes."]
    #[doc = "                  Any value is accepted."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = " \\param mac       The buffer to where the MAC is written. This must be"]
    #[doc = "                  a writable buffer of length \\c 16 Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_poly1305_mac"]
    pub fn poly1305_mac(
        key: *const crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        ilen: usize,
        mac: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           The Poly1305 checkup routine."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_poly1305_self_test"]
    pub fn poly1305_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum chachapoly_mode_t {
    #[doc = "< The mode value for performing encryption."]
    CHACHAPOLY_ENCRYPT = 0,
    #[doc = "< The mode value for performing decryption."]
    CHACHAPOLY_DECRYPT = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct chachapoly_context {
    #[doc = "< The ChaCha20 context."]
    pub chacha20_ctx: chacha20_context,
    #[doc = "< The Poly1305 context."]
    pub poly1305_ctx: poly1305_context,
    #[doc = "< The length (bytes) of the Additional Authenticated Data."]
    pub aad_len: u64,
    #[doc = "< The length (bytes) of the ciphertext."]
    pub ciphertext_len: u64,
    #[doc = "< The current state of the context."]
    pub state: crate::types::c_int,
    #[doc = "< Cipher mode (encrypt or decrypt)."]
    pub mode: chachapoly_mode_t,
}
#[test]
fn bindgen_test_layout_chachapoly_context() {
    assert_eq!(
        ::core::mem::size_of::<chachapoly_context>(),
        232usize,
        concat!("Size of: ", stringify!(chachapoly_context))
    );
    assert_eq!(
        ::core::mem::align_of::<chachapoly_context>(),
        8usize,
        concat!("Alignment of ", stringify!(chachapoly_context))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<chachapoly_context>())).chacha20_ctx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(chacha20_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<chachapoly_context>())).poly1305_ctx as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(poly1305_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chachapoly_context>())).aad_len as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(aad_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<chachapoly_context>())).ciphertext_len as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(ciphertext_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chachapoly_context>())).state as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chachapoly_context>())).mode as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for chachapoly_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified ChaCha20-Poly1305 context."]
    #[doc = ""]
    #[doc = "                  It must be the first API called before using"]
    #[doc = "                  the context. It must be followed by a call to"]
    #[doc = "                  \\c mbedtls_chachapoly_setkey() before any operation can be"]
    #[doc = "                  done, and to \\c mbedtls_chachapoly_free() once all"]
    #[doc = "                  operations with that context have been finished."]
    #[doc = ""]
    #[doc = "                  In order to encrypt or decrypt full messages at once, for"]
    #[doc = "                  each message you should make a single call to"]
    #[doc = "                  \\c mbedtls_chachapoly_crypt_and_tag() or"]
    #[doc = "                  \\c mbedtls_chachapoly_auth_decrypt()."]
    #[doc = ""]
    #[doc = "                  In order to encrypt messages piecewise, for each"]
    #[doc = "                  message you should make a call to"]
    #[doc = "                  \\c mbedtls_chachapoly_starts(), then 0 or more calls to"]
    #[doc = "                  \\c mbedtls_chachapoly_update_aad(), then 0 or more calls to"]
    #[doc = "                  \\c mbedtls_chachapoly_update(), then one call to"]
    #[doc = "                  \\c mbedtls_chachapoly_finish()."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged! Always"]
    #[doc = "                  use \\c mbedtls_chachapoly_auth_decrypt() when possible!"]
    #[doc = ""]
    #[doc = "                  If however this is not possible because the data is too"]
    #[doc = "                  large to fit in memory, you need to:"]
    #[doc = ""]
    #[doc = "                  - call \\c mbedtls_chachapoly_starts() and (if needed)"]
    #[doc = "                  \\c mbedtls_chachapoly_update_aad() as above,"]
    #[doc = "                  - call \\c mbedtls_chachapoly_update() multiple times and"]
    #[doc = "                  ensure its output (the plaintext) is NOT used in any other"]
    #[doc = "                  way than placing it in temporary storage at this point,"]
    #[doc = "                  - call \\c mbedtls_chachapoly_finish() to compute the"]
    #[doc = "                  authentication tag and compared it in constant time to the"]
    #[doc = "                  tag received with the ciphertext."]
    #[doc = ""]
    #[doc = "                  If the tags are not equal, you must immediately discard"]
    #[doc = "                  all previous outputs of \\c mbedtls_chachapoly_update(),"]
    #[doc = "                  otherwise you can now safely use the plaintext."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChachaPoly context to initialize. Must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_chachapoly_init"]
    pub fn chachapoly_init(ctx: *mut chachapoly_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified"]
    #[doc = "                  ChaCha20-Poly1305 context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChachaPoly context to clear. This may be \\c NULL, in which"]
    #[doc = "                  case this function is a no-op."]
    #[link_name = "\u{1}mbedtls_chachapoly_free"]
    pub fn chachapoly_free(ctx: *mut chachapoly_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the ChaCha20-Poly1305"]
    #[doc = "                  symmetric encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to which the key should be"]
    #[doc = "                  bound. This must be initialized."]
    #[doc = " \\param key       The \\c 256 Bit (\\c 32 Bytes) key."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_chachapoly_setkey"]
    pub fn chachapoly_setkey(
        ctx: *mut chachapoly_context,
        key: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a ChaCha20-Poly1305 encryption or"]
    #[doc = "                  decryption operation."]
    #[doc = ""]
    #[doc = " \\warning         You must never use the same nonce twice with the same key."]
    #[doc = "                  This would void any confidentiality and authenticity"]
    #[doc = "                  guarantees for the messages encrypted with the same nonce"]
    #[doc = "                  and key."]
    #[doc = ""]
    #[doc = " \\note            If the context is being used for AAD only (no data to"]
    #[doc = "                  encrypt or decrypt) then \\p mode can be set to any value."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged, see the"]
    #[doc = "                  warning on \\c mbedtls_chachapoly_init()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context. This must be initialized"]
    #[doc = "                  and bound to a key."]
    #[doc = " \\param nonce     The nonce/IV to use for the message."]
    #[doc = "                  This must be a redable buffer of length \\c 12 Bytes."]
    #[doc = " \\param mode      The operation to perform: #MBEDTLS_CHACHAPOLY_ENCRYPT or"]
    #[doc = "                  #MBEDTLS_CHACHAPOLY_DECRYPT (discouraged, see warning)."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_chachapoly_starts"]
    pub fn chachapoly_starts(
        ctx: *mut chachapoly_context,
        nonce: *const crate::types::c_uchar,
        mode: chachapoly_mode_t,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds additional data to be authenticated"]
    #[doc = "                  into an ongoing ChaCha20-Poly1305 operation."]
    #[doc = ""]
    #[doc = "                  The Additional Authenticated Data (AAD), also called"]
    #[doc = "                  Associated Data (AD) is only authenticated but not"]
    #[doc = "                  encrypted nor included in the encrypted output. It is"]
    #[doc = "                  usually transmitted separately from the ciphertext or"]
    #[doc = "                  computed locally by each party."]
    #[doc = ""]
    #[doc = " \\note            This function is called before data is encrypted/decrypted."]
    #[doc = "                  I.e. call this function to process the AAD before calling"]
    #[doc = "                  \\c mbedtls_chachapoly_update()."]
    #[doc = ""]
    #[doc = "                  You may call this function multiple times to process"]
    #[doc = "                  an arbitrary amount of AAD. It is permitted to call"]
    #[doc = "                  this function 0 times, if no AAD is used."]
    #[doc = ""]
    #[doc = "                  This function cannot be called any more if data has"]
    #[doc = "                  been processed by \\c mbedtls_chachapoly_update(),"]
    #[doc = "                  or if the context has been finished."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged, see the"]
    #[doc = "                  warning on \\c mbedtls_chachapoly_init()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context. This must be initialized"]
    #[doc = "                  and bound to a key."]
    #[doc = " \\param aad_len   The length in Bytes of the AAD. The length has no"]
    #[doc = "                  restrictions."]
    #[doc = " \\param aad       Buffer containing the AAD."]
    #[doc = "                  This pointer can be \\c NULL if `aad_len == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA"]
    #[doc = "                  if \\p ctx or \\p aad are NULL."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE"]
    #[doc = "                  if the operations has not been started or has been"]
    #[doc = "                  finished, or if the AAD has been finished."]
    #[link_name = "\u{1}mbedtls_chachapoly_update_aad"]
    pub fn chachapoly_update_aad(
        ctx: *mut chachapoly_context,
        aad: *const crate::types::c_uchar,
        aad_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Thus function feeds data to be encrypted or decrypted"]
    #[doc = "                  into an on-going ChaCha20-Poly1305"]
    #[doc = "                  operation."]
    #[doc = ""]
    #[doc = "                  The direction (encryption or decryption) depends on the"]
    #[doc = "                  mode that was given when calling"]
    #[doc = "                  \\c mbedtls_chachapoly_starts()."]
    #[doc = ""]
    #[doc = "                  You may call this function multiple times to process"]
    #[doc = "                  an arbitrary amount of data. It is permitted to call"]
    #[doc = "                  this function 0 times, if no data is to be encrypted"]
    #[doc = "                  or decrypted."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged, see the"]
    #[doc = "                  warning on \\c mbedtls_chachapoly_init()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized."]
    #[doc = " \\param len       The length (in bytes) of the data to encrypt or decrypt."]
    #[doc = " \\param input     The buffer containing the data to encrypt or decrypt."]
    #[doc = "                  This pointer can be \\c NULL if `len == 0`."]
    #[doc = " \\param output    The buffer to where the encrypted or decrypted data is"]
    #[doc = "                  written. This must be able to hold \\p len bytes."]
    #[doc = "                  This pointer can be \\c NULL if `len == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE"]
    #[doc = "                  if the operation has not been started or has been"]
    #[doc = "                  finished."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_chachapoly_update"]
    pub fn chachapoly_update(
        ctx: *mut chachapoly_context,
        len: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finished the ChaCha20-Poly1305 operation and"]
    #[doc = "                  generates the MAC (authentication tag)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized."]
    #[doc = " \\param mac       The buffer to where the 128-bit (16 bytes) MAC is written."]
    #[doc = ""]
    #[doc = " \\warning         Decryption with the piecewise API is discouraged, see the"]
    #[doc = "                  warning on \\c mbedtls_chachapoly_init()."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE"]
    #[doc = "                  if the operation has not been started or has been"]
    #[doc = "                  finished."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_chachapoly_finish"]
    pub fn chachapoly_finish(
        ctx: *mut chachapoly_context,
        mac: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a complete ChaCha20-Poly1305"]
    #[doc = "                  authenticated encryption with the previously-set key."]
    #[doc = ""]
    #[doc = " \\note            Before using this function, you must set the key with"]
    #[doc = "                  \\c mbedtls_chachapoly_setkey()."]
    #[doc = ""]
    #[doc = " \\warning         You must never use the same nonce twice with the same key."]
    #[doc = "                  This would void any confidentiality and authenticity"]
    #[doc = "                  guarantees for the messages encrypted with the same nonce"]
    #[doc = "                  and key."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to use (holds the key)."]
    #[doc = "                  This must be initialized."]
    #[doc = " \\param length    The length (in bytes) of the data to encrypt or decrypt."]
    #[doc = " \\param nonce     The 96-bit (12 bytes) nonce/IV to use."]
    #[doc = " \\param aad       The buffer containing the additional authenticated"]
    #[doc = "                  data (AAD). This pointer can be \\c NULL if `aad_len == 0`."]
    #[doc = " \\param aad_len   The length (in bytes) of the AAD data to process."]
    #[doc = " \\param input     The buffer containing the data to encrypt or decrypt."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = " \\param output    The buffer to where the encrypted or decrypted data"]
    #[doc = "                  is written. This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = " \\param tag       The buffer to where the computed 128-bit (16 bytes) MAC"]
    #[doc = "                  is written. This must not be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_chachapoly_encrypt_and_tag"]
    pub fn chachapoly_encrypt_and_tag(
        ctx: *mut chachapoly_context,
        length: usize,
        nonce: *const crate::types::c_uchar,
        aad: *const crate::types::c_uchar,
        aad_len: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        tag: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a complete ChaCha20-Poly1305"]
    #[doc = "                  authenticated decryption with the previously-set key."]
    #[doc = ""]
    #[doc = " \\note            Before using this function, you must set the key with"]
    #[doc = "                  \\c mbedtls_chachapoly_setkey()."]
    #[doc = ""]
    #[doc = " \\param ctx       The ChaCha20-Poly1305 context to use (holds the key)."]
    #[doc = " \\param length    The length (in Bytes) of the data to decrypt."]
    #[doc = " \\param nonce     The \\c 96 Bit (\\c 12 bytes) nonce/IV to use."]
    #[doc = " \\param aad       The buffer containing the additional authenticated data (AAD)."]
    #[doc = "                  This pointer can be \\c NULL if `aad_len == 0`."]
    #[doc = " \\param aad_len   The length (in bytes) of the AAD data to process."]
    #[doc = " \\param tag       The buffer holding the authentication tag."]
    #[doc = "                  This must be a readable buffer of length \\c 16 Bytes."]
    #[doc = " \\param input     The buffer containing the data to decrypt."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = " \\param output    The buffer to where the decrypted data is written."]
    #[doc = "                  This pointer can be \\c NULL if `ilen == 0`."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED"]
    #[doc = "                  if the data was not authentic."]
    #[doc = " \\return          Another negative error code on other kinds of failure."]
    #[link_name = "\u{1}mbedtls_chachapoly_auth_decrypt"]
    pub fn chachapoly_auth_decrypt(
        ctx: *mut chachapoly_context,
        length: usize,
        nonce: *const crate::types::c_uchar,
        aad: *const crate::types::c_uchar,
        aad_len: usize,
        tag: *const crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           The ChaCha20-Poly1305 checkup routine."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_chachapoly_self_test"]
    pub fn chachapoly_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " The CMAC context structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cmac_context_t {
    #[doc = " The internal state of the CMAC algorithm."]
    pub state: [crate::types::c_uchar; 16usize],
    #[doc = " Unprocessed data - either data that was not block aligned and is still"]
    #[doc = "  pending processing, or the final block."]
    pub unprocessed_block: [crate::types::c_uchar; 16usize],
    #[doc = " The length of data pending processing."]
    pub unprocessed_len: usize,
}
#[test]
fn bindgen_test_layout_cmac_context_t() {
    assert_eq!(
        ::core::mem::size_of::<cmac_context_t>(),
        36usize,
        concat!("Size of: ", stringify!(cmac_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cmac_context_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cmac_context_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmac_context_t>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmac_context_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cmac_context_t>())).unprocessed_block as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmac_context_t),
            "::",
            stringify!(unprocessed_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmac_context_t>())).unprocessed_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cmac_context_t),
            "::",
            stringify!(unprocessed_len)
        )
    );
}
extern "C" {
    #[doc = " \\brief               This function sets the CMAC key, and prepares to authenticate"]
    #[doc = "                      the input data."]
    #[doc = "                      Must be called with an initialized cipher context."]
    #[doc = ""]
    #[doc = " \\param ctx           The cipher context used for the CMAC operation, initialized"]
    #[doc = "                      as one of the following types: MBEDTLS_CIPHER_AES_128_ECB,"]
    #[doc = "                      MBEDTLS_CIPHER_AES_192_ECB, MBEDTLS_CIPHER_AES_256_ECB,"]
    #[doc = "                      or MBEDTLS_CIPHER_DES_EDE3_ECB."]
    #[doc = " \\param key           The CMAC key."]
    #[doc = " \\param keybits       The length of the CMAC key in bits."]
    #[doc = "                      Must be supported by the cipher."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              A cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_cipher_cmac_starts"]
    pub fn cipher_cmac_starts(
        ctx: *mut cipher_context_t,
        key: *const crate::types::c_uchar,
        keybits: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function feeds an input buffer into an ongoing CMAC"]
    #[doc = "                      computation."]
    #[doc = ""]
    #[doc = "                      It is called between mbedtls_cipher_cmac_starts() or"]
    #[doc = "                      mbedtls_cipher_cmac_reset(), and mbedtls_cipher_cmac_finish()."]
    #[doc = "                      Can be called repeatedly."]
    #[doc = ""]
    #[doc = " \\param ctx           The cipher context used for the CMAC operation."]
    #[doc = " \\param input         The buffer holding the input data."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = ""]
    #[doc = " \\return             \\c 0 on success."]
    #[doc = " \\return             #MBEDTLS_ERR_MD_BAD_INPUT_DATA"]
    #[doc = "                     if parameter verification fails."]
    #[link_name = "\u{1}mbedtls_cipher_cmac_update"]
    pub fn cipher_cmac_update(
        ctx: *mut cipher_context_t,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function finishes the CMAC operation, and writes"]
    #[doc = "                      the result to the output buffer."]
    #[doc = ""]
    #[doc = "                      It is called after mbedtls_cipher_cmac_update()."]
    #[doc = "                      It can be followed by mbedtls_cipher_cmac_reset() and"]
    #[doc = "                      mbedtls_cipher_cmac_update(), or mbedtls_cipher_free()."]
    #[doc = ""]
    #[doc = " \\param ctx           The cipher context used for the CMAC operation."]
    #[doc = " \\param output        The output buffer for the CMAC checksum result."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA"]
    #[doc = "                      if parameter verification fails."]
    #[link_name = "\u{1}mbedtls_cipher_cmac_finish"]
    pub fn cipher_cmac_finish(
        ctx: *mut cipher_context_t,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function prepares the authentication of another"]
    #[doc = "                      message with the same key as the previous CMAC"]
    #[doc = "                      operation."]
    #[doc = ""]
    #[doc = "                      It is called after mbedtls_cipher_cmac_finish()"]
    #[doc = "                      and before mbedtls_cipher_cmac_update()."]
    #[doc = ""]
    #[doc = " \\param ctx           The cipher context used for the CMAC operation."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA"]
    #[doc = "                      if parameter verification fails."]
    #[link_name = "\u{1}mbedtls_cipher_cmac_reset"]
    pub fn cipher_cmac_reset(ctx: *mut cipher_context_t) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function calculates the full generic CMAC"]
    #[doc = "                      on the input buffer with the provided key."]
    #[doc = ""]
    #[doc = "                      The function allocates the context, performs the"]
    #[doc = "                      calculation, and frees the context."]
    #[doc = ""]
    #[doc = "                      The CMAC result is calculated as"]
    #[doc = "                      output = generic CMAC(cmac key, input buffer)."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param cipher_info   The cipher information."]
    #[doc = " \\param key           The CMAC key."]
    #[doc = " \\param keylen        The length of the CMAC key in bits."]
    #[doc = " \\param input         The buffer holding the input data."]
    #[doc = " \\param ilen          The length of the input data."]
    #[doc = " \\param output        The buffer for the generic CMAC result."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA"]
    #[doc = "                      if parameter verification fails."]
    #[link_name = "\u{1}mbedtls_cipher_cmac"]
    pub fn cipher_cmac(
        cipher_info: *const cipher_info_t,
        key: *const crate::types::c_uchar,
        keylen: usize,
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function implements the AES-CMAC-PRF-128 pseudorandom"]
    #[doc = "                  function, as defined in"]
    #[doc = "                  <em>RFC-4615: The Advanced Encryption Standard-Cipher-based"]
    #[doc = "                  Message Authentication Code-Pseudo-Random Function-128"]
    #[doc = "                  (AES-CMAC-PRF-128) Algorithm for the Internet Key"]
    #[doc = "                  Exchange Protocol (IKE).</em>"]
    #[doc = ""]
    #[doc = " \\param key       The key to use."]
    #[doc = " \\param key_len   The key length in Bytes."]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param in_len    The length of the input data in Bytes."]
    #[doc = " \\param output    The buffer holding the generated 16 Bytes of"]
    #[doc = "                  pseudorandom output."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_aes_cmac_prf_128"]
    pub fn aes_cmac_prf_128(
        key: *const crate::types::c_uchar,
        key_len: usize,
        input: *const crate::types::c_uchar,
        in_len: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          The CMAC checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_cmac_self_test"]
    pub fn cmac_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          DES context structure"]
#[doc = ""]
#[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
#[doc = "                 security risk. We recommend considering stronger ciphers"]
#[doc = "                 instead."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct des_context {
    #[doc = "<  DES subkeys"]
    pub sk: [u32; 32usize],
}
#[test]
fn bindgen_test_layout_des_context() {
    assert_eq!(
        ::core::mem::size_of::<des_context>(),
        128usize,
        concat!("Size of: ", stringify!(des_context))
    );
    assert_eq!(
        ::core::mem::align_of::<des_context>(),
        4usize,
        concat!("Alignment of ", stringify!(des_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<des_context>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(des_context),
            "::",
            stringify!(sk)
        )
    );
}
#[doc = " \\brief          Triple-DES context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct des3_context {
    #[doc = "<  3DES subkeys"]
    pub sk: [u32; 96usize],
}
#[test]
fn bindgen_test_layout_des3_context() {
    assert_eq!(
        ::core::mem::size_of::<des3_context>(),
        384usize,
        concat!("Size of: ", stringify!(des3_context))
    );
    assert_eq!(
        ::core::mem::align_of::<des3_context>(),
        4usize,
        concat!("Alignment of ", stringify!(des3_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<des3_context>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(des3_context),
            "::",
            stringify!(sk)
        )
    );
}
impl Default for des3_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Initialize DES context"]
    #[doc = ""]
    #[doc = " \\param ctx      DES context to be initialized"]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_init"]
    pub fn des_init(ctx: *mut des_context);
}
extern "C" {
    #[doc = " \\brief          Clear DES context"]
    #[doc = ""]
    #[doc = " \\param ctx      DES context to be cleared"]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_free"]
    pub fn des_free(ctx: *mut des_context);
}
extern "C" {
    #[doc = " \\brief          Initialize Triple-DES context"]
    #[doc = ""]
    #[doc = " \\param ctx      DES3 context to be initialized"]
    #[link_name = "\u{1}mbedtls_des3_init"]
    pub fn des3_init(ctx: *mut des3_context);
}
extern "C" {
    #[doc = " \\brief          Clear Triple-DES context"]
    #[doc = ""]
    #[doc = " \\param ctx      DES3 context to be cleared"]
    #[link_name = "\u{1}mbedtls_des3_free"]
    pub fn des3_free(ctx: *mut des3_context);
}
extern "C" {
    #[doc = " \\brief          Set key parity on the given key to odd."]
    #[doc = ""]
    #[doc = "                 DES keys are 56 bits long, but each byte is padded with"]
    #[doc = "                 a parity bit to allow verification."]
    #[doc = ""]
    #[doc = " \\param key      8-byte secret key"]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_key_set_parity"]
    pub fn des_key_set_parity(key: *mut crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          Check that key parity on the given key is odd."]
    #[doc = ""]
    #[doc = "                 DES keys are 56 bits long, but each byte is padded with"]
    #[doc = "                 a parity bit to allow verification."]
    #[doc = ""]
    #[doc = " \\param key      8-byte secret key"]
    #[doc = ""]
    #[doc = " \\return         0 is parity was ok, 1 if parity was not correct."]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_key_check_key_parity"]
    pub fn des_key_check_key_parity(key: *const crate::types::c_uchar) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check that key is not a weak or semi-weak DES key"]
    #[doc = ""]
    #[doc = " \\param key      8-byte secret key"]
    #[doc = ""]
    #[doc = " \\return         0 if no weak key was found, 1 if a weak key was identified."]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_key_check_weak"]
    pub fn des_key_check_weak(key: *const crate::types::c_uchar) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          DES key schedule (56-bit, encryption)"]
    #[doc = ""]
    #[doc = " \\param ctx      DES context to be initialized"]
    #[doc = " \\param key      8-byte secret key"]
    #[doc = ""]
    #[doc = " \\return         0"]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_setkey_enc"]
    pub fn des_setkey_enc(
        ctx: *mut des_context,
        key: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          DES key schedule (56-bit, decryption)"]
    #[doc = ""]
    #[doc = " \\param ctx      DES context to be initialized"]
    #[doc = " \\param key      8-byte secret key"]
    #[doc = ""]
    #[doc = " \\return         0"]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_setkey_dec"]
    pub fn des_setkey_dec(
        ctx: *mut des_context,
        key: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Triple-DES key schedule (112-bit, encryption)"]
    #[doc = ""]
    #[doc = " \\param ctx      3DES context to be initialized"]
    #[doc = " \\param key      16-byte secret key"]
    #[doc = ""]
    #[doc = " \\return         0"]
    #[link_name = "\u{1}mbedtls_des3_set2key_enc"]
    pub fn des3_set2key_enc(
        ctx: *mut des3_context,
        key: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Triple-DES key schedule (112-bit, decryption)"]
    #[doc = ""]
    #[doc = " \\param ctx      3DES context to be initialized"]
    #[doc = " \\param key      16-byte secret key"]
    #[doc = ""]
    #[doc = " \\return         0"]
    #[link_name = "\u{1}mbedtls_des3_set2key_dec"]
    pub fn des3_set2key_dec(
        ctx: *mut des3_context,
        key: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Triple-DES key schedule (168-bit, encryption)"]
    #[doc = ""]
    #[doc = " \\param ctx      3DES context to be initialized"]
    #[doc = " \\param key      24-byte secret key"]
    #[doc = ""]
    #[doc = " \\return         0"]
    #[link_name = "\u{1}mbedtls_des3_set3key_enc"]
    pub fn des3_set3key_enc(
        ctx: *mut des3_context,
        key: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Triple-DES key schedule (168-bit, decryption)"]
    #[doc = ""]
    #[doc = " \\param ctx      3DES context to be initialized"]
    #[doc = " \\param key      24-byte secret key"]
    #[doc = ""]
    #[doc = " \\return         0"]
    #[link_name = "\u{1}mbedtls_des3_set3key_dec"]
    pub fn des3_set3key_dec(
        ctx: *mut des3_context,
        key: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          DES-ECB block encryption/decryption"]
    #[doc = ""]
    #[doc = " \\param ctx      DES context"]
    #[doc = " \\param input    64-bit input block"]
    #[doc = " \\param output   64-bit output block"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_crypt_ecb"]
    pub fn des_crypt_ecb(
        ctx: *mut des_context,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          DES-CBC buffer encryption/decryption"]
    #[doc = ""]
    #[doc = " \\note           Upon exit, the content of the IV is updated so that you can"]
    #[doc = "                 call the function same function again on the following"]
    #[doc = "                 block(s) of data and get the same result as if it was"]
    #[doc = "                 encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "                 If on the other hand you need to retain the contents of the"]
    #[doc = "                 IV, you should either save it manually or use the cipher"]
    #[doc = "                 module instead."]
    #[doc = ""]
    #[doc = " \\param ctx      DES context"]
    #[doc = " \\param mode     MBEDTLS_DES_ENCRYPT or MBEDTLS_DES_DECRYPT"]
    #[doc = " \\param length   length of the input data"]
    #[doc = " \\param iv       initialization vector (updated after use)"]
    #[doc = " \\param input    buffer holding the input data"]
    #[doc = " \\param output   buffer holding the output data"]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_crypt_cbc"]
    pub fn des_crypt_cbc(
        ctx: *mut des_context,
        mode: crate::types::c_int,
        length: usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          3DES-ECB block encryption/decryption"]
    #[doc = ""]
    #[doc = " \\param ctx      3DES context"]
    #[doc = " \\param input    64-bit input block"]
    #[doc = " \\param output   64-bit output block"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_des3_crypt_ecb"]
    pub fn des3_crypt_ecb(
        ctx: *mut des3_context,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          3DES-CBC buffer encryption/decryption"]
    #[doc = ""]
    #[doc = " \\note           Upon exit, the content of the IV is updated so that you can"]
    #[doc = "                 call the function same function again on the following"]
    #[doc = "                 block(s) of data and get the same result as if it was"]
    #[doc = "                 encrypted in one call. This allows a \"streaming\" usage."]
    #[doc = "                 If on the other hand you need to retain the contents of the"]
    #[doc = "                 IV, you should either save it manually or use the cipher"]
    #[doc = "                 module instead."]
    #[doc = ""]
    #[doc = " \\param ctx      3DES context"]
    #[doc = " \\param mode     MBEDTLS_DES_ENCRYPT or MBEDTLS_DES_DECRYPT"]
    #[doc = " \\param length   length of the input data"]
    #[doc = " \\param iv       initialization vector (updated after use)"]
    #[doc = " \\param input    buffer holding the input data"]
    #[doc = " \\param output   buffer holding the output data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or MBEDTLS_ERR_DES_INVALID_INPUT_LENGTH"]
    #[link_name = "\u{1}mbedtls_des3_crypt_cbc"]
    pub fn des3_crypt_cbc(
        ctx: *mut des3_context,
        mode: crate::types::c_int,
        length: usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Internal function for key expansion."]
    #[doc = "                 (Only exposed to allow overriding it,"]
    #[doc = "                 see MBEDTLS_DES_SETKEY_ALT)"]
    #[doc = ""]
    #[doc = " \\param SK       Round keys"]
    #[doc = " \\param key      Base key"]
    #[doc = ""]
    #[doc = " \\warning        DES is considered a weak cipher and its use constitutes a"]
    #[doc = "                 security risk. We recommend considering stronger ciphers"]
    #[doc = "                 instead."]
    #[link_name = "\u{1}mbedtls_des_setkey"]
    pub fn des_setkey(SK: *mut u32, key: *const crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[link_name = "\u{1}mbedtls_des_self_test"]
    pub fn des_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[repr(u32)]
#[doc = " Roles in the EC J-PAKE exchange"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ecjpake_role {
    #[doc = "< Client"]
    ECJPAKE_CLIENT = 0,
    #[doc = "< Server"]
    ECJPAKE_SERVER = 1,
}
#[doc = " EC J-PAKE context structure."]
#[doc = ""]
#[doc = " J-PAKE is a symmetric protocol, except for the identifiers used in"]
#[doc = " Zero-Knowledge Proofs, and the serialization of the second message"]
#[doc = " (KeyExchange) as defined by the Thread spec."]
#[doc = ""]
#[doc = " In order to benefit from this symmetry, we choose a different naming"]
#[doc = " convetion from the Thread v1.0 spec. Correspondance is indicated in the"]
#[doc = " description as a pair C: client name, S: server name"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecjpake_context {
    #[doc = "< Hash to use"]
    pub md_info: *const md_info_t,
    #[doc = "< Elliptic curve"]
    pub grp: ecp_group,
    #[doc = "< Are we client or server?"]
    pub role: ecjpake_role,
    #[doc = "< Format for point export"]
    pub point_format: crate::types::c_int,
    #[doc = "< My public key 1   C: X1, S: X3"]
    pub Xm1: ecp_point,
    #[doc = "< My public key 2   C: X2, S: X4"]
    pub Xm2: ecp_point,
    #[doc = "< Peer public key 1 C: X3, S: X1"]
    pub Xp1: ecp_point,
    #[doc = "< Peer public key 2 C: X4, S: X2"]
    pub Xp2: ecp_point,
    #[doc = "< Peer public key   C: Xs, S: Xc"]
    pub Xp: ecp_point,
    #[doc = "< My private key 1  C: x1, S: x3"]
    pub xm1: mpi,
    #[doc = "< My private key 2  C: x2, S: x4"]
    pub xm2: mpi,
    #[doc = "< Pre-shared secret (passphrase)"]
    pub s: mpi,
}
#[test]
fn bindgen_test_layout_ecjpake_context() {
    assert_eq!(
        ::core::mem::size_of::<ecjpake_context>(),
        352usize,
        concat!("Size of: ", stringify!(ecjpake_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ecjpake_context>(),
        4usize,
        concat!("Alignment of ", stringify!(ecjpake_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).md_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(md_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).grp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).role as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).point_format as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(point_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xm1 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xm1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xm2 as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xm2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xp1 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xp2 as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xp2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xp as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).xm1 as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(xm1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).xm2 as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(xm2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).s as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(s)
        )
    );
}
impl Default for ecjpake_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           Initialize an ECJPAKE context."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to initialize."]
    #[doc = "                  This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_ecjpake_init"]
    pub fn ecjpake_init(ctx: *mut ecjpake_context);
}
extern "C" {
    #[doc = " \\brief           Set up an ECJPAKE context for use."]
    #[doc = ""]
    #[doc = " \\note            Currently the only values for hash/curve allowed by the"]
    #[doc = "                  standard are #MBEDTLS_MD_SHA256/#MBEDTLS_ECP_DP_SECP256R1."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to set up. This must be initialized."]
    #[doc = " \\param role      The role of the caller. This must be either"]
    #[doc = "                  #MBEDTLS_ECJPAKE_CLIENT or #MBEDTLS_ECJPAKE_SERVER."]
    #[doc = " \\param hash      The identifier of the hash function to use,"]
    #[doc = "                  for example #MBEDTLS_MD_SHA256."]
    #[doc = " \\param curve     The identifier of the elliptic curve to use,"]
    #[doc = "                  for example #MBEDTLS_ECP_DP_SECP256R1."]
    #[doc = " \\param secret    The pre-shared secret (passphrase). This must be"]
    #[doc = "                  a readable buffer of length \\p len Bytes. It need"]
    #[doc = "                  only be valid for the duration of this call."]
    #[doc = " \\param len       The length of the pre-shared secret \\p secret."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_ecjpake_setup"]
    pub fn ecjpake_setup(
        ctx: *mut ecjpake_context,
        role: ecjpake_role,
        hash: md_type_t,
        curve: ecp_group_id,
        secret: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Check if an ECJPAKE context is ready for use."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to check. This must be"]
    #[doc = "                  initialized."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the context is ready for use."]
    #[doc = " \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA otherwise."]
    #[link_name = "\u{1}mbedtls_ecjpake_check"]
    pub fn ecjpake_check(ctx: *const ecjpake_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Generate and write the first round message"]
    #[doc = "                  (TLS: contents of the Client/ServerHello extension,"]
    #[doc = "                  excluding extension type and length bytes)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be"]
    #[doc = "                  initialized and set up."]
    #[doc = " \\param buf       The buffer to write the contents to. This must be a"]
    #[doc = "                  writable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The length of \\p buf in Bytes."]
    #[doc = " \\param olen      The address at which to store the total number"]
    #[doc = "                  of Bytes written to \\p buf. This must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG parameter to be passed to \\p f_rng. This"]
    #[doc = "                  may be \\c NULL if \\p f_rng doesn't use a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_ecjpake_write_round_one"]
    pub fn ecjpake_write_round_one(
        ctx: *mut ecjpake_context,
        buf: *mut crate::types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Read and process the first round message"]
    #[doc = "                  (TLS: contents of the Client/ServerHello extension,"]
    #[doc = "                  excluding extension type and length bytes)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be initialized"]
    #[doc = "                  and set up."]
    #[doc = " \\param buf       The buffer holding the first round message. This must"]
    #[doc = "                  be a readable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The length in Bytes of \\p buf."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_ecjpake_read_round_one"]
    pub fn ecjpake_read_round_one(
        ctx: *mut ecjpake_context,
        buf: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Generate and write the second round message"]
    #[doc = "                  (TLS: contents of the Client/ServerKeyExchange)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be initialized,"]
    #[doc = "                  set up, and already have performed round one."]
    #[doc = " \\param buf       The buffer to write the round two contents to."]
    #[doc = "                  This must be a writable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The size of \\p buf in Bytes."]
    #[doc = " \\param olen      The address at which to store the total number of Bytes"]
    #[doc = "                  written to \\p buf. This must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG parameter to be passed to \\p f_rng. This"]
    #[doc = "                  may be \\c NULL if \\p f_rng doesn't use a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_ecjpake_write_round_two"]
    pub fn ecjpake_write_round_two(
        ctx: *mut ecjpake_context,
        buf: *mut crate::types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Read and process the second round message"]
    #[doc = "                  (TLS: contents of the Client/ServerKeyExchange)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be initialized"]
    #[doc = "                  and set up and already have performed round one."]
    #[doc = " \\param buf       The buffer holding the second round message. This must"]
    #[doc = "                  be a readable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The length in Bytes of \\p buf."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_ecjpake_read_round_two"]
    pub fn ecjpake_read_round_two(
        ctx: *mut ecjpake_context,
        buf: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Derive the shared secret"]
    #[doc = "                  (TLS: Pre-Master Secret)."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to use. This must be initialized,"]
    #[doc = "                  set up and have performed both round one and two."]
    #[doc = " \\param buf       The buffer to write the derived secret to. This must"]
    #[doc = "                  be a writable buffer of length \\p len Bytes."]
    #[doc = " \\param len       The length of \\p buf in Bytes."]
    #[doc = " \\param olen      The address at which to store the total number of Bytes"]
    #[doc = "                  written to \\p buf. This must not be \\c NULL."]
    #[doc = " \\param f_rng     The RNG function to use. This must not be \\c NULL."]
    #[doc = " \\param p_rng     The RNG parameter to be passed to \\p f_rng. This"]
    #[doc = "                  may be \\c NULL if \\p f_rng doesn't use a context."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful."]
    #[doc = " \\return          A negative error code on failure."]
    #[link_name = "\u{1}mbedtls_ecjpake_derive_secret"]
    pub fn ecjpake_derive_secret(
        ctx: *mut ecjpake_context,
        buf: *mut crate::types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_rng: *mut crate::types::c_void,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This clears an ECJPAKE context and frees any"]
    #[doc = "                  embedded data structure."]
    #[doc = ""]
    #[doc = " \\param ctx       The ECJPAKE context to free. This may be \\c NULL,"]
    #[doc = "                  in which case this function does nothing. If it is not"]
    #[doc = "                  \\c NULL, it must point to an initialized ECJPAKE context."]
    #[link_name = "\u{1}mbedtls_ecjpake_free"]
    pub fn ecjpake_free(ctx: *mut ecjpake_context);
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if a test failed"]
    #[link_name = "\u{1}mbedtls_ecjpake_self_test"]
    pub fn ecjpake_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          The GCM context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcm_context {
    #[doc = "< The cipher context used."]
    pub cipher_ctx: cipher_context_t,
    #[doc = "< Precalculated HTable low."]
    pub HL: [u64; 16usize],
    #[doc = "< Precalculated HTable high."]
    pub HH: [u64; 16usize],
    #[doc = "< The total length of the encrypted data."]
    pub len: u64,
    #[doc = "< The total length of the additional data."]
    pub add_len: u64,
    #[doc = "< The first ECTR for tag."]
    pub base_ectr: [crate::types::c_uchar; 16usize],
    #[doc = "< The Y working value."]
    pub y: [crate::types::c_uchar; 16usize],
    #[doc = "< The buf working value."]
    pub buf: [crate::types::c_uchar; 16usize],
    #[doc = "< The operation to perform:"]
    #[doc = "#MBEDTLS_GCM_ENCRYPT or"]
    #[doc = "#MBEDTLS_GCM_DECRYPT."]
    pub mode: crate::types::c_int,
}
#[test]
fn bindgen_test_layout_gcm_context() {
    assert_eq!(
        ::core::mem::size_of::<gcm_context>(),
        392usize,
        concat!("Size of: ", stringify!(gcm_context))
    );
    assert_eq!(
        ::core::mem::align_of::<gcm_context>(),
        8usize,
        concat!("Alignment of ", stringify!(gcm_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).cipher_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).HL as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(HL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).HH as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(HH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).len as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).add_len as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(add_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).base_ectr as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(base_ectr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).y as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).buf as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).mode as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for gcm_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified GCM context,"]
    #[doc = "                  to make references valid, and prepares the context"]
    #[doc = "                  for mbedtls_gcm_setkey() or mbedtls_gcm_free()."]
    #[doc = ""]
    #[doc = "                  The function does not bind the GCM context to a particular"]
    #[doc = "                  cipher, nor set the key. For this purpose, use"]
    #[doc = "                  mbedtls_gcm_setkey()."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context to initialize. This must not be \\c NULL."]
    #[link_name = "\u{1}mbedtls_gcm_init"]
    pub fn gcm_init(ctx: *mut gcm_context);
}
extern "C" {
    #[doc = " \\brief           This function associates a GCM context with a"]
    #[doc = "                  cipher algorithm and a key."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must be initialized."]
    #[doc = " \\param cipher    The 128-bit block cipher to use."]
    #[doc = " \\param key       The encryption key. This must be a readable buffer of at"]
    #[doc = "                  least \\p keybits bits."]
    #[doc = " \\param keybits   The key size in bits. Valid options are:"]
    #[doc = "                  <ul><li>128 bits</li>"]
    #[doc = "                  <li>192 bits</li>"]
    #[doc = "                  <li>256 bits</li></ul>"]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          A cipher-specific error code on failure."]
    #[link_name = "\u{1}mbedtls_gcm_setkey"]
    pub fn gcm_setkey(
        ctx: *mut gcm_context,
        cipher: cipher_id_t,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs GCM encryption or decryption of a buffer."]
    #[doc = ""]
    #[doc = " \\note            For encryption, the output buffer can be the same as the"]
    #[doc = "                  input buffer. For decryption, the output buffer cannot be"]
    #[doc = "                  the same as input buffer. If the buffers overlap, the output"]
    #[doc = "                  buffer must trail at least 8 Bytes behind the input buffer."]
    #[doc = ""]
    #[doc = " \\warning         When this function performs a decryption, it outputs the"]
    #[doc = "                  authentication tag and does not verify that the data is"]
    #[doc = "                  authentic. You should use this function to perform encryption"]
    #[doc = "                  only. For decryption, use mbedtls_gcm_auth_decrypt() instead."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context to use for encryption or decryption. This"]
    #[doc = "                  must be initialized."]
    #[doc = " \\param mode      The operation to perform:"]
    #[doc = "                  - #MBEDTLS_GCM_ENCRYPT to perform authenticated encryption."]
    #[doc = "                    The ciphertext is written to \\p output and the"]
    #[doc = "                    authentication tag is written to \\p tag."]
    #[doc = "                  - #MBEDTLS_GCM_DECRYPT to perform decryption."]
    #[doc = "                    The plaintext is written to \\p output and the"]
    #[doc = "                    authentication tag is written to \\p tag."]
    #[doc = "                    Note that this mode is not recommended, because it does"]
    #[doc = "                    not verify the authenticity of the data. For this reason,"]
    #[doc = "                    you should use mbedtls_gcm_auth_decrypt() instead of"]
    #[doc = "                    calling this function in decryption mode."]
    #[doc = " \\param length    The length of the input data, which is equal to the length"]
    #[doc = "                  of the output data."]
    #[doc = " \\param iv        The initialization vector. This must be a readable buffer of"]
    #[doc = "                  at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the IV."]
    #[doc = " \\param add       The buffer holding the additional data. This must be of at"]
    #[doc = "                  least that size in Bytes."]
    #[doc = " \\param add_len   The length of the additional data."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, this must be a readable buffer of at least that"]
    #[doc = "                  size in Bytes."]
    #[doc = " \\param output    The buffer for holding the output data. If \\p length is greater"]
    #[doc = "                  than zero, this must be a writable buffer of at least that"]
    #[doc = "                  size in Bytes."]
    #[doc = " \\param tag_len   The length of the tag to generate."]
    #[doc = " \\param tag       The buffer for holding the tag. This must be a readable"]
    #[doc = "                  buffer of at least \\p tag_len Bytes."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if the encryption or decryption was performed"]
    #[doc = "                  successfully. Note that in #MBEDTLS_GCM_DECRYPT mode,"]
    #[doc = "                  this does not indicate that the data is authentic."]
    #[doc = " \\return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are"]
    #[doc = "                  not valid or a cipher-specific error code if the encryption"]
    #[doc = "                  or decryption failed."]
    #[link_name = "\u{1}mbedtls_gcm_crypt_and_tag"]
    pub fn gcm_crypt_and_tag(
        ctx: *mut gcm_context,
        mode: crate::types::c_int,
        length: usize,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        add: *const crate::types::c_uchar,
        add_len: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
        tag_len: usize,
        tag: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a GCM authenticated decryption of a"]
    #[doc = "                  buffer."]
    #[doc = ""]
    #[doc = " \\note            For decryption, the output buffer cannot be the same as"]
    #[doc = "                  input buffer. If the buffers overlap, the output buffer"]
    #[doc = "                  must trail at least 8 Bytes behind the input buffer."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must be initialized."]
    #[doc = " \\param length    The length of the ciphertext to decrypt, which is also"]
    #[doc = "                  the length of the decrypted plaintext."]
    #[doc = " \\param iv        The initialization vector. This must be a readable buffer"]
    #[doc = "                  of at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the IV."]
    #[doc = " \\param add       The buffer holding the additional data. This must be of at"]
    #[doc = "                  least that size in Bytes."]
    #[doc = " \\param add_len   The length of the additional data."]
    #[doc = " \\param tag       The buffer holding the tag to verify. This must be a"]
    #[doc = "                  readable buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the tag to verify."]
    #[doc = " \\param input     The buffer holding the ciphertext. If \\p length is greater"]
    #[doc = "                  than zero, this must be a readable buffer of at least that"]
    #[doc = "                  size."]
    #[doc = " \\param output    The buffer for holding the decrypted plaintext. If \\p length"]
    #[doc = "                  is greater than zero, this must be a writable buffer of at"]
    #[doc = "                  least that size."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 if successful and authenticated."]
    #[doc = " \\return          #MBEDTLS_ERR_GCM_AUTH_FAILED if the tag does not match."]
    #[doc = " \\return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are"]
    #[doc = "                  not valid or a cipher-specific error code if the decryption"]
    #[doc = "                  failed."]
    #[link_name = "\u{1}mbedtls_gcm_auth_decrypt"]
    pub fn gcm_auth_decrypt(
        ctx: *mut gcm_context,
        length: usize,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        add: *const crate::types::c_uchar,
        add_len: usize,
        tag: *const crate::types::c_uchar,
        tag_len: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a GCM encryption or decryption"]
    #[doc = "                  operation."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must be initialized."]
    #[doc = " \\param mode      The operation to perform: #MBEDTLS_GCM_ENCRYPT or"]
    #[doc = "                  #MBEDTLS_GCM_DECRYPT."]
    #[doc = " \\param iv        The initialization vector. This must be a readable buffer of"]
    #[doc = "                  at least \\p iv_len Bytes."]
    #[doc = " \\param iv_len    The length of the IV."]
    #[doc = " \\param add       The buffer holding the additional data, or \\c NULL"]
    #[doc = "                  if \\p add_len is \\c 0."]
    #[doc = " \\param add_len   The length of the additional data. If \\c 0,"]
    #[doc = "                  \\p add may be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[link_name = "\u{1}mbedtls_gcm_starts"]
    pub fn gcm_starts(
        ctx: *mut gcm_context,
        mode: crate::types::c_int,
        iv: *const crate::types::c_uchar,
        iv_len: usize,
        add: *const crate::types::c_uchar,
        add_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing GCM"]
    #[doc = "                  encryption or decryption operation."]
    #[doc = ""]
    #[doc = "    `             The function expects input to be a multiple of 16"]
    #[doc = "                  Bytes. Only the last call before calling"]
    #[doc = "                  mbedtls_gcm_finish() can be less than 16 Bytes."]
    #[doc = ""]
    #[doc = " \\note            For decryption, the output buffer cannot be the same as"]
    #[doc = "                  input buffer. If the buffers overlap, the output buffer"]
    #[doc = "                  must trail at least 8 Bytes behind the input buffer."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must be initialized."]
    #[doc = " \\param length    The length of the input data. This must be a multiple of"]
    #[doc = "                  16 except in the last call before mbedtls_gcm_finish()."]
    #[doc = " \\param input     The buffer holding the input data. If \\p length is greater"]
    #[doc = "                  than zero, this must be a readable buffer of at least that"]
    #[doc = "                  size in Bytes."]
    #[doc = " \\param output    The buffer for holding the output data. If \\p length is"]
    #[doc = "                  greater than zero, this must be a writable buffer of at"]
    #[doc = "                  least that size in Bytes."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         #MBEDTLS_ERR_GCM_BAD_INPUT on failure."]
    #[link_name = "\u{1}mbedtls_gcm_update"]
    pub fn gcm_update(
        ctx: *mut gcm_context,
        length: usize,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the GCM operation and generates"]
    #[doc = "                  the authentication tag."]
    #[doc = ""]
    #[doc = "                  It wraps up the GCM stream, and generates the"]
    #[doc = "                  tag. The tag can have a maximum length of 16 Bytes."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context. This must be initialized."]
    #[doc = " \\param tag       The buffer for holding the tag. This must be a readable"]
    #[doc = "                  buffer of at least \\p tag_len Bytes."]
    #[doc = " \\param tag_len   The length of the tag to generate. This must be at least"]
    #[doc = "                  four."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          #MBEDTLS_ERR_GCM_BAD_INPUT on failure."]
    #[link_name = "\u{1}mbedtls_gcm_finish"]
    pub fn gcm_finish(
        ctx: *mut gcm_context,
        tag: *mut crate::types::c_uchar,
        tag_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function clears a GCM context and the underlying"]
    #[doc = "                  cipher sub-context."]
    #[doc = ""]
    #[doc = " \\param ctx       The GCM context to clear. If this is \\c NULL, the call has"]
    #[doc = "                  no effect. Otherwise, this must be initialized."]
    #[link_name = "\u{1}mbedtls_gcm_free"]
    pub fn gcm_free(ctx: *mut gcm_context);
}
extern "C" {
    #[doc = " \\brief          The GCM checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_gcm_self_test"]
    pub fn gcm_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
extern "C" {
    #[doc = "  \\brief  This is the HMAC-based Extract-and-Expand Key Derivation Function"]
    #[doc = "          (HKDF)."]
    #[doc = ""]
    #[doc = "  \\param  md        A hash function; md.size denotes the length of the hash"]
    #[doc = "                    function output in bytes."]
    #[doc = "  \\param  salt      An optional salt value (a non-secret random value);"]
    #[doc = "                    if the salt is not provided, a string of all zeros of"]
    #[doc = "                    md.size length is used as the salt."]
    #[doc = "  \\param  salt_len  The length in bytes of the optional \\p salt."]
    #[doc = "  \\param  ikm       The input keying material."]
    #[doc = "  \\param  ikm_len   The length in bytes of \\p ikm."]
    #[doc = "  \\param  info      An optional context and application specific information"]
    #[doc = "                    string. This can be a zero-length string."]
    #[doc = "  \\param  info_len  The length of \\p info in bytes."]
    #[doc = "  \\param  okm       The output keying material of \\p okm_len bytes."]
    #[doc = "  \\param  okm_len   The length of the output keying material in bytes. This"]
    #[doc = "                    must be less than or equal to 255 * md.size bytes."]
    #[doc = ""]
    #[doc = "  \\return 0 on success."]
    #[doc = "  \\return #MBEDTLS_ERR_HKDF_BAD_INPUT_DATA when the parameters are invalid."]
    #[doc = "  \\return An MBEDTLS_ERR_MD_* error for errors returned from the underlying"]
    #[doc = "          MD layer."]
    #[link_name = "\u{1}mbedtls_hkdf"]
    pub fn hkdf(
        md: *const md_info_t,
        salt: *const crate::types::c_uchar,
        salt_len: usize,
        ikm: *const crate::types::c_uchar,
        ikm_len: usize,
        info: *const crate::types::c_uchar,
        info_len: usize,
        okm: *mut crate::types::c_uchar,
        okm_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = "  \\brief  Take the input keying material \\p ikm and extract from it a"]
    #[doc = "          fixed-length pseudorandom key \\p prk."]
    #[doc = ""]
    #[doc = "  \\warning    This function should only be used if the security of it has been"]
    #[doc = "              studied and established in that particular context (eg. TLS 1.3"]
    #[doc = "              key schedule). For standard HKDF security guarantees use"]
    #[doc = "              \\c mbedtls_hkdf instead."]
    #[doc = ""]
    #[doc = "  \\param       md        A hash function; md.size denotes the length of the"]
    #[doc = "                         hash function output in bytes."]
    #[doc = "  \\param       salt      An optional salt value (a non-secret random value);"]
    #[doc = "                         if the salt is not provided, a string of all zeros"]
    #[doc = "                         of md.size length is used as the salt."]
    #[doc = "  \\param       salt_len  The length in bytes of the optional \\p salt."]
    #[doc = "  \\param       ikm       The input keying material."]
    #[doc = "  \\param       ikm_len   The length in bytes of \\p ikm."]
    #[doc = "  \\param[out]  prk       A pseudorandom key of at least md.size bytes."]
    #[doc = ""]
    #[doc = "  \\return 0 on success."]
    #[doc = "  \\return #MBEDTLS_ERR_HKDF_BAD_INPUT_DATA when the parameters are invalid."]
    #[doc = "  \\return An MBEDTLS_ERR_MD_* error for errors returned from the underlying"]
    #[doc = "          MD layer."]
    #[link_name = "\u{1}mbedtls_hkdf_extract"]
    pub fn hkdf_extract(
        md: *const md_info_t,
        salt: *const crate::types::c_uchar,
        salt_len: usize,
        ikm: *const crate::types::c_uchar,
        ikm_len: usize,
        prk: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = "  \\brief  Expand the supplied \\p prk into several additional pseudorandom"]
    #[doc = "          keys, which is the output of the HKDF."]
    #[doc = ""]
    #[doc = "  \\warning    This function should only be used if the security of it has been"]
    #[doc = "              studied and established in that particular context (eg. TLS 1.3"]
    #[doc = "              key schedule). For standard HKDF security guarantees use"]
    #[doc = "              \\c mbedtls_hkdf instead."]
    #[doc = ""]
    #[doc = "  \\param  md        A hash function; md.size denotes the length of the hash"]
    #[doc = "                    function output in bytes."]
    #[doc = "  \\param  prk       A pseudorandom key of at least md.size bytes. \\p prk is"]
    #[doc = "                    usually the output from the HKDF extract step."]
    #[doc = "  \\param  prk_len   The length in bytes of \\p prk."]
    #[doc = "  \\param  info      An optional context and application specific information"]
    #[doc = "                    string. This can be a zero-length string."]
    #[doc = "  \\param  info_len  The length of \\p info in bytes."]
    #[doc = "  \\param  okm       The output keying material of \\p okm_len bytes."]
    #[doc = "  \\param  okm_len   The length of the output keying material in bytes. This"]
    #[doc = "                    must be less than or equal to 255 * md.size bytes."]
    #[doc = ""]
    #[doc = "  \\return 0 on success."]
    #[doc = "  \\return #MBEDTLS_ERR_HKDF_BAD_INPUT_DATA when the parameters are invalid."]
    #[doc = "  \\return An MBEDTLS_ERR_MD_* error for errors returned from the underlying"]
    #[doc = "          MD layer."]
    #[link_name = "\u{1}mbedtls_hkdf_expand"]
    pub fn hkdf_expand(
        md: *const md_info_t,
        prk: *const crate::types::c_uchar,
        prk_len: usize,
        info: *const crate::types::c_uchar,
        info_len: usize,
        okm: *mut crate::types::c_uchar,
        okm_len: usize,
    ) -> crate::types::c_int;
}
#[doc = " \\brief          MD2 context structure"]
#[doc = ""]
#[doc = " \\warning        MD2 is considered a weak message digest and its use"]
#[doc = "                 constitutes a security risk. We recommend considering"]
#[doc = "                 stronger message digests instead."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md2_context {
    #[doc = "< checksum of the data block"]
    pub cksum: [crate::types::c_uchar; 16usize],
    #[doc = "< intermediate digest state"]
    pub state: [crate::types::c_uchar; 48usize],
    #[doc = "< data block being processed"]
    pub buffer: [crate::types::c_uchar; 16usize],
    #[doc = "< amount of data in buffer"]
    pub left: usize,
}
#[test]
fn bindgen_test_layout_md2_context() {
    assert_eq!(
        ::core::mem::size_of::<md2_context>(),
        84usize,
        concat!("Size of: ", stringify!(md2_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md2_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md2_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md2_context>())).cksum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(cksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md2_context>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md2_context>())).buffer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md2_context>())).left as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(left)
        )
    );
}
impl Default for md2_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Initialize MD2 context"]
    #[doc = ""]
    #[doc = " \\param ctx      MD2 context to be initialized"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_init"]
    pub fn md2_init(ctx: *mut md2_context);
}
extern "C" {
    #[doc = " \\brief          Clear MD2 context"]
    #[doc = ""]
    #[doc = " \\param ctx      MD2 context to be cleared"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_free"]
    pub fn md2_free(ctx: *mut md2_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) an MD2 context"]
    #[doc = ""]
    #[doc = " \\param dst      The destination context"]
    #[doc = " \\param src      The context to be cloned"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_clone"]
    pub fn md2_clone(dst: *mut md2_context, src: *const md2_context);
}
extern "C" {
    #[doc = " \\brief          MD2 context setup"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_starts_ret"]
    pub fn md2_starts_ret(ctx: *mut md2_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD2 process buffer"]
    #[doc = ""]
    #[doc = " \\param ctx      MD2 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_update_ret"]
    pub fn md2_update_ret(
        ctx: *mut md2_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD2 final digest"]
    #[doc = ""]
    #[doc = " \\param ctx      MD2 context"]
    #[doc = " \\param output   MD2 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_finish_ret"]
    pub fn md2_finish_ret(
        ctx: *mut md2_context,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD2 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\param ctx      MD2 context"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_internal_md2_process"]
    pub fn internal_md2_process(ctx: *mut md2_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD2 context setup"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md2_starts_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_starts"]
    pub fn md2_starts(ctx: *mut md2_context);
}
extern "C" {
    #[doc = " \\brief          MD2 process buffer"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md2_update_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      MD2 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_update"]
    pub fn md2_update(ctx: *mut md2_context, input: *const crate::types::c_uchar, ilen: usize);
}
extern "C" {
    #[doc = " \\brief          MD2 final digest"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md2_finish_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      MD2 context"]
    #[doc = " \\param output   MD2 checksum result"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_finish"]
    pub fn md2_finish(ctx: *mut md2_context, output: *mut crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          MD2 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_internal_md2_process() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      MD2 context"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_process"]
    pub fn md2_process(ctx: *mut md2_context);
}
extern "C" {
    #[doc = " \\brief          Output = MD2( input buffer )"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   MD2 checksum result"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_ret"]
    pub fn md2_ret(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = MD2( input buffer )"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md2_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   MD2 checksum result"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2"]
    pub fn md2(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[doc = ""]
    #[doc = " \\warning        MD2 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md2_self_test"]
    pub fn md2_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          MD4 context structure"]
#[doc = ""]
#[doc = " \\warning        MD4 is considered a weak message digest and its use"]
#[doc = "                 constitutes a security risk. We recommend considering"]
#[doc = "                 stronger message digests instead."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md4_context {
    #[doc = "< number of bytes processed"]
    pub total: [u32; 2usize],
    #[doc = "< intermediate digest state"]
    pub state: [u32; 4usize],
    #[doc = "< data block being processed"]
    pub buffer: [crate::types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md4_context() {
    assert_eq!(
        ::core::mem::size_of::<md4_context>(),
        88usize,
        concat!("Size of: ", stringify!(md4_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md4_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md4_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md4_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md4_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md4_context>())).buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_context),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for md4_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Initialize MD4 context"]
    #[doc = ""]
    #[doc = " \\param ctx      MD4 context to be initialized"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_init"]
    pub fn md4_init(ctx: *mut md4_context);
}
extern "C" {
    #[doc = " \\brief          Clear MD4 context"]
    #[doc = ""]
    #[doc = " \\param ctx      MD4 context to be cleared"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_free"]
    pub fn md4_free(ctx: *mut md4_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) an MD4 context"]
    #[doc = ""]
    #[doc = " \\param dst      The destination context"]
    #[doc = " \\param src      The context to be cloned"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_clone"]
    pub fn md4_clone(dst: *mut md4_context, src: *const md4_context);
}
extern "C" {
    #[doc = " \\brief          MD4 context setup"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[link_name = "\u{1}mbedtls_md4_starts_ret"]
    pub fn md4_starts_ret(ctx: *mut md4_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD4 process buffer"]
    #[doc = ""]
    #[doc = " \\param ctx      MD4 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_update_ret"]
    pub fn md4_update_ret(
        ctx: *mut md4_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD4 final digest"]
    #[doc = ""]
    #[doc = " \\param ctx      MD4 context"]
    #[doc = " \\param output   MD4 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_finish_ret"]
    pub fn md4_finish_ret(
        ctx: *mut md4_context,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD4 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\param ctx      MD4 context"]
    #[doc = " \\param data     buffer holding one block of data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_internal_md4_process"]
    pub fn internal_md4_process(
        ctx: *mut md4_context,
        data: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD4 context setup"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md4_starts_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_starts"]
    pub fn md4_starts(ctx: *mut md4_context);
}
extern "C" {
    #[doc = " \\brief          MD4 process buffer"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md4_update_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      MD4 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_update"]
    pub fn md4_update(ctx: *mut md4_context, input: *const crate::types::c_uchar, ilen: usize);
}
extern "C" {
    #[doc = " \\brief          MD4 final digest"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md4_finish_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      MD4 context"]
    #[doc = " \\param output   MD4 checksum result"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_finish"]
    pub fn md4_finish(ctx: *mut md4_context, output: *mut crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          MD4 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_internal_md4_process() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      MD4 context"]
    #[doc = " \\param data     buffer holding one block of data"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_process"]
    pub fn md4_process(ctx: *mut md4_context, data: *const crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          Output = MD4( input buffer )"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   MD4 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_ret"]
    pub fn md4_ret(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = MD4( input buffer )"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_md4_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   MD4 checksum result"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4"]
    pub fn md4(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[doc = ""]
    #[doc = " \\warning        MD4 is considered a weak message digest and its use"]
    #[doc = "                 constitutes a security risk. We recommend considering"]
    #[doc = "                 stronger message digests instead."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_md4_self_test"]
    pub fn md4_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nist_kw_mode_t {
    KW_MODE_KW = 0,
    KW_MODE_KWP = 1,
}
#[doc = " \\brief    The key wrapping context-type definition. The key wrapping context is passed"]
#[doc = "           to the APIs called."]
#[doc = ""]
#[doc = " \\note     The definition of this type may change in future library versions."]
#[doc = "           Don't make any assumptions on this context!"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nist_kw_context {
    #[doc = "< The cipher context used."]
    pub cipher_ctx: cipher_context_t,
}
#[test]
fn bindgen_test_layout_nist_kw_context() {
    assert_eq!(
        ::core::mem::size_of::<nist_kw_context>(),
        64usize,
        concat!("Size of: ", stringify!(nist_kw_context))
    );
    assert_eq!(
        ::core::mem::align_of::<nist_kw_context>(),
        4usize,
        concat!("Alignment of ", stringify!(nist_kw_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nist_kw_context>())).cipher_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nist_kw_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
}
impl Default for nist_kw_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified key wrapping context"]
    #[doc = "                  to make references valid and prepare the context"]
    #[doc = "                  for mbedtls_nist_kw_setkey() or mbedtls_nist_kw_free()."]
    #[doc = ""]
    #[doc = " \\param ctx       The key wrapping context to initialize."]
    #[doc = ""]
    #[link_name = "\u{1}mbedtls_nist_kw_init"]
    pub fn nist_kw_init(ctx: *mut nist_kw_context);
}
extern "C" {
    #[doc = " \\brief           This function initializes the key wrapping context set in the"]
    #[doc = "                  \\p ctx parameter and sets the encryption key."]
    #[doc = ""]
    #[doc = " \\param ctx       The key wrapping context."]
    #[doc = " \\param cipher    The 128-bit block cipher to use. Only AES is supported."]
    #[doc = " \\param key       The Key Encryption Key (KEK)."]
    #[doc = " \\param keybits   The KEK size in bits. This must be acceptable by the cipher."]
    #[doc = " \\param is_wrap   Specify whether the operation within the context is wrapping or unwrapping"]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          \\c MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA for any invalid input."]
    #[doc = " \\return          \\c MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE for 128-bit block ciphers"]
    #[doc = "                  which are not supported."]
    #[doc = " \\return          cipher-specific error code on failure of the underlying cipher."]
    #[link_name = "\u{1}mbedtls_nist_kw_setkey"]
    pub fn nist_kw_setkey(
        ctx: *mut nist_kw_context,
        cipher: cipher_id_t,
        key: *const crate::types::c_uchar,
        keybits: crate::types::c_uint,
        is_wrap: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function releases and clears the specified key wrapping context"]
    #[doc = "          and underlying cipher sub-context."]
    #[doc = ""]
    #[doc = " \\param ctx       The key wrapping context to clear."]
    #[link_name = "\u{1}mbedtls_nist_kw_free"]
    pub fn nist_kw_free(ctx: *mut nist_kw_context);
}
extern "C" {
    #[doc = " \\brief           This function encrypts a buffer using key wrapping."]
    #[doc = ""]
    #[doc = " \\param ctx       The key wrapping context to use for encryption."]
    #[doc = " \\param mode      The key wrapping mode to use (MBEDTLS_KW_MODE_KW or MBEDTLS_KW_MODE_KWP)"]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param in_len    The length of the input data in Bytes."]
    #[doc = "                  The input uses units of 8 Bytes called semiblocks."]
    #[doc = "                  <ul><li>For KW mode: a multiple of 8 bytes between 16 and 2^57-8 inclusive. </li>"]
    #[doc = "                  <li>For KWP mode: any length between 1 and 2^32-1 inclusive.</li></ul>"]
    #[doc = " \\param[out] output    The buffer holding the output data."]
    #[doc = "                  <ul><li>For KW mode: Must be at least 8 bytes larger than \\p in_len.</li>"]
    #[doc = "                  <li>For KWP mode: Must be at least 8 bytes larger rounded up to a multiple of"]
    #[doc = "                  8 bytes for KWP (15 bytes at most).</li></ul>"]
    #[doc = " \\param[out] out_len The number of bytes written to the output buffer. \\c 0 on failure."]
    #[doc = " \\param[in] out_size The capacity of the output buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          \\c MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA for invalid input length."]
    #[doc = " \\return          cipher-specific error code on failure of the underlying cipher."]
    #[link_name = "\u{1}mbedtls_nist_kw_wrap"]
    pub fn nist_kw_wrap(
        ctx: *mut nist_kw_context,
        mode: nist_kw_mode_t,
        input: *const crate::types::c_uchar,
        in_len: usize,
        output: *mut crate::types::c_uchar,
        out_len: *mut usize,
        out_size: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function decrypts a buffer using key wrapping."]
    #[doc = ""]
    #[doc = " \\param ctx       The key wrapping context to use for decryption."]
    #[doc = " \\param mode      The key wrapping mode to use (MBEDTLS_KW_MODE_KW or MBEDTLS_KW_MODE_KWP)"]
    #[doc = " \\param input     The buffer holding the input data."]
    #[doc = " \\param in_len    The length of the input data in Bytes."]
    #[doc = "                  The input uses units of 8 Bytes called semiblocks."]
    #[doc = "                  The input must be a multiple of semiblocks."]
    #[doc = "                  <ul><li>For KW mode: a multiple of 8 bytes between 24 and 2^57 inclusive. </li>"]
    #[doc = "                  <li>For KWP mode: a multiple of 8 bytes between 16 and 2^32 inclusive.</li></ul>"]
    #[doc = " \\param[out] output    The buffer holding the output data."]
    #[doc = "                  The output buffer's minimal length is 8 bytes shorter than \\p in_len."]
    #[doc = " \\param[out] out_len The number of bytes written to the output buffer. \\c 0 on failure."]
    #[doc = "                  For KWP mode, the length could be up to 15 bytes shorter than \\p in_len,"]
    #[doc = "                  depending on how much padding was added to the data."]
    #[doc = " \\param[in] out_size The capacity of the output buffer."]
    #[doc = ""]
    #[doc = " \\return          \\c 0 on success."]
    #[doc = " \\return          \\c MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA for invalid input length."]
    #[doc = " \\return          \\c MBEDTLS_ERR_CIPHER_AUTH_FAILED for verification failure of the ciphertext."]
    #[doc = " \\return          cipher-specific error code on failure of the underlying cipher."]
    #[link_name = "\u{1}mbedtls_nist_kw_unwrap"]
    pub fn nist_kw_unwrap(
        ctx: *mut nist_kw_context,
        mode: nist_kw_mode_t,
        input: *const crate::types::c_uchar,
        in_len: usize,
        output: *mut crate::types::c_uchar,
        out_len: *mut usize,
        out_size: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          The key wrapping checkup routine."]
    #[doc = ""]
    #[doc = " \\return         \\c 0 on success."]
    #[doc = " \\return         \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_nist_kw_self_test"]
    pub fn nist_kw_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          PKCS#5 PBES2 function"]
    #[doc = ""]
    #[doc = " \\param pbe_params the ASN.1 algorithm parameters"]
    #[doc = " \\param mode       either MBEDTLS_PKCS5_DECRYPT or MBEDTLS_PKCS5_ENCRYPT"]
    #[doc = " \\param pwd        password to use when generating key"]
    #[doc = " \\param pwdlen     length of password"]
    #[doc = " \\param data       data to process"]
    #[doc = " \\param datalen    length of data"]
    #[doc = " \\param output     output buffer"]
    #[doc = ""]
    #[doc = " \\returns        0 on success, or a MBEDTLS_ERR_XXX code if verification fails."]
    #[link_name = "\u{1}mbedtls_pkcs5_pbes2"]
    pub fn pkcs5_pbes2(
        pbe_params: *const asn1_buf,
        mode: crate::types::c_int,
        pwd: *const crate::types::c_uchar,
        pwdlen: usize,
        data: *const crate::types::c_uchar,
        datalen: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          PKCS#5 PBKDF2 using HMAC"]
    #[doc = ""]
    #[doc = " \\param ctx      Generic HMAC context"]
    #[doc = " \\param password Password to use when generating key"]
    #[doc = " \\param plen     Length of password"]
    #[doc = " \\param salt     Salt to use when generating key"]
    #[doc = " \\param slen     Length of salt"]
    #[doc = " \\param iteration_count       Iteration count"]
    #[doc = " \\param key_length            Length of generated key in bytes"]
    #[doc = " \\param output   Generated key. Must be at least as big as key_length"]
    #[doc = ""]
    #[doc = " \\returns        0 on success, or a MBEDTLS_ERR_XXX code if verification fails."]
    #[link_name = "\u{1}mbedtls_pkcs5_pbkdf2_hmac"]
    pub fn pkcs5_pbkdf2_hmac(
        ctx: *mut md_context_t,
        password: *const crate::types::c_uchar,
        plen: usize,
        salt: *const crate::types::c_uchar,
        slen: usize,
        iteration_count: crate::types::c_uint,
        key_length: u32,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[link_name = "\u{1}mbedtls_pkcs5_self_test"]
    pub fn pkcs5_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief            PKCS12 Password Based function (encryption / decryption)"]
    #[doc = "                   for pbeWithSHAAnd128BitRC4"]
    #[doc = ""]
    #[doc = " \\param pbe_params an ASN1 buffer containing the pkcs-12PbeParams structure"]
    #[doc = " \\param mode       either MBEDTLS_PKCS12_PBE_ENCRYPT or MBEDTLS_PKCS12_PBE_DECRYPT"]
    #[doc = " \\param pwd        the password used (may be NULL if no password is used)"]
    #[doc = " \\param pwdlen     length of the password (may be 0)"]
    #[doc = " \\param input      the input data"]
    #[doc = " \\param len        data length"]
    #[doc = " \\param output     the output buffer"]
    #[doc = ""]
    #[doc = " \\return           0 if successful, or a MBEDTLS_ERR_XXX code"]
    #[link_name = "\u{1}mbedtls_pkcs12_pbe_sha1_rc4_128"]
    pub fn pkcs12_pbe_sha1_rc4_128(
        pbe_params: *mut asn1_buf,
        mode: crate::types::c_int,
        pwd: *const crate::types::c_uchar,
        pwdlen: usize,
        input: *const crate::types::c_uchar,
        len: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief            PKCS12 Password Based function (encryption / decryption)"]
    #[doc = "                   for cipher-based and mbedtls_md-based PBE's"]
    #[doc = ""]
    #[doc = " \\param pbe_params an ASN1 buffer containing the pkcs-12PbeParams structure"]
    #[doc = " \\param mode       either MBEDTLS_PKCS12_PBE_ENCRYPT or MBEDTLS_PKCS12_PBE_DECRYPT"]
    #[doc = " \\param cipher_type the cipher used"]
    #[doc = " \\param md_type     the mbedtls_md used"]
    #[doc = " \\param pwd        the password used (may be NULL if no password is used)"]
    #[doc = " \\param pwdlen     length of the password (may be 0)"]
    #[doc = " \\param input      the input data"]
    #[doc = " \\param len        data length"]
    #[doc = " \\param output     the output buffer"]
    #[doc = ""]
    #[doc = " \\return           0 if successful, or a MBEDTLS_ERR_XXX code"]
    #[link_name = "\u{1}mbedtls_pkcs12_pbe"]
    pub fn pkcs12_pbe(
        pbe_params: *mut asn1_buf,
        mode: crate::types::c_int,
        cipher_type: cipher_type_t,
        md_type: md_type_t,
        pwd: *const crate::types::c_uchar,
        pwdlen: usize,
        input: *const crate::types::c_uchar,
        len: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief            The PKCS#12 derivation function uses a password and a salt"]
    #[doc = "                   to produce pseudo-random bits for a particular \"purpose\"."]
    #[doc = ""]
    #[doc = "                   Depending on the given id, this function can produce an"]
    #[doc = "                   encryption/decryption key, an nitialization vector or an"]
    #[doc = "                   integrity key."]
    #[doc = ""]
    #[doc = " \\param data       buffer to store the derived data in"]
    #[doc = " \\param datalen    length to fill"]
    #[doc = " \\param pwd        password to use (may be NULL if no password is used)"]
    #[doc = " \\param pwdlen     length of the password (may be 0)"]
    #[doc = " \\param salt       salt buffer to use"]
    #[doc = " \\param saltlen    length of the salt"]
    #[doc = " \\param mbedtls_md         mbedtls_md type to use during the derivation"]
    #[doc = " \\param id         id that describes the purpose (can be MBEDTLS_PKCS12_DERIVE_KEY,"]
    #[doc = "                   MBEDTLS_PKCS12_DERIVE_IV or MBEDTLS_PKCS12_DERIVE_MAC_KEY)"]
    #[doc = " \\param iterations number of iterations"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or a MD, BIGNUM type error."]
    #[link_name = "\u{1}mbedtls_pkcs12_derivation"]
    pub fn pkcs12_derivation(
        data: *mut crate::types::c_uchar,
        datalen: usize,
        pwd: *const crate::types::c_uchar,
        pwdlen: usize,
        salt: *const crate::types::c_uchar,
        saltlen: usize,
        mbedtls_md: md_type_t,
        id: crate::types::c_int,
        iterations: crate::types::c_int,
    ) -> crate::types::c_int;
}
#[doc = " \\brief          RIPEMD-160 context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ripemd160_context {
    #[doc = "< number of bytes processed"]
    pub total: [u32; 2usize],
    #[doc = "< intermediate digest state"]
    pub state: [u32; 5usize],
    #[doc = "< data block being processed"]
    pub buffer: [crate::types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_ripemd160_context() {
    assert_eq!(
        ::core::mem::size_of::<ripemd160_context>(),
        92usize,
        concat!("Size of: ", stringify!(ripemd160_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ripemd160_context>(),
        4usize,
        concat!("Alignment of ", stringify!(ripemd160_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ripemd160_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ripemd160_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ripemd160_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ripemd160_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ripemd160_context>())).buffer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ripemd160_context),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for ripemd160_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief          Initialize RIPEMD-160 context"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context to be initialized"]
    #[link_name = "\u{1}mbedtls_ripemd160_init"]
    pub fn ripemd160_init(ctx: *mut ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          Clear RIPEMD-160 context"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context to be cleared"]
    #[link_name = "\u{1}mbedtls_ripemd160_free"]
    pub fn ripemd160_free(ctx: *mut ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) an RIPEMD-160 context"]
    #[doc = ""]
    #[doc = " \\param dst      The destination context"]
    #[doc = " \\param src      The context to be cloned"]
    #[link_name = "\u{1}mbedtls_ripemd160_clone"]
    pub fn ripemd160_clone(dst: *mut ripemd160_context, src: *const ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 context setup"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_ripemd160_starts_ret"]
    pub fn ripemd160_starts_ret(ctx: *mut ripemd160_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process buffer"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_ripemd160_update_ret"]
    pub fn ripemd160_update_ret(
        ctx: *mut ripemd160_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 final digest"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context"]
    #[doc = " \\param output   RIPEMD-160 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_ripemd160_finish_ret"]
    pub fn ripemd160_finish_ret(
        ctx: *mut ripemd160_context,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context"]
    #[doc = " \\param data     buffer holding one block of data"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_internal_ripemd160_process"]
    pub fn internal_ripemd160_process(
        ctx: *mut ripemd160_context,
        data: *const crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 context setup"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_ripemd160_starts_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      context to be initialized"]
    #[link_name = "\u{1}mbedtls_ripemd160_starts"]
    pub fn ripemd160_starts(ctx: *mut ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process buffer"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_ripemd160_update_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context"]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[link_name = "\u{1}mbedtls_ripemd160_update"]
    pub fn ripemd160_update(
        ctx: *mut ripemd160_context,
        input: *const crate::types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 final digest"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_ripemd160_finish_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context"]
    #[doc = " \\param output   RIPEMD-160 checksum result"]
    #[link_name = "\u{1}mbedtls_ripemd160_finish"]
    pub fn ripemd160_finish(ctx: *mut ripemd160_context, output: *mut crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process data block (internal use only)"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_internal_ripemd160_process() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param ctx      RIPEMD-160 context"]
    #[doc = " \\param data     buffer holding one block of data"]
    #[link_name = "\u{1}mbedtls_ripemd160_process"]
    pub fn ripemd160_process(ctx: *mut ripemd160_context, data: *const crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          Output = RIPEMD-160( input buffer )"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   RIPEMD-160 checksum result"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_ripemd160_ret"]
    pub fn ripemd160_ret(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = RIPEMD-160( input buffer )"]
    #[doc = ""]
    #[doc = " \\deprecated     Superseded by mbedtls_ripemd160_ret() in 2.7.0"]
    #[doc = ""]
    #[doc = " \\param input    buffer holding the data"]
    #[doc = " \\param ilen     length of the input data"]
    #[doc = " \\param output   RIPEMD-160 checksum result"]
    #[link_name = "\u{1}mbedtls_ripemd160"]
    pub fn ripemd160(
        input: *const crate::types::c_uchar,
        ilen: usize,
        output: *mut crate::types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[link_name = "\u{1}mbedtls_ripemd160_self_test"]
    pub fn ripemd160_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          XTEA context structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xtea_context {
    #[doc = "< key"]
    pub k: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_xtea_context() {
    assert_eq!(
        ::core::mem::size_of::<xtea_context>(),
        16usize,
        concat!("Size of: ", stringify!(xtea_context))
    );
    assert_eq!(
        ::core::mem::align_of::<xtea_context>(),
        4usize,
        concat!("Alignment of ", stringify!(xtea_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xtea_context>())).k as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtea_context),
            "::",
            stringify!(k)
        )
    );
}
extern "C" {
    #[doc = " \\brief          Initialize XTEA context"]
    #[doc = ""]
    #[doc = " \\param ctx      XTEA context to be initialized"]
    #[link_name = "\u{1}mbedtls_xtea_init"]
    pub fn xtea_init(ctx: *mut xtea_context);
}
extern "C" {
    #[doc = " \\brief          Clear XTEA context"]
    #[doc = ""]
    #[doc = " \\param ctx      XTEA context to be cleared"]
    #[link_name = "\u{1}mbedtls_xtea_free"]
    pub fn xtea_free(ctx: *mut xtea_context);
}
extern "C" {
    #[doc = " \\brief          XTEA key schedule"]
    #[doc = ""]
    #[doc = " \\param ctx      XTEA context to be initialized"]
    #[doc = " \\param key      the secret key"]
    #[link_name = "\u{1}mbedtls_xtea_setup"]
    pub fn xtea_setup(ctx: *mut xtea_context, key: *const crate::types::c_uchar);
}
extern "C" {
    #[doc = " \\brief          XTEA cipher function"]
    #[doc = ""]
    #[doc = " \\param ctx      XTEA context"]
    #[doc = " \\param mode     MBEDTLS_XTEA_ENCRYPT or MBEDTLS_XTEA_DECRYPT"]
    #[doc = " \\param input    8-byte input block"]
    #[doc = " \\param output   8-byte output block"]
    #[doc = ""]
    #[doc = " \\return         0 if successful"]
    #[link_name = "\u{1}mbedtls_xtea_crypt_ecb"]
    pub fn xtea_crypt_ecb(
        ctx: *mut xtea_context,
        mode: crate::types::c_int,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          XTEA CBC cipher function"]
    #[doc = ""]
    #[doc = " \\param ctx      XTEA context"]
    #[doc = " \\param mode     MBEDTLS_XTEA_ENCRYPT or MBEDTLS_XTEA_DECRYPT"]
    #[doc = " \\param length   the length of input, multiple of 8"]
    #[doc = " \\param iv       initialization vector for CBC mode"]
    #[doc = " \\param input    input block"]
    #[doc = " \\param output   output block"]
    #[doc = ""]
    #[doc = " \\return         0 if successful,"]
    #[doc = "                 MBEDTLS_ERR_XTEA_INVALID_INPUT_LENGTH if the length % 8 != 0"]
    #[link_name = "\u{1}mbedtls_xtea_crypt_cbc"]
    pub fn xtea_crypt_cbc(
        ctx: *mut xtea_context,
        mode: crate::types::c_int,
        length: usize,
        iv: *mut crate::types::c_uchar,
        input: *const crate::types::c_uchar,
        output: *mut crate::types::c_uchar,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if the test failed"]
    #[link_name = "\u{1}mbedtls_xtea_self_test"]
    pub fn xtea_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief           Entropy poll callback pointer"]
#[doc = ""]
#[doc = " \\param data      Callback-specific data pointer"]
#[doc = " \\param output    Data to fill"]
#[doc = " \\param len       Maximum size to provide"]
#[doc = " \\param olen      The actual amount of bytes put into the buffer (Can be 0)"]
#[doc = ""]
#[doc = " \\return          0 if no critical failures occurred,"]
#[doc = "                  MBEDTLS_ERR_ENTROPY_SOURCE_FAILED otherwise"]
pub type entropy_f_source_ptr = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::types::c_void,
        output: *mut crate::types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> crate::types::c_int,
>;
#[doc = " \\brief           Entropy source state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct entropy_source_state {
    #[doc = "< The entropy source callback"]
    pub f_source: entropy_f_source_ptr,
    #[doc = "< The callback data pointer"]
    pub p_source: *mut crate::types::c_void,
    #[doc = "< Amount received in bytes"]
    pub size: usize,
    #[doc = "< Minimum bytes required before release"]
    pub threshold: usize,
    #[doc = "< Is the source strong?"]
    pub strong: crate::types::c_int,
}
#[test]
fn bindgen_test_layout_entropy_source_state() {
    assert_eq!(
        ::core::mem::size_of::<entropy_source_state>(),
        20usize,
        concat!("Size of: ", stringify!(entropy_source_state))
    );
    assert_eq!(
        ::core::mem::align_of::<entropy_source_state>(),
        4usize,
        concat!("Alignment of ", stringify!(entropy_source_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).f_source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(f_source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).p_source as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(p_source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).threshold as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).strong as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(strong)
        )
    );
}
impl Default for entropy_source_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " \\brief           Entropy context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entropy_context {
    pub accumulator_started: crate::types::c_int,
    pub accumulator: sha512_context,
    pub source_count: crate::types::c_int,
    pub source: [entropy_source_state; 20usize],
}
#[test]
fn bindgen_test_layout_entropy_context() {
    assert_eq!(
        ::core::mem::size_of::<entropy_context>(),
        632usize,
        concat!("Size of: ", stringify!(entropy_context))
    );
    assert_eq!(
        ::core::mem::align_of::<entropy_context>(),
        8usize,
        concat!("Alignment of ", stringify!(entropy_context))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<entropy_context>())).accumulator_started as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(accumulator_started)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_context>())).accumulator as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(accumulator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_context>())).source_count as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(source_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_context>())).source as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(source)
        )
    );
}
impl Default for entropy_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief           Initialize the context"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context to initialize"]
    #[link_name = "\u{1}mbedtls_entropy_init"]
    pub fn entropy_init(ctx: *mut entropy_context);
}
extern "C" {
    #[doc = " \\brief           Free the data in the context"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context to free"]
    #[link_name = "\u{1}mbedtls_entropy_free"]
    pub fn entropy_free(ctx: *mut entropy_context);
}
extern "C" {
    #[doc = " \\brief           Adds an entropy source to poll"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context"]
    #[doc = " \\param f_source  Entropy function"]
    #[doc = " \\param p_source  Function data"]
    #[doc = " \\param threshold Minimum required from source before entropy is released"]
    #[doc = "                  ( with mbedtls_entropy_func() ) (in bytes)"]
    #[doc = " \\param strong    MBEDTLS_ENTROPY_SOURCE_STRONG or"]
    #[doc = "                  MBEDTLS_ENTROPY_SOURCE_WEAK."]
    #[doc = "                  At least one strong source needs to be added."]
    #[doc = "                  Weaker sources (such as the cycle counter) can be used as"]
    #[doc = "                  a complement."]
    #[doc = ""]
    #[doc = " \\return          0 if successful or MBEDTLS_ERR_ENTROPY_MAX_SOURCES"]
    #[link_name = "\u{1}mbedtls_entropy_add_source"]
    pub fn entropy_add_source(
        ctx: *mut entropy_context,
        f_source: entropy_f_source_ptr,
        p_source: *mut crate::types::c_void,
        threshold: usize,
        strong: crate::types::c_int,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Trigger an extra gather poll for the accumulator"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    #[link_name = "\u{1}mbedtls_entropy_gather"]
    pub fn entropy_gather(ctx: *mut entropy_context) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Retrieve entropy from the accumulator"]
    #[doc = "                  (Maximum length: MBEDTLS_ENTROPY_BLOCK_SIZE)"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param data      Entropy context"]
    #[doc = " \\param output    Buffer to fill"]
    #[doc = " \\param len       Number of bytes desired, must be at most MBEDTLS_ENTROPY_BLOCK_SIZE"]
    #[doc = ""]
    #[doc = " \\return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    #[link_name = "\u{1}mbedtls_entropy_func"]
    pub fn entropy_func(
        data: *mut crate::types::c_void,
        output: *mut crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief           Add data to the accumulator manually"]
    #[doc = "                  (Thread-safe if MBEDTLS_THREADING_C is enabled)"]
    #[doc = ""]
    #[doc = " \\param ctx       Entropy context"]
    #[doc = " \\param data      Data to add"]
    #[doc = " \\param len       Length of data"]
    #[doc = ""]
    #[doc = " \\return          0 if successful"]
    #[link_name = "\u{1}mbedtls_entropy_update_manual"]
    pub fn entropy_update_manual(
        ctx: *mut entropy_context,
        data: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine"]
    #[doc = ""]
    #[doc = "                 This module self-test also calls the entropy self-test,"]
    #[doc = "                 mbedtls_entropy_source_self_test();"]
    #[doc = ""]
    #[doc = " \\return         0 if successful, or 1 if a test failed"]
    #[link_name = "\u{1}mbedtls_entropy_self_test"]
    pub fn entropy_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
#[doc = " \\brief          The CTR_DRBG context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctr_drbg_context {
    #[doc = "< The counter (V)."]
    pub counter: [crate::types::c_uchar; 16usize],
    #[doc = "< The reseed counter."]
    #[doc = " This is the number of requests that have"]
    #[doc = " been made since the last (re)seeding,"]
    #[doc = " minus one."]
    #[doc = " Before the initial seeding, this field"]
    #[doc = " contains the amount of entropy in bytes"]
    #[doc = " to use as a nonce for the initial seeding,"]
    #[doc = " or -1 if no nonce length has been explicitly"]
    #[doc = " set (see mbedtls_ctr_drbg_set_nonce_len())."]
    pub reseed_counter: crate::types::c_int,
    #[doc = "< This determines whether prediction"]
    #[doc = "resistance is enabled, that is"]
    #[doc = "whether to systematically reseed before"]
    #[doc = "each random generation."]
    pub prediction_resistance: crate::types::c_int,
    #[doc = "< The amount of entropy grabbed on each"]
    #[doc = "seed or reseed operation, in bytes."]
    pub entropy_len: usize,
    #[doc = "< The reseed interval."]
    #[doc = " This is the maximum number of requests"]
    #[doc = " that can be made between reseedings."]
    pub reseed_interval: crate::types::c_int,
    #[doc = "< The AES context."]
    pub aes_ctx: aes_context,
    pub f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::types::c_void,
            arg2: *mut crate::types::c_uchar,
            arg3: usize,
        ) -> crate::types::c_int,
    >,
    #[doc = "< The context for the entropy function."]
    pub p_entropy: *mut crate::types::c_void,
}
#[test]
fn bindgen_test_layout_ctr_drbg_context() {
    assert_eq!(
        ::core::mem::size_of::<ctr_drbg_context>(),
        320usize,
        concat!("Size of: ", stringify!(ctr_drbg_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ctr_drbg_context>(),
        4usize,
        concat!("Alignment of ", stringify!(ctr_drbg_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctr_drbg_context>())).reseed_counter as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(reseed_counter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctr_drbg_context>())).prediction_resistance as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(prediction_resistance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).entropy_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(entropy_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctr_drbg_context>())).reseed_interval as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(reseed_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).aes_ctx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).f_entropy as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(f_entropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).p_entropy as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(p_entropy)
        )
    );
}
impl Default for ctr_drbg_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " \\brief               This function initializes the CTR_DRBG context,"]
    #[doc = "                      and prepares it for mbedtls_ctr_drbg_seed()"]
    #[doc = "                      or mbedtls_ctr_drbg_free()."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context to initialize."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_init"]
    pub fn ctr_drbg_init(ctx: *mut ctr_drbg_context);
}
extern "C" {
    #[doc = " - The \\p custom string."]
    #[doc = ""]
    #[doc = " \\note                To achieve the nominal security strength permitted"]
    #[doc = "                      by CTR_DRBG, the entropy length must be:"]
    #[doc = "                      - at least 16 bytes for a 128-bit strength"]
    #[doc = "                      (maximum achievable strength when using AES-128);"]
    #[doc = "                      - at least 32 bytes for a 256-bit strength"]
    #[doc = "                      (maximum achievable strength when using AES-256)."]
    #[doc = ""]
    #[doc = "                      In addition, if you do not pass a nonce in \\p custom,"]
    #[doc = "                      the sum of the entropy length"]
    #[doc = "                      and the entropy nonce length must be:"]
    #[doc = "                      - at least 24 bytes for a 128-bit strength"]
    #[doc = "                      (maximum achievable strength when using AES-128);"]
    #[doc = "                      - at least 48 bytes for a 256-bit strength"]
    #[doc = "                      (maximum achievable strength when using AES-256)."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context to seed."]
    #[doc = "                      It must have been initialized with"]
    #[doc = "                      mbedtls_ctr_drbg_init()."]
    #[doc = "                      After a successful call to mbedtls_ctr_drbg_seed(),"]
    #[doc = "                      you may not call mbedtls_ctr_drbg_seed() again on"]
    #[doc = "                      the same context unless you call"]
    #[doc = "                      mbedtls_ctr_drbg_free() and mbedtls_ctr_drbg_init()"]
    #[doc = "                      again first."]
    #[doc = " \\param f_entropy     The entropy callback, taking as arguments the"]
    #[doc = "                      \\p p_entropy context, the buffer to fill, and the"]
    #[doc = "                      length of the buffer."]
    #[doc = "                      \\p f_entropy is always called with a buffer size"]
    #[doc = "                      less than or equal to the entropy length."]
    #[doc = " \\param p_entropy     The entropy context to pass to \\p f_entropy."]
    #[doc = " \\param custom        The personalization string."]
    #[doc = "                      This can be \\c NULL, in which case the personalization"]
    #[doc = "                      string is empty regardless of the value of \\p len."]
    #[doc = " \\param len           The length of the personalization string."]
    #[doc = "                      This must be at most"]
    #[doc = "                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT"]
    #[doc = "                      - #MBEDTLS_CTR_DRBG_ENTROPY_LEN."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_seed"]
    pub fn ctr_drbg_seed(
        ctx: *mut ctr_drbg_context,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::types::c_void,
                arg2: *mut crate::types::c_uchar,
                arg3: usize,
            ) -> crate::types::c_int,
        >,
        p_entropy: *mut crate::types::c_void,
        custom: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function clears CTR_CRBG context data."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context to clear."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_free"]
    pub fn ctr_drbg_free(ctx: *mut ctr_drbg_context);
}
extern "C" {
    #[doc = " \\brief               This function turns prediction resistance on or off."]
    #[doc = "                      The default value is off."]
    #[doc = ""]
    #[doc = " \\note                If enabled, entropy is gathered at the beginning of"]
    #[doc = "                      every call to mbedtls_ctr_drbg_random_with_add()"]
    #[doc = "                      or mbedtls_ctr_drbg_random()."]
    #[doc = "                      Only use this if your entropy source has sufficient"]
    #[doc = "                      throughput."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param resistance    #MBEDTLS_CTR_DRBG_PR_ON or #MBEDTLS_CTR_DRBG_PR_OFF."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_set_prediction_resistance"]
    pub fn ctr_drbg_set_prediction_resistance(
        ctx: *mut ctr_drbg_context,
        resistance: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               This function sets the amount of entropy grabbed on each"]
    #[doc = "                      seed or reseed."]
    #[doc = ""]
    #[doc = " The default value is #MBEDTLS_CTR_DRBG_ENTROPY_LEN."]
    #[doc = ""]
    #[doc = " \\note                The security strength of CTR_DRBG is bounded by the"]
    #[doc = "                      entropy length. Thus:"]
    #[doc = "                      - When using AES-256"]
    #[doc = "                        (\\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is disabled,"]
    #[doc = "                        which is the default),"]
    #[doc = "                        \\p len must be at least 32 (in bytes)"]
    #[doc = "                        to achieve a 256-bit strength."]
    #[doc = "                      - When using AES-128"]
    #[doc = "                        (\\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is enabled)"]
    #[doc = "                        \\p len must be at least 16 (in bytes)"]
    #[doc = "                        to achieve a 128-bit strength."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param len           The amount of entropy to grab, in bytes."]
    #[doc = "                      This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT"]
    #[doc = "                      and at most the maximum length accepted by the"]
    #[doc = "                      entropy function that is set in the context."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_set_entropy_len"]
    pub fn ctr_drbg_set_entropy_len(ctx: *mut ctr_drbg_context, len: usize);
}
extern "C" {
    #[doc = " \\brief               This function sets the amount of entropy grabbed"]
    #[doc = "                      as a nonce for the initial seeding."]
    #[doc = ""]
    #[doc = " Call this function before calling mbedtls_ctr_drbg_seed() to read"]
    #[doc = " a nonce from the entropy source during the initial seeding."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param len           The amount of entropy to grab for the nonce, in bytes."]
    #[doc = "                      This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT"]
    #[doc = "                      and at most the maximum length accepted by the"]
    #[doc = "                      entropy function that is set in the context."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if \\p len is"]
    #[doc = "                      more than #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED"]
    #[doc = "                      if the initial seeding has already taken place."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_set_nonce_len"]
    pub fn ctr_drbg_set_nonce_len(ctx: *mut ctr_drbg_context, len: usize) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the reseed interval."]
    #[doc = ""]
    #[doc = " The reseed interval is the number of calls to mbedtls_ctr_drbg_random()"]
    #[doc = " or mbedtls_ctr_drbg_random_with_add() after which the entropy function"]
    #[doc = " is called again."]
    #[doc = ""]
    #[doc = " The default value is #MBEDTLS_CTR_DRBG_RESEED_INTERVAL."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param interval      The reseed interval."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_set_reseed_interval"]
    pub fn ctr_drbg_set_reseed_interval(ctx: *mut ctr_drbg_context, interval: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief               This function reseeds the CTR_DRBG context, that is"]
    #[doc = "                      extracts data from the entropy source."]
    #[doc = ""]
    #[doc = " \\param ctx           The CTR_DRBG context."]
    #[doc = " \\param additional    Additional data to add to the state. Can be \\c NULL."]
    #[doc = " \\param len           The length of the additional data."]
    #[doc = "                      This must be less than"]
    #[doc = "                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \\c entropy_len"]
    #[doc = "                      where \\c entropy_len is the entropy length"]
    #[doc = "                      configured for the context."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_reseed"]
    pub fn ctr_drbg_reseed(
        ctx: *mut ctr_drbg_context,
        additional: *const crate::types::c_uchar,
        len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief              This function updates the state of the CTR_DRBG context."]
    #[doc = ""]
    #[doc = " \\param ctx          The CTR_DRBG context."]
    #[doc = " \\param additional   The data to update the state with. This must not be"]
    #[doc = "                     \\c NULL unless \\p add_len is \\c 0."]
    #[doc = " \\param add_len      Length of \\p additional in bytes. This must be at"]
    #[doc = "                     most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT."]
    #[doc = ""]
    #[doc = " \\return             \\c 0 on success."]
    #[doc = " \\return             #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if"]
    #[doc = "                     \\p add_len is more than"]
    #[doc = "                     #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT."]
    #[doc = " \\return             An error from the underlying AES cipher on failure."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_update_ret"]
    pub fn ctr_drbg_update_ret(
        ctx: *mut ctr_drbg_context,
        additional: *const crate::types::c_uchar,
        add_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function updates a CTR_DRBG instance with additional"]
    #[doc = "          data and uses it to generate random data."]
    #[doc = ""]
    #[doc = " This function automatically reseeds if the reseed counter is exceeded"]
    #[doc = " or prediction resistance is enabled."]
    #[doc = ""]
    #[doc = " \\param p_rng         The CTR_DRBG context. This must be a pointer to a"]
    #[doc = "                      #mbedtls_ctr_drbg_context structure."]
    #[doc = " \\param output        The buffer to fill."]
    #[doc = " \\param output_len    The length of the buffer in bytes."]
    #[doc = " \\param additional    Additional data to update. Can be \\c NULL, in which"]
    #[doc = "                      case the additional data is empty regardless of"]
    #[doc = "                      the value of \\p add_len."]
    #[doc = " \\param add_len       The length of the additional data"]
    #[doc = "                      if \\p additional is not \\c NULL."]
    #[doc = "                      This must be less than #MBEDTLS_CTR_DRBG_MAX_INPUT"]
    #[doc = "                      and less than"]
    #[doc = "                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \\c entropy_len"]
    #[doc = "                      where \\c entropy_len is the entropy length"]
    #[doc = "                      configured for the context."]
    #[doc = ""]
    #[doc = " \\return    \\c 0 on success."]
    #[doc = " \\return    #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or"]
    #[doc = "            #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_random_with_add"]
    pub fn ctr_drbg_random_with_add(
        p_rng: *mut crate::types::c_void,
        output: *mut crate::types::c_uchar,
        output_len: usize,
        additional: *const crate::types::c_uchar,
        add_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function uses CTR_DRBG to generate random data."]
    #[doc = ""]
    #[doc = " This function automatically reseeds if the reseed counter is exceeded"]
    #[doc = " or prediction resistance is enabled."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param p_rng         The CTR_DRBG context. This must be a pointer to a"]
    #[doc = "                      #mbedtls_ctr_drbg_context structure."]
    #[doc = " \\param output        The buffer to fill."]
    #[doc = " \\param output_len    The length of the buffer in bytes."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or"]
    #[doc = "                      #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_random"]
    pub fn ctr_drbg_random(
        p_rng: *mut crate::types::c_void,
        output: *mut crate::types::c_uchar,
        output_len: usize,
    ) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief              This function updates the state of the CTR_DRBG context."]
    #[doc = ""]
    #[doc = " \\deprecated         Superseded by mbedtls_ctr_drbg_update_ret()"]
    #[doc = "                     in 2.16.0."]
    #[doc = ""]
    #[doc = " \\note               If \\p add_len is greater than"]
    #[doc = "                     #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT, only the first"]
    #[doc = "                     #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT Bytes are used."]
    #[doc = "                     The remaining Bytes are silently discarded."]
    #[doc = ""]
    #[doc = " \\param ctx          The CTR_DRBG context."]
    #[doc = " \\param additional   The data to update the state with."]
    #[doc = " \\param add_len      Length of \\p additional data."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_update"]
    pub fn ctr_drbg_update(
        ctx: *mut ctr_drbg_context,
        additional: *const crate::types::c_uchar,
        add_len: usize,
    );
}
extern "C" {
    #[doc = " \\brief               The CTR_DRBG checkup routine."]
    #[doc = ""]
    #[doc = " \\return              \\c 0 on success."]
    #[doc = " \\return              \\c 1 on failure."]
    #[link_name = "\u{1}mbedtls_ctr_drbg_self_test"]
    pub fn ctr_drbg_self_test(verbose: crate::types::c_int) -> crate::types::c_int;
}
extern "C" {
    #[doc = " \\brief   Set the threshold error level to handle globally all debug output."]
    #[doc = "          Debug messages that have a level over the threshold value are"]
    #[doc = "          discarded."]
    #[doc = "          (Default value: 0 = No debug )"]
    #[doc = ""]
    #[doc = " \\param threshold     theshold level of messages to filter on. Messages at a"]
    #[doc = "                      higher level will be discarded."]
    #[doc = "                          - Debug levels"]
    #[doc = "                              - 0 No debug"]
    #[doc = "                              - 1 Error"]
    #[doc = "                              - 2 State change"]
    #[doc = "                              - 3 Informational"]
    #[doc = "                              - 4 Verbose"]
    #[link_name = "\u{1}mbedtls_debug_set_threshold"]
    pub fn debug_set_threshold(threshold: crate::types::c_int);
}
extern "C" {
    #[doc = " \\brief    Print a message to the debug output. This function is always used"]
    #[doc = "          through the MBEDTLS_SSL_DEBUG_MSG() macro, which supplies the ssl"]
    #[doc = "          context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the message has occurred in"]
    #[doc = " \\param line      line number the message has occurred at"]
    #[doc = " \\param format    format specifier, in printf format"]
    #[doc = " \\param ...       variables used by the format specifier"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    #[link_name = "\u{1}mbedtls_debug_print_msg"]
    pub fn debug_print_msg(
        ssl: *const ssl_context,
        level: crate::types::c_int,
        file: *const crate::types::c_char,
        line: crate::types::c_int,
        format: *const crate::types::c_char,
        ...
    );
}
extern "C" {
    #[doc = " \\brief   Print the return value of a function to the debug output. This"]
    #[doc = "          function is always used through the MBEDTLS_SSL_DEBUG_RET() macro,"]
    #[doc = "          which supplies the ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      the name of the function that returned the error"]
    #[doc = " \\param ret       the return code value"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    #[link_name = "\u{1}mbedtls_debug_print_ret"]
    pub fn debug_print_ret(
        ssl: *const ssl_context,
        level: crate::types::c_int,
        file: *const crate::types::c_char,
        line: crate::types::c_int,
        text: *const crate::types::c_char,
        ret: crate::types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief   Output a buffer of size len bytes to the debug output. This function"]
    #[doc = "          is always used through the MBEDTLS_SSL_DEBUG_BUF() macro,"]
    #[doc = "          which supplies the ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      a name or label for the buffer being dumped. Normally the"]
    #[doc = "                  variable or buffer name"]
    #[doc = " \\param buf       the buffer to be outputted"]
    #[doc = " \\param len       length of the buffer"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    #[link_name = "\u{1}mbedtls_debug_print_buf"]
    pub fn debug_print_buf(
        ssl: *const ssl_context,
        level: crate::types::c_int,
        file: *const crate::types::c_char,
        line: crate::types::c_int,
        text: *const crate::types::c_char,
        buf: *const crate::types::c_uchar,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief   Print a MPI variable to the debug output. This function is always"]
    #[doc = "          used through the MBEDTLS_SSL_DEBUG_MPI() macro, which supplies the"]
    #[doc = "          ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      a name or label for the MPI being output. Normally the"]
    #[doc = "                  variable name"]
    #[doc = " \\param X         the MPI variable"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    #[link_name = "\u{1}mbedtls_debug_print_mpi"]
    pub fn debug_print_mpi(
        ssl: *const ssl_context,
        level: crate::types::c_int,
        file: *const crate::types::c_char,
        line: crate::types::c_int,
        text: *const crate::types::c_char,
        X: *const mpi,
    );
}
extern "C" {
    #[doc = " \\brief   Print an ECP point to the debug output. This function is always"]
    #[doc = "          used through the MBEDTLS_SSL_DEBUG_ECP() macro, which supplies the"]
    #[doc = "          ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      a name or label for the ECP point being output. Normally the"]
    #[doc = "                  variable name"]
    #[doc = " \\param X         the ECP point"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    #[link_name = "\u{1}mbedtls_debug_print_ecp"]
    pub fn debug_print_ecp(
        ssl: *const ssl_context,
        level: crate::types::c_int,
        file: *const crate::types::c_char,
        line: crate::types::c_int,
        text: *const crate::types::c_char,
        X: *const ecp_point,
    );
}
extern "C" {
    #[doc = " \\brief   Print a X.509 certificate structure to the debug output. This"]
    #[doc = "          function is always used through the MBEDTLS_SSL_DEBUG_CRT() macro,"]
    #[doc = "          which supplies the ssl context, file and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param text      a name or label for the certificate being output"]
    #[doc = " \\param crt       X.509 certificate structure"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    #[link_name = "\u{1}mbedtls_debug_print_crt"]
    pub fn debug_print_crt(
        ssl: *const ssl_context,
        level: crate::types::c_int,
        file: *const crate::types::c_char,
        line: crate::types::c_int,
        text: *const crate::types::c_char,
        crt: *const x509_crt,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum debug_ecdh_attr {
    DEBUG_ECDH_Q = 0,
    DEBUG_ECDH_QP = 1,
    DEBUG_ECDH_Z = 2,
}
extern "C" {
    #[doc = " \\brief   Print a field of the ECDH structure in the SSL context to the debug"]
    #[doc = "          output. This function is always used through the"]
    #[doc = "          MBEDTLS_SSL_DEBUG_ECDH() macro, which supplies the ssl context, file"]
    #[doc = "          and line number parameters."]
    #[doc = ""]
    #[doc = " \\param ssl       SSL context"]
    #[doc = " \\param level     error level of the debug message"]
    #[doc = " \\param file      file the error has occurred in"]
    #[doc = " \\param line      line number the error has occurred in"]
    #[doc = " \\param ecdh      the ECDH context"]
    #[doc = " \\param attr      the identifier of the attribute being output"]
    #[doc = ""]
    #[doc = " \\attention       This function is intended for INTERNAL usage within the"]
    #[doc = "                  library only."]
    #[link_name = "\u{1}mbedtls_debug_printf_ecdh"]
    pub fn debug_printf_ecdh(
        ssl: *const ssl_context,
        level: crate::types::c_int,
        file: *const crate::types::c_char,
        line: crate::types::c_int,
        ecdh: *const ecdh_context,
        attr: debug_ecdh_attr,
    );
}
pub type __builtin_va_list = __va_list;
